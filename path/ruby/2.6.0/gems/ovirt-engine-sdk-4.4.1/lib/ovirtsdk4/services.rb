#
# Copyright (c) 2015-2016 Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


# 
# These forward declarations are required in order to avoid circular dependencies.
# 
module OvirtSDK4
  
  class AffinityGroupService < Service
  end
  
  class AffinityGroupHostService < Service
  end
  
  class AffinityGroupHostLabelService < Service
  end
  
  class AffinityGroupHostLabelsService < Service
  end
  
  class AffinityGroupHostsService < Service
  end
  
  class AffinityGroupVmService < Service
  end
  
  class AffinityGroupVmLabelService < Service
  end
  
  class AffinityGroupVmLabelsService < Service
  end
  
  class AffinityGroupVmsService < Service
  end
  
  class AffinityGroupsService < Service
  end
  
  class AffinityLabelService < Service
  end
  
  class AffinityLabelHostService < Service
  end
  
  class AffinityLabelHostsService < Service
  end
  
  class AffinityLabelVmService < Service
  end
  
  class AffinityLabelVmsService < Service
  end
  
  class AffinityLabelsService < Service
  end
  
  class AreaService < Service
  end
  
  class AssignedAffinityLabelService < Service
  end
  
  class AssignedAffinityLabelsService < Service
  end
  
  class AssignedCpuProfileService < Service
  end
  
  class AssignedCpuProfilesService < Service
  end
  
  class AssignedDiskProfileService < Service
  end
  
  class AssignedDiskProfilesService < Service
  end
  
  class AssignedPermissionsService < Service
  end
  
  class AssignedRolesService < Service
  end
  
  class AssignedTagService < Service
  end
  
  class AssignedTagsService < Service
  end
  
  class AssignedVnicProfileService < Service
  end
  
  class AssignedVnicProfilesService < Service
  end
  
  class AttachedStorageDomainService < Service
  end
  
  class AttachedStorageDomainDisksService < Service
  end
  
  class AttachedStorageDomainsService < Service
  end
  
  class BalanceService < Service
  end
  
  class BalancesService < Service
  end
  
  class BookmarkService < Service
  end
  
  class BookmarksService < Service
  end
  
  class ClusterService < Service
  end
  
  class ClusterEnabledFeatureService < Service
  end
  
  class ClusterEnabledFeaturesService < Service
  end
  
  class ClusterExternalProvidersService < Service
  end
  
  class ClusterFeatureService < Service
  end
  
  class ClusterFeaturesService < Service
  end
  
  class ClusterLevelService < Service
  end
  
  class ClusterLevelsService < Service
  end
  
  class ClusterNetworkService < Service
  end
  
  class ClusterNetworksService < Service
  end
  
  class ClustersService < Service
  end
  
  class CopyableService < Service
  end
  
  class CpuProfileService < Service
  end
  
  class CpuProfilesService < Service
  end
  
  class DataCenterService < Service
  end
  
  class DataCenterNetworkService < Service
  end
  
  class DataCenterNetworksService < Service
  end
  
  class DataCentersService < Service
  end
  
  class DiskAttachmentService < Service
  end
  
  class DiskAttachmentsService < Service
  end
  
  class DiskProfileService < Service
  end
  
  class DiskProfilesService < Service
  end
  
  class DiskSnapshotService < Service
  end
  
  class DiskSnapshotsService < Service
  end
  
  class DisksService < Service
  end
  
  class DomainService < Service
  end
  
  class DomainGroupService < Service
  end
  
  class DomainGroupsService < Service
  end
  
  class DomainUserService < Service
  end
  
  class DomainUserGroupsService < Service
  end
  
  class DomainUsersService < Service
  end
  
  class DomainsService < Service
  end
  
  class EventService < Service
  end
  
  class EventSubscriptionService < Service
  end
  
  class EventSubscriptionsService < Service
  end
  
  class EventsService < Service
  end
  
  class ExternalComputeResourceService < Service
  end
  
  class ExternalComputeResourcesService < Service
  end
  
  class ExternalDiscoveredHostService < Service
  end
  
  class ExternalDiscoveredHostsService < Service
  end
  
  class ExternalHostService < Service
  end
  
  class ExternalHostGroupService < Service
  end
  
  class ExternalHostGroupsService < Service
  end
  
  class ExternalHostProvidersService < Service
  end
  
  class ExternalHostsService < Service
  end
  
  class ExternalNetworkProviderConfigurationService < Service
  end
  
  class ExternalNetworkProviderConfigurationsService < Service
  end
  
  class ExternalProviderService < Service
  end
  
  class ExternalProviderCertificateService < Service
  end
  
  class ExternalProviderCertificatesService < Service
  end
  
  class ExternalVmImportsService < Service
  end
  
  class FenceAgentService < Service
  end
  
  class FenceAgentsService < Service
  end
  
  class FileService < Service
  end
  
  class FilesService < Service
  end
  
  class FilterService < Service
  end
  
  class FiltersService < Service
  end
  
  class FollowService < Service
  end
  
  class GlusterBricksService < Service
  end
  
  class GlusterHookService < Service
  end
  
  class GlusterHooksService < Service
  end
  
  class GlusterVolumesService < Service
  end
  
  class GroupService < Service
  end
  
  class GroupsService < Service
  end
  
  class HostDeviceService < Service
  end
  
  class HostDevicesService < Service
  end
  
  class HostHookService < Service
  end
  
  class HostHooksService < Service
  end
  
  class HostNicsService < Service
  end
  
  class HostNumaNodesService < Service
  end
  
  class HostStorageService < Service
  end
  
  class HostsService < Service
  end
  
  class IconService < Service
  end
  
  class IconsService < Service
  end
  
  class ImageService < Service
  end
  
  class ImageTransferService < Service
  end
  
  class ImageTransfersService < Service
  end
  
  class ImagesService < Service
  end
  
  class InstanceTypeService < Service
  end
  
  class InstanceTypeGraphicsConsoleService < Service
  end
  
  class InstanceTypeGraphicsConsolesService < Service
  end
  
  class InstanceTypeNicService < Service
  end
  
  class InstanceTypeNicsService < Service
  end
  
  class InstanceTypeWatchdogService < Service
  end
  
  class InstanceTypeWatchdogsService < Service
  end
  
  class InstanceTypesService < Service
  end
  
  class IscsiBondService < Service
  end
  
  class IscsiBondsService < Service
  end
  
  class JobService < Service
  end
  
  class JobsService < Service
  end
  
  class KatelloErrataService < Service
  end
  
  class KatelloErratumService < Service
  end
  
  class LinkLayerDiscoveryProtocolService < Service
  end
  
  class MacPoolService < Service
  end
  
  class MacPoolsService < Service
  end
  
  class MeasurableService < Service
  end
  
  class MoveableService < Service
  end
  
  class NetworkService < Service
  end
  
  class NetworkAttachmentService < Service
  end
  
  class NetworkAttachmentsService < Service
  end
  
  class NetworkFilterService < Service
  end
  
  class NetworkFiltersService < Service
  end
  
  class NetworkLabelService < Service
  end
  
  class NetworkLabelsService < Service
  end
  
  class NetworksService < Service
  end
  
  class NicNetworkFilterParameterService < Service
  end
  
  class NicNetworkFilterParametersService < Service
  end
  
  class OpenstackImageService < Service
  end
  
  class OpenstackImageProviderService < ExternalProviderService
  end
  
  class OpenstackImageProvidersService < Service
  end
  
  class OpenstackImagesService < Service
  end
  
  class OpenstackNetworkService < Service
  end
  
  class OpenstackNetworkProviderService < ExternalProviderService
  end
  
  class OpenstackNetworkProvidersService < Service
  end
  
  class OpenstackNetworksService < Service
  end
  
  class OpenstackSubnetService < Service
  end
  
  class OpenstackSubnetsService < Service
  end
  
  class OpenstackVolumeAuthenticationKeyService < Service
  end
  
  class OpenstackVolumeAuthenticationKeysService < Service
  end
  
  class OpenstackVolumeProviderService < ExternalProviderService
  end
  
  class OpenstackVolumeProvidersService < Service
  end
  
  class OpenstackVolumeTypeService < Service
  end
  
  class OpenstackVolumeTypesService < Service
  end
  
  class OperatingSystemService < Service
  end
  
  class OperatingSystemsService < Service
  end
  
  class PermissionService < Service
  end
  
  class PermitService < Service
  end
  
  class PermitsService < Service
  end
  
  class QosService < Service
  end
  
  class QossService < Service
  end
  
  class QuotaService < Service
  end
  
  class QuotaClusterLimitService < Service
  end
  
  class QuotaClusterLimitsService < Service
  end
  
  class QuotaStorageLimitService < Service
  end
  
  class QuotaStorageLimitsService < Service
  end
  
  class QuotasService < Service
  end
  
  class RoleService < Service
  end
  
  class RolesService < Service
  end
  
  class SchedulingPoliciesService < Service
  end
  
  class SchedulingPolicyService < Service
  end
  
  class SchedulingPolicyUnitService < Service
  end
  
  class SchedulingPolicyUnitsService < Service
  end
  
  class SnapshotService < Service
  end
  
  class SnapshotCdromService < Service
  end
  
  class SnapshotCdromsService < Service
  end
  
  class SnapshotDiskService < Service
  end
  
  class SnapshotDisksService < Service
  end
  
  class SnapshotNicService < Service
  end
  
  class SnapshotNicsService < Service
  end
  
  class SnapshotsService < Service
  end
  
  class SshPublicKeyService < Service
  end
  
  class SshPublicKeysService < Service
  end
  
  class StatisticService < Service
  end
  
  class StatisticsService < Service
  end
  
  class StepService < MeasurableService
  end
  
  class StepsService < Service
  end
  
  class StorageService < Service
  end
  
  class StorageDomainService < Service
  end
  
  class StorageDomainContentDiskService < Service
  end
  
  class StorageDomainContentDisksService < Service
  end
  
  class StorageDomainDiskService < MeasurableService
  end
  
  class StorageDomainDisksService < Service
  end
  
  class StorageDomainServerConnectionService < Service
  end
  
  class StorageDomainServerConnectionsService < Service
  end
  
  class StorageDomainTemplateService < Service
  end
  
  class StorageDomainTemplatesService < Service
  end
  
  class StorageDomainVmService < Service
  end
  
  class StorageDomainVmDiskAttachmentService < Service
  end
  
  class StorageDomainVmDiskAttachmentsService < Service
  end
  
  class StorageDomainVmsService < Service
  end
  
  class StorageDomainsService < Service
  end
  
  class StorageServerConnectionService < Service
  end
  
  class StorageServerConnectionExtensionService < Service
  end
  
  class StorageServerConnectionExtensionsService < Service
  end
  
  class StorageServerConnectionsService < Service
  end
  
  class SystemService < Service
  end
  
  class SystemOptionService < Service
  end
  
  class SystemOptionsService < Service
  end
  
  class SystemPermissionsService < AssignedPermissionsService
  end
  
  class TagService < Service
  end
  
  class TagsService < Service
  end
  
  class TemplateService < Service
  end
  
  class TemplateCdromService < Service
  end
  
  class TemplateCdromsService < Service
  end
  
  class TemplateDiskService < Service
  end
  
  class TemplateDiskAttachmentService < Service
  end
  
  class TemplateDiskAttachmentsService < Service
  end
  
  class TemplateDisksService < Service
  end
  
  class TemplateGraphicsConsoleService < Service
  end
  
  class TemplateGraphicsConsolesService < Service
  end
  
  class TemplateNicService < Service
  end
  
  class TemplateNicsService < Service
  end
  
  class TemplateWatchdogService < Service
  end
  
  class TemplateWatchdogsService < Service
  end
  
  class TemplatesService < Service
  end
  
  class UnmanagedNetworkService < Service
  end
  
  class UnmanagedNetworksService < Service
  end
  
  class UserService < Service
  end
  
  class UserOptionService < Service
  end
  
  class UserOptionsService < Service
  end
  
  class UsersService < Service
  end
  
  class VirtualFunctionAllowedNetworkService < Service
  end
  
  class VirtualFunctionAllowedNetworksService < Service
  end
  
  class VmService < MeasurableService
  end
  
  class VmApplicationService < Service
  end
  
  class VmApplicationsService < Service
  end
  
  class VmBackupService < Service
  end
  
  class VmBackupDiskService < Service
  end
  
  class VmBackupDisksService < Service
  end
  
  class VmBackupsService < Service
  end
  
  class VmCdromService < Service
  end
  
  class VmCdromsService < Service
  end
  
  class VmCheckpointService < Service
  end
  
  class VmCheckpointDiskService < Service
  end
  
  class VmCheckpointDisksService < Service
  end
  
  class VmCheckpointsService < Service
  end
  
  class VmDiskService < MeasurableService
  end
  
  class VmDisksService < Service
  end
  
  class VmGraphicsConsoleService < Service
  end
  
  class VmGraphicsConsolesService < Service
  end
  
  class VmHostDeviceService < Service
  end
  
  class VmHostDevicesService < Service
  end
  
  class VmNicService < MeasurableService
  end
  
  class VmNicsService < Service
  end
  
  class VmNumaNodeService < Service
  end
  
  class VmNumaNodesService < Service
  end
  
  class VmPoolService < Service
  end
  
  class VmPoolsService < Service
  end
  
  class VmReportedDeviceService < Service
  end
  
  class VmReportedDevicesService < Service
  end
  
  class VmSessionService < Service
  end
  
  class VmSessionsService < Service
  end
  
  class VmWatchdogService < Service
  end
  
  class VmWatchdogsService < Service
  end
  
  class VmsService < Service
  end
  
  class VnicProfileService < Service
  end
  
  class VnicProfilesService < Service
  end
  
  class WeightService < Service
  end
  
  class WeightsService < Service
  end
  
  class AttachedStorageDomainDiskService < MeasurableService
  end
  
  class DiskService < MeasurableService
  end
  
  class EngineKatelloErrataService < KatelloErrataService
  end
  
  class ExternalHostProviderService < ExternalProviderService
  end
  
  class GlusterBrickService < MeasurableService
  end
  
  class GlusterVolumeService < MeasurableService
  end
  
  class HostService < MeasurableService
  end
  
  class HostNicService < MeasurableService
  end
  
  class HostNumaNodeService < MeasurableService
  end
  
  class AffinityGroupService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieve the affinity group details.
    # 
    # [source,xml]
    # ----
    # <affinity_group id="00000000-0000-0000-0000-000000000000">
    #   <name>AF_GROUP_001</name>
    #   <cluster id="00000000-0000-0000-0000-000000000000"/>
    #   <positive>true</positive>
    #   <enforcing>true</enforcing>
    # </affinity_group>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityGroup]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the affinity group.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the removal should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the affinity group.
    # 
    # @param group [AffinityGroup] The affinity group.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityGroup]
    # 
    def update(group, opts = {})
      internal_update(group, AffinityGroup, UPDATE, opts)
    end
    
    # 
    # Returns a reference to the service that manages the
    # list of all host labels attached to this affinity
    # group.
    # 
    # @return [AffinityGroupHostLabelsService] A reference to `host_labels` service.
    # 
    def host_labels_service
      @host_labels_service ||= AffinityGroupHostLabelsService.new(self, 'hostlabels')
    end
    
    # 
    # Returns a reference to the service that manages the
    # list of all hosts attached to this affinity
    # group.
    # 
    # @return [AffinityGroupHostsService] A reference to `hosts` service.
    # 
    def hosts_service
      @hosts_service ||= AffinityGroupHostsService.new(self, 'hosts')
    end
    
    # 
    # Returns a reference to the service that manages the
    # list of all virtual machine labels attached to this affinity
    # group.
    # 
    # @return [AffinityGroupVmLabelsService] A reference to `vm_labels` service.
    # 
    def vm_labels_service
      @vm_labels_service ||= AffinityGroupVmLabelsService.new(self, 'vmlabels')
    end
    
    # 
    # Returns a reference to the service that manages the
    # list of all virtual machines attached to this affinity
    # group.
    # 
    # @return [AffinityGroupVmsService] A reference to `vms` service.
    # 
    def vms_service
      @vms_service ||= AffinityGroupVmsService.new(self, 'vms')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'hostlabels'
        return host_labels_service
      end
      if path.start_with?('hostlabels/')
        return host_labels_service.service(path[11..-1])
      end
      if path == 'hosts'
        return hosts_service
      end
      if path.start_with?('hosts/')
        return hosts_service.service(path[6..-1])
      end
      if path == 'vmlabels'
        return vm_labels_service
      end
      if path.start_with?('vmlabels/')
        return vm_labels_service.service(path[9..-1])
      end
      if path == 'vms'
        return vms_service
      end
      if path.start_with?('vms/')
        return vms_service.service(path[4..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityGroupHostService < Service
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove host from the affinity group.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the removal should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityGroupHostLabelService < Service
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove this label from the affinity group.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the removal should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityGroupHostLabelsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a host label to the affinity group.
    # 
    # For example, to add the label `789` to the affinity group `456` of cluster `123`,
    # send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/clusters/123/affinitygroups/456/hostlabels
    # ....
    # 
    # With the following body:
    # 
    # [source,xml]
    # ----
    # <affinity_label id="789"/>
    # ----
    # 
    # @param label [AffinityLabel] The AffinityLabel object to add to the affinity group.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityLabel]
    # 
    def add(label, opts = {})
      internal_add(label, AffinityLabel, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all host labels assigned to this affinity group.
    # 
    # The order of the returned labels isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of host labels to return.
    #   If not specified, all the labels are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<AffinityLabel>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Access the service that manages the host label assignment to this affinity group.
    # 
    # @param id [String] The identifier of the `label`.
    # 
    # @return [AffinityGroupHostLabelService] A reference to the `label` service.
    # 
    def label_service(id)
      AffinityGroupHostLabelService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return label_service(path)
      end
      return label_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AffinityGroupHostsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a host to the affinity group.
    # 
    # For example, to add the host `789` to the affinity group `456` of cluster `123`, send a request like
    # this:
    # 
    # ....
    # POST /ovirt-engine/api/clusters/123/affinitygroups/456/hosts
    # ....
    # 
    # With the following body:
    # 
    # [source,xml]
    # ----
    # <host id="789"/>
    # ----
    # 
    # @param host [Host] The host to be added to the affinity group.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def add(host, opts = {})
      internal_add(host, Host, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all hosts assigned to this affinity group.
    # 
    # The order of the returned hosts isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of hosts to return. If not specified, all the hosts are
    #   returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Host>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Access the service that manages the host assignment to this affinity group.
    # 
    # @param id [String] The identifier of the `host`.
    # 
    # @return [AffinityGroupHostService] A reference to the `host` service.
    # 
    def host_service(id)
      AffinityGroupHostService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return host_service(path)
      end
      return host_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AffinityGroupVmService < Service
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove this virtual machine from the affinity group.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the removal should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityGroupVmLabelService < Service
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove this label from the affinity group.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the removal should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityGroupVmLabelsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a virtual machine label to the affinity group.
    # 
    # For example, to add the label `789` to the affinity group `456` of cluster `123`,
    # send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/clusters/123/affinitygroups/456/vmlabels
    # ....
    # 
    # With the following body:
    # 
    # [source,xml]
    # ----
    # <affinity_label id="789"/>
    # ----
    # 
    # @param label [AffinityLabel] The AffinityLabel object to add to the affinity group.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityLabel]
    # 
    def add(label, opts = {})
      internal_add(label, AffinityLabel, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all virtual machine labels assigned to this affinity group.
    # 
    # The order of the returned labels isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of virtual machine labels to return.
    #   If not specified, all the labels are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<AffinityLabel>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Access the service that manages the virtual machine label assignment to this affinity group.
    # 
    # @param id [String] The identifier of the `label`.
    # 
    # @return [AffinityGroupVmLabelService] A reference to the `label` service.
    # 
    def label_service(id)
      AffinityGroupVmLabelService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return label_service(path)
      end
      return label_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AffinityGroupVmsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a virtual machine to the affinity group.
    # 
    # For example, to add the virtual machine `789` to the affinity group `456` of cluster `123`, send a request like
    # this:
    # 
    # ....
    # POST /ovirt-engine/api/clusters/123/affinitygroups/456/vms
    # ....
    # 
    # With the following body:
    # 
    # [source,xml]
    # ----
    # <vm id="789"/>
    # ----
    # 
    # @param vm [Vm] The `vm` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def add(vm, opts = {})
      internal_add(vm, Vm, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all virtual machines assigned to this affinity group.
    # 
    # The order of the returned virtual machines isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of virtual machines to return. If not specified, all the virtual machines are
    #   returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Vm>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Access the service that manages the virtual machine assignment to this affinity group.
    # 
    # @param id [String] The identifier of the `vm`.
    # 
    # @return [AffinityGroupVmService] A reference to the `vm` service.
    # 
    def vm_service(id)
      AffinityGroupVmService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return vm_service(path)
      end
      return vm_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AffinityGroupsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Create a new affinity group.
    # 
    # Post a request like in the example below to create a new affinity group:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/000-000/affinitygroups
    # ----
    # 
    # And use the following example in its body:
    # 
    # [source,xml]
    # ----
    # <affinity_group>
    #   <name>AF_GROUP_001</name>
    #   <hosts_rule>
    #     <enforcing>true</enforcing>
    #     <positive>true</positive>
    #   </hosts_rule>
    #   <vms_rule>
    #     <enabled>false</enabled>
    #   </vms_rule>
    # </affinity_group>
    # ----
    # 
    # @param group [AffinityGroup] The affinity group object to create.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityGroup]
    # 
    def add(group, opts = {})
      internal_add(group, AffinityGroup, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List existing affinity groups.
    # 
    # The order of the affinity groups results isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of affinity groups to return. If not specified all the affinity groups are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<AffinityGroup>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Access the affinity group service that manages the affinity group specified by an ID.
    # 
    # @param id [String] The identifier of the `group`.
    # 
    # @return [AffinityGroupService] A reference to the `group` service.
    # 
    def group_service(id)
      AffinityGroupService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return group_service(path)
      end
      return group_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AffinityLabelService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the details of a label.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityLabel]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a label from the system and clears all assignments
    # of the removed label.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates a label. This call will update all metadata, such as the name
    # or description.
    # 
    # @param label [AffinityLabel] The `label` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityLabel]
    # 
    def update(label, opts = {})
      internal_update(label, AffinityLabel, UPDATE, opts)
    end
    
    # 
    # List all hosts with this label.
    # 
    # @return [AffinityLabelHostsService] A reference to `hosts` service.
    # 
    def hosts_service
      @hosts_service ||= AffinityLabelHostsService.new(self, 'hosts')
    end
    
    # 
    # List all virtual machines with this label.
    # 
    # @return [AffinityLabelVmsService] A reference to `vms` service.
    # 
    def vms_service
      @vms_service ||= AffinityLabelVmsService.new(self, 'vms')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'hosts'
        return hosts_service
      end
      if path.start_with?('hosts/')
        return hosts_service.service(path[6..-1])
      end
      if path == 'vms'
        return vms_service
      end
      if path.start_with?('vms/')
        return vms_service.service(path[4..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityLabelHostService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves details about a host that has this label assigned.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove a label from a host.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityLabelHostsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a label to a host.
    # 
    # @param host [Host] The `host` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def add(host, opts = {})
      internal_add(host, Host, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all hosts with the label.
    # 
    # The order of the returned hosts isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Host>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A link to the specific label-host assignment to
    # allow label removal.
    # 
    # @param id [String] The identifier of the `host`.
    # 
    # @return [AffinityLabelHostService] A reference to the `host` service.
    # 
    def host_service(id)
      AffinityLabelHostService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return host_service(path)
      end
      return host_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AffinityLabelVmService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves details about a vm that has this label assigned.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove a label from a vm.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AffinityLabelVmsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a label to a vm.
    # 
    # @param vm [Vm] The `vm` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def add(vm, opts = {})
      internal_add(vm, Vm, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all virtual machines with the label.
    # 
    # The order of the returned virtual machines isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Vm>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A link to the specific label-vm assignment to
    # allow label removal.
    # 
    # @param id [String] The identifier of the `vm`.
    # 
    # @return [AffinityLabelVmService] A reference to the `vm` service.
    # 
    def vm_service(id)
      AffinityLabelVmService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return vm_service(path)
      end
      return vm_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AffinityLabelsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new label. The label is automatically attached
    # to all entities mentioned in the vms or hosts lists.
    # 
    # @param label [AffinityLabel] The `label` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityLabel]
    # 
    def add(label, opts = {})
      internal_add(label, AffinityLabel, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all labels present in the system.
    # 
    # The order of the returned labels isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of labels to return. If not specified all the labels are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<AffinityLabel>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Link to a single label details.
    # 
    # @param id [String] The identifier of the `label`.
    # 
    # @return [AffinityLabelService] A reference to the `label` service.
    # 
    def label_service(id)
      AffinityLabelService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return label_service(path)
      end
      return label_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AreaService < Service
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AssignedAffinityLabelService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves details about the attached label.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityLabel]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the label from an entity. Does not touch the label itself.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AssignedAffinityLabelsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Attaches a label to an entity.
    # 
    # @param label [AffinityLabel] The `label` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [AffinityLabel]
    # 
    def add(label, opts = {})
      internal_add(label, AffinityLabel, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all labels that are attached to an entity.
    # 
    # The order of the returned entities isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<AffinityLabel>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Link to the specific entity-label assignment to allow
    # removal.
    # 
    # @param id [String] The identifier of the `label`.
    # 
    # @return [AssignedAffinityLabelService] A reference to the `label` service.
    # 
    def label_service(id)
      AssignedAffinityLabelService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return label_service(path)
      end
      return label_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AssignedCpuProfileService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [CpuProfile]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AssignedCpuProfilesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new cpu profile for the cluster.
    # 
    # @param profile [CpuProfile] The `profile` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [CpuProfile]
    # 
    def add(profile, opts = {})
      internal_add(profile, CpuProfile, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the CPU profiles assigned to the cluster.
    # 
    # The order of the returned CPU profiles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of profiles to return. If not specified all the profiles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<CpuProfile>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `profile` service.
    # 
    # @param id [String] The identifier of the `profile`.
    # 
    # @return [AssignedCpuProfileService] A reference to the `profile` service.
    # 
    def profile_service(id)
      AssignedCpuProfileService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return profile_service(path)
      end
      return profile_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AssignedDiskProfileService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskProfile]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AssignedDiskProfilesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new disk profile for the storage domain.
    # 
    # @param profile [DiskProfile] The `profile` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskProfile]
    # 
    def add(profile, opts = {})
      internal_add(profile, DiskProfile, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disk profiles assigned to the storage domain.
    # 
    # The order of the returned disk profiles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of profiles to return. If not specified all the profiles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<DiskProfile>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `profile` service.
    # 
    # @param id [String] The identifier of the `profile`.
    # 
    # @return [AssignedDiskProfileService] A reference to the `profile` service.
    # 
    def profile_service(id)
      AssignedDiskProfileService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return profile_service(path)
      end
      return profile_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AssignedPermissionsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Assign a new permission to a user or group for specific entity.
    # 
    # For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
    # send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/vms/123/permissions
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <permission>
    #   <role>
    #     <name>UserVmManager</name>
    #   </role>
    #   <user id="456"/>
    # </permission>
    # ----
    # 
    # To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/permissions
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <permission>
    #   <role>
    #     <name>SuperUser</name>
    #   </role>
    #   <user id="456"/>
    # </permission>
    # ----
    # 
    # If you want to assign permission to the group instead of the user please replace the `user` element with the
    # `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
    # id `123` to the group with id `789` send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/clusters/123/permissions
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <permission>
    #   <role>
    #     <name>UserRole</name>
    #   </role>
    #   <group id="789"/>
    # </permission>
    # ----
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add(permission, opts = {})
      internal_add(permission, Permission, ADD, opts)
    end
    
    ADD_CLUSTER_PERMISSION = [
    ].freeze
    
    private_constant :ADD_CLUSTER_PERMISSION
    
    # 
    # Add a new permission on the cluster to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_cluster_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_CLUSTER_PERMISSION, opts)
    end
    
    ADD_DATA_CENTER_PERMISSION = [
    ].freeze
    
    private_constant :ADD_DATA_CENTER_PERMISSION
    
    # 
    # Add a new permission on the data center to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_data_center_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_DATA_CENTER_PERMISSION, opts)
    end
    
    ADD_GROUP_LEVEL = [
    ].freeze
    
    private_constant :ADD_GROUP_LEVEL
    
    # 
    # Add a new group level permission for a given virtual machine.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_group_level(permission, opts = {})
      internal_add(permission, Permission, ADD_GROUP_LEVEL, opts)
    end
    
    ADD_HOST_PERMISSION = [
    ].freeze
    
    private_constant :ADD_HOST_PERMISSION
    
    # 
    # Add a new permission on the host to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_host_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_HOST_PERMISSION, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all the permissions of the specific entity.
    # 
    # For example to list all the permissions of the cluster with id `123` send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/clusters/123/permissions
    # ....
    # 
    # [source,xml]
    # ----
    # <permissions>
    #   <permission id="456">
    #     <cluster id="123"/>
    #     <role id="789"/>
    #     <user id="451"/>
    #   </permission>
    #   <permission id="654">
    #     <cluster id="123"/>
    #     <role id="789"/>
    #     <group id="127"/>
    #   </permission>
    # </permissions>
    # ----
    # 
    # The order of the returned permissions isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Permission>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    ADD_STORAGE_DOMAIN_PERMISSION = [
    ].freeze
    
    private_constant :ADD_STORAGE_DOMAIN_PERMISSION
    
    # 
    # Add a new permission on the storage domain to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_storage_domain_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_STORAGE_DOMAIN_PERMISSION, opts)
    end
    
    ADD_TEMPLATE_PERMISSION = [
    ].freeze
    
    private_constant :ADD_TEMPLATE_PERMISSION
    
    # 
    # Add a new permission on the template to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_template_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_TEMPLATE_PERMISSION, opts)
    end
    
    ADD_USER_LEVEL = [
    ].freeze
    
    private_constant :ADD_USER_LEVEL
    
    # 
    # Add a new user level permission for a given virtual machine.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_user_level(permission, opts = {})
      internal_add(permission, Permission, ADD_USER_LEVEL, opts)
    end
    
    ADD_VM_PERMISSION = [
    ].freeze
    
    private_constant :ADD_VM_PERMISSION
    
    # 
    # Add a new permission on the vm to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_vm_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_VM_PERMISSION, opts)
    end
    
    ADD_VM_POOL_PERMISSION = [
    ].freeze
    
    private_constant :ADD_VM_POOL_PERMISSION
    
    # 
    # Add a new permission on the vm pool to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_vm_pool_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_VM_POOL_PERMISSION, opts)
    end
    
    # 
    # Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
    # dispatched.
    # 
    # @param id [String] The identifier of the `permission`.
    # 
    # @return [PermissionService] A reference to the `permission` service.
    # 
    def permission_service(id)
      PermissionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return permission_service(path)
      end
      return permission_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AssignedRolesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the roles assigned to the permission.
    # 
    # The order of the returned roles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of roles to return. If not specified all the roles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Role>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
    # 
    # @param id [String] The identifier of the `role`.
    # 
    # @return [RoleService] A reference to the `role` service.
    # 
    def role_service(id)
      RoleService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return role_service(path)
      end
      return role_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AssignedTagService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the information about the assigned tag.
    # 
    # For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
    # with id `123` send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/vms/123/tags/456
    # ....
    # 
    # [source,xml]
    # ----
    # <tag href="/ovirt-engine/api/tags/456" id="456">
    #   <name>root</name>
    #   <description>root</description>
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    # </tag>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Tag]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Unassign tag from specific entity in the system.
    # 
    # For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
    # 
    # ....
    # DELETE /ovirt-engine/api/vms/123/tags/456
    # ....
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AssignedTagsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Assign tag to specific entity in the system.
    # 
    # For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/vms/123/tags
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <tag>
    #   <name>mytag</name>
    # </tag>
    # ----
    # 
    # @param tag [Tag] The assigned tag.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Tag]
    # 
    def add(tag, opts = {})
      internal_add(tag, Tag, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all tags assigned to the specific entity.
    # 
    # For example to list all the tags of the virtual machine with id `123` send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/vms/123/tags
    # ....
    # 
    # [source,xml]
    # ----
    # <tags>
    #   <tag href="/ovirt-engine/api/tags/222" id="222">
    #     <name>mytag</name>
    #     <description>mytag</description>
    #     <vm href="/ovirt-engine/api/vms/123" id="123"/>
    #   </tag>
    # </tags>
    # ----
    # 
    # The order of the returned tags isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of tags to return. If not specified all the tags are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Tag>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages assignment of specific tag.
    # 
    # @param id [String] The identifier of the `tag`.
    # 
    # @return [AssignedTagService] A reference to the `tag` service.
    # 
    def tag_service(id)
      AssignedTagService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return tag_service(path)
      end
      return tag_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AssignedVnicProfileService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VnicProfile]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AssignedVnicProfilesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new virtual network interface card profile for the network.
    # 
    # @param profile [VnicProfile] The `profile` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VnicProfile]
    # 
    def add(profile, opts = {})
      internal_add(profile, VnicProfile, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of VNIC profiles assifned to the network.
    # 
    # The order of the returned VNIC profiles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of profiles to return. If not specified all the profiles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<VnicProfile>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `profile` service.
    # 
    # @param id [String] The identifier of the `profile`.
    # 
    # @return [AssignedVnicProfileService] A reference to the `profile` service.
    # 
    def profile_service(id)
      AssignedVnicProfileService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return profile_service(path)
      end
      return profile_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AttachedStorageDomainService < Service
    
    ACTIVATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :ACTIVATE
    
    # 
    # This operation activates an attached storage domain.
    # Once the storage domain is activated it is ready for use with the data center.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
    # ----
    # 
    # The activate action does not take any action specific parameters,
    # so the request body should contain an empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the activation should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def activate(opts = {})
      internal_action(:activate, nil, ACTIVATE, opts)
    end
    
    DEACTIVATE = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :DEACTIVATE
    
    # 
    # This operation deactivates an attached storage domain.
    # Once the storage domain is deactivated it will not be used with the data center.
    # For example, to deactivate storage domain `456`, send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # If the `force` parameter is `true` then the operation will succeed, even if the OVF update which takes place
    # before the deactivation of the storage domain failed. If the `force` parameter is `false` and the OVF update failed,
    # the deactivation of the storage domain will also fail.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the deactivation should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the operation should succeed and the storage domain should be moved to a deactivated state, even if
    #   the OVF update for the storage domain failed.
    #   For example, to deactivate storage domain `456` using force flag, send the following request:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <action>
    #     <force>true</force>
    #   <action>
    #   ----
    #   
    #   This parameter is optional, and the default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def deactivate(opts = {})
      internal_action(:deactivate, nil, DEACTIVATE, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the `disks` service.
    # 
    # @return [AttachedStorageDomainDisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= AttachedStorageDomainDisksService.new(self, 'disks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class AttachedStorageDomainDisksService < Service
    
    ADD = [
      [:unregistered, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds or registers a disk.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
    # operation of the service that manages the disks of the system. To register an unregistered disk use the
    # <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
    # that disk.
    # 
    # @param disk [Disk] The disk to add or register.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :unregistered Indicates if a new disk should be added or if an existing unregistered disk should be registered. If the
    #   value is `true` then the identifier of the disk to register needs to be provided. For example, to register
    #   the disk with id `456` send a request like this:
    #   
    #   ....
    #   POST /ovirt-engine/api/storagedomains/123/disks?unregistered=true
    #   ....
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <disk id="456"/>
    #   ----
    #   
    #   If the value is `false` then a new disk will be created in the storage domain. In that case the
    #   `provisioned_size`, `format` and `name` attributes are mandatory. For example, to create a new
    #   _copy on write_ disk of 1 GiB, send a request like this:
    #   
    #   ....
    #   POST /ovirt-engine/api/storagedomains/123/disks
    #   ....
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <disk>
    #     <name>mydisk</name>
    #     <format>cow</format>
    #     <provisioned_size>1073741824</provisioned_size>
    #   </disk>
    #   ----
    #   
    #   The default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def add(disk, opts = {})
      internal_add(disk, Disk, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieve the list of disks that are available in the storage domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified all the disks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific disk.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [AttachedStorageDomainDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      AttachedStorageDomainDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AttachedStorageDomainsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Attaches an existing storage domain to the data center.
    # 
    # @param storage_domain [StorageDomain] The storage domain to attach to the data center.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def add(storage_domain, opts = {})
      internal_add(storage_domain, StorageDomain, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of storage domains attached to the data center.
    # 
    # The order of the returned storage domains isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of storage domains to return. If not specified all the storage domains are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<StorageDomain>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `storage_domain` service.
    # 
    # @param id [String] The identifier of the `storage_domain`.
    # 
    # @return [AttachedStorageDomainService] A reference to the `storage_domain` service.
    # 
    def storage_domain_service(id)
      AttachedStorageDomainService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return storage_domain_service(path)
      end
      return storage_domain_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class BalanceService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Balance]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class BalancesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a balance module to a specified user defined scheduling policy.
    # 
    # @param balance [Balance] The `balance` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Balance]
    # 
    def add(balance, opts = {})
      internal_add(balance, Balance, ADD, opts)
    end
    
    LIST = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of balance modules used by the scheduling policy.
    # 
    # The order of the returned balance modules isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of balances to return. If not specified all the balances are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Balance>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `balance` service.
    # 
    # @param id [String] The identifier of the `balance`.
    # 
    # @return [BalanceService] A reference to the `balance` service.
    # 
    def balance_service(id)
      BalanceService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return balance_service(path)
      end
      return balance_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class BookmarkService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get a bookmark.
    # 
    # An example for getting a bookmark:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/bookmarks/123
    # ----
    # 
    # [source,xml]
    # ----
    # <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
    #   <name>example_vm</name>
    #   <value>vm: name=example*</value>
    # </bookmark>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Bookmark]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove a bookmark.
    # 
    # An example for removing a bookmark:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/bookmarks/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update a bookmark.
    # 
    # An example for updating a bookmark:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/bookmarks/123
    # ----
    # 
    # With the request body:
    # 
    # [source,xml]
    # ----
    # <bookmark>
    #   <name>new_example_vm</name>
    #   <value>vm: name=new_example*</value>
    # </bookmark>
    # ----
    # 
    # @param bookmark [Bookmark] The updated bookmark.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Bookmark]
    # 
    def update(bookmark, opts = {})
      internal_update(bookmark, Bookmark, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class BookmarksService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adding a new bookmark.
    # 
    # Example of adding a bookmark:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/bookmarks
    # ----
    # 
    # [source,xml]
    # ----
    # <bookmark>
    #   <name>new_example_vm</name>
    #   <value>vm: name=new_example*</value>
    # </bookmark>
    # ----
    # 
    # @param bookmark [Bookmark] The added bookmark.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Bookmark]
    # 
    def add(bookmark, opts = {})
      internal_add(bookmark, Bookmark, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Listing all the available bookmarks.
    # 
    # Example of listing bookmarks:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/bookmarks
    # ----
    # 
    # [source,xml]
    # ----
    # <bookmarks>
    #   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
    #     <name>database</name>
    #     <value>vm: name=database*</value>
    #   </bookmark>
    #   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
    #     <name>example</name>
    #     <value>vm: name=example*</value>
    #   </bookmark>
    # </bookmarks>
    # ----
    # 
    # The order of the returned bookmarks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of bookmarks to return. If not specified all the bookmarks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Bookmark>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A reference to the service managing a specific bookmark.
    # 
    # @param id [String] The identifier of the `bookmark`.
    # 
    # @return [BookmarkService] A reference to the `bookmark` service.
    # 
    def bookmark_service(id)
      BookmarkService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return bookmark_service(path)
      end
      return bookmark_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ClusterService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets information about the cluster.
    # 
    # An example of getting a cluster:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusters/123
    # ----
    # 
    # [source,xml]
    # ----
    # <cluster href="/ovirt-engine/api/clusters/123" id="123">
    #   <actions>
    #     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
    #   </actions>
    #   <name>Default</name>
    #   <description>The default server cluster</description>
    #   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
    #   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
    #   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
    #   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
    #   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
    #   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
    #   <ballooning_enabled>false</ballooning_enabled>
    #   <cpu>
    #     <architecture>x86_64</architecture>
    #     <type>Intel Nehalem Family</type>
    #   </cpu>
    #   <error_handling>
    #     <on_error>migrate</on_error>
    #   </error_handling>
    #   <fencing_policy>
    #     <enabled>true</enabled>
    #     <skip_if_connectivity_broken>
    #       <enabled>false</enabled>
    #       <threshold>50</threshold>
    #     </skip_if_connectivity_broken>
    #     <skip_if_sd_active>
    #       <enabled>false</enabled>
    #     </skip_if_sd_active>
    #   </fencing_policy>
    #   <gluster_service>false</gluster_service>
    #   <ha_reservation>false</ha_reservation>
    #   <ksm>
    #     <enabled>true</enabled>
    #     <merge_across_nodes>true</merge_across_nodes>
    #   </ksm>
    #   <memory_policy>
    #     <over_commit>
    #       <percent>100</percent>
    #     </over_commit>
    #     <transparent_hugepages>
    #       <enabled>true</enabled>
    #     </transparent_hugepages>
    #   </memory_policy>
    #   <migration>
    #     <auto_converge>inherit</auto_converge>
    #     <bandwidth>
    #       <assignment_method>auto</assignment_method>
    #     </bandwidth>
    #     <compressed>inherit</compressed>
    #   </migration>
    #   <required_rng_sources>
    #     <required_rng_source>random</required_rng_source>
    #   </required_rng_sources>
    #   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
    #   <threads_as_cores>false</threads_as_cores>
    #   <trusted_service>false</trusted_service>
    #   <tunnel_migration>false</tunnel_migration>
    #   <version>
    #     <major>4</major>
    #     <minor>0</minor>
    #   </version>
    #   <virt_service>true</virt_service>
    #   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
    # </cluster>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cluster]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REFRESH_GLUSTER_HEAL_STATUS = [
    ].freeze
    
    private_constant :REFRESH_GLUSTER_HEAL_STATUS
    
    # 
    # Refresh the Gluster heal info for all volumes in cluster.
    # 
    # For example, Cluster `123`, send a request like
    # this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/123/refreshglusterhealstatus
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def refresh_gluster_heal_status(opts = {})
      internal_action(:refreshglusterhealstatus, nil, REFRESH_GLUSTER_HEAL_STATUS, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the cluster from the system.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    RESET_EMULATED_MACHINE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :RESET_EMULATED_MACHINE
    
    # 
    # Executes the `reset_emulated_machine` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the reset should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reset_emulated_machine(opts = {})
      internal_action(:resetemulatedmachine, nil, RESET_EMULATED_MACHINE, opts)
    end
    
    SYNC_ALL_NETWORKS = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :SYNC_ALL_NETWORKS
    
    # 
    # Synchronizes all networks on the cluster.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/123/syncallnetworks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def sync_all_networks(opts = {})
      internal_action(:syncallnetworks, nil, SYNC_ALL_NETWORKS, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates information about the cluster.
    # 
    # Only the specified fields are updated; others remain unchanged.
    # 
    # For example, to update the cluster's CPU:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/clusters/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <cluster>
    #   <cpu>
    #     <type>Intel Haswell-noTSX Family</type>
    #   </cpu>
    # </cluster>
    # ----
    # 
    # @param cluster [Cluster] The `cluster` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cluster]
    # 
    def update(cluster, opts = {})
      internal_update(cluster, Cluster, UPDATE, opts)
    end
    
    UPGRADE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPGRADE
    
    # 
    # Start or finish upgrade process for the cluster based on the action value. This action marks the cluster for
    # upgrade or clears the upgrade running flag on the cluster based on the action value which takes values of
    # start or stop.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/123/upgrade
    # ----
    # 
    # With a request body like this to mark the cluster for upgrade:
    # 
    # [source,xml]
    # ----
    # <action>
    #     <upgrade_action>
    #         start
    #     </upgrade_action>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [ClusterUpgradeAction] :upgrade_action The action to be performed.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def upgrade(opts = {})
      internal_action(:upgrade, nil, UPGRADE, opts)
    end
    
    # 
    # A reference to the service that manages affinity groups.
    # 
    # @return [AffinityGroupsService] A reference to `affinity_groups` service.
    # 
    def affinity_groups_service
      @affinity_groups_service ||= AffinityGroupsService.new(self, 'affinitygroups')
    end
    
    # 
    # A reference to the service that manages assigned CPU profiles for the cluster.
    # 
    # @return [AssignedCpuProfilesService] A reference to `cpu_profiles` service.
    # 
    def cpu_profiles_service
      @cpu_profiles_service ||= AssignedCpuProfilesService.new(self, 'cpuprofiles')
    end
    
    # 
    # A reference to the service that manages the collection of enabled features for the cluster.
    # 
    # @return [ClusterEnabledFeaturesService] A reference to `enabled_features` service.
    # 
    def enabled_features_service
      @enabled_features_service ||= ClusterEnabledFeaturesService.new(self, 'enabledfeatures')
    end
    
    # 
    # A reference to the service that manages the collection of external network providers.
    # 
    # @return [ClusterExternalProvidersService] A reference to `external_network_providers` service.
    # 
    def external_network_providers_service
      @external_network_providers_service ||= ClusterExternalProvidersService.new(self, 'externalnetworkproviders')
    end
    
    # 
    # A reference to the service that manages the Gluster hooks for the cluster.
    # 
    # @return [GlusterHooksService] A reference to `gluster_hooks` service.
    # 
    def gluster_hooks_service
      @gluster_hooks_service ||= GlusterHooksService.new(self, 'glusterhooks')
    end
    
    # 
    # A reference to the service that manages Gluster volumes for the cluster.
    # 
    # @return [GlusterVolumesService] A reference to `gluster_volumes` service.
    # 
    def gluster_volumes_service
      @gluster_volumes_service ||= GlusterVolumesService.new(self, 'glustervolumes')
    end
    
    # 
    # A sub-collection with all the supported network filters for the cluster.
    # 
    # @return [NetworkFiltersService] A reference to `network_filters` service.
    # 
    def network_filters_service
      @network_filters_service ||= NetworkFiltersService.new(self, 'networkfilters')
    end
    
    # 
    # A reference to the service that manages assigned networks for the cluster.
    # 
    # @return [ClusterNetworksService] A reference to `networks` service.
    # 
    def networks_service
      @networks_service ||= ClusterNetworksService.new(self, 'networks')
    end
    
    # 
    # A reference to permissions.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'affinitygroups'
        return affinity_groups_service
      end
      if path.start_with?('affinitygroups/')
        return affinity_groups_service.service(path[15..-1])
      end
      if path == 'cpuprofiles'
        return cpu_profiles_service
      end
      if path.start_with?('cpuprofiles/')
        return cpu_profiles_service.service(path[12..-1])
      end
      if path == 'enabledfeatures'
        return enabled_features_service
      end
      if path.start_with?('enabledfeatures/')
        return enabled_features_service.service(path[16..-1])
      end
      if path == 'externalnetworkproviders'
        return external_network_providers_service
      end
      if path.start_with?('externalnetworkproviders/')
        return external_network_providers_service.service(path[25..-1])
      end
      if path == 'glusterhooks'
        return gluster_hooks_service
      end
      if path.start_with?('glusterhooks/')
        return gluster_hooks_service.service(path[13..-1])
      end
      if path == 'glustervolumes'
        return gluster_volumes_service
      end
      if path.start_with?('glustervolumes/')
        return gluster_volumes_service.service(path[15..-1])
      end
      if path == 'networkfilters'
        return network_filters_service
      end
      if path.start_with?('networkfilters/')
        return network_filters_service.service(path[15..-1])
      end
      if path == 'networks'
        return networks_service
      end
      if path.start_with?('networks/')
        return networks_service.service(path[9..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ClusterEnabledFeatureService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Provides the information about the cluster feature enabled.
    # 
    # For example, to find details of the enabled feature `456` for cluster `123`, send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusters/123/enabledfeatures/456
    # ----
    # 
    # That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
    # 
    # [source,xml]
    # ----
    # <cluster_feature id="456">
    #   <name>libgfapi_supported</name>
    # </cluster_feature>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ClusterFeature]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Disables a cluster feature.
    # 
    # For example, to disable the feature `456` of cluster `123` send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/clusters/123/enabledfeatures/456
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ClusterEnabledFeaturesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Enable an additional feature for a cluster.
    # 
    # For example, to enable a feature `456` on cluster `123`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/123/enabledfeatures
    # ----
    # 
    # The request body should look like this:
    # 
    # [source,xml]
    # ----
    # <cluster_feature id="456"/>
    # ----
    # 
    # @param feature [ClusterFeature] The `feature` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ClusterFeature]
    # 
    def add(feature, opts = {})
      internal_add(feature, ClusterFeature, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists the additional features enabled for the cluster.
    # 
    # For example, to get the features enabled for cluster `123` send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusters/123/enabledfeatures
    # ----
    # 
    # This will return a list of features:
    # 
    # [source,xml]
    # ----
    # <enabled_features>
    #   <cluster_feature id="123">
    #      <name>test_feature</name>
    #   </cluster_feature>
    #   ...
    # </enabled_features>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ClusterFeature>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A reference to the service that provides information about a specific
    # feature enabled for the cluster.
    # 
    # @param id [String] The identifier of the `feature`.
    # 
    # @return [ClusterEnabledFeatureService] A reference to the `feature` service.
    # 
    def feature_service(id)
      ClusterEnabledFeatureService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return feature_service(path)
      end
      return feature_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ClusterExternalProvidersService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of external providers.
    # 
    # The order of the returned list of providers is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ExternalProvider>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ClusterFeatureService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Provides the information about the a cluster feature supported by a cluster level.
    # 
    # For example, to find details of the cluster feature `456` for cluster level 4.1, send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures/456
    # ----
    # 
    # That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
    # 
    # [source,xml]
    # ----
    # <cluster_feature id="456">
    #   <name>libgfapi_supported</name>
    # </cluster_feature>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ClusterFeature]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ClusterFeaturesService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists the cluster features supported by the cluster level.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures
    # ----
    # 
    # This will return a list of cluster features supported by the cluster level:
    # 
    # [source,xml]
    # ----
    # <cluster_features>
    #   <cluster_feature id="123">
    #      <name>test_feature</name>
    #   </cluster_feature>
    #   ...
    # </cluster_features>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ClusterFeature>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that provides information about a specific feature.
    # 
    # @param id [String] The identifier of the `feature`.
    # 
    # @return [ClusterFeatureService] A reference to the `feature` service.
    # 
    def feature_service(id)
      ClusterFeatureService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return feature_service(path)
      end
      return feature_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ClusterLevelService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Provides the information about the capabilities of the specific cluster level managed by this service.
    # 
    # For example, to find what CPU types are supported by level 3.6 you can send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusterlevels/3.6
    # ----
    # 
    # That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
    # information which describes the cluster level:
    # 
    # [source,xml]
    # ----
    # <cluster_level id="3.6">
    #   <cpu_types>
    #     <cpu_type>
    #       <name>Intel Nehalem Family</name>
    #       <level>3</level>
    #       <architecture>x86_64</architecture>
    #     </cpu_type>
    #     ...
    #   </cpu_types>
    #   <permits>
    #     <permit id="1">
    #       <name>create_vm</name>
    #       <administrative>false</administrative>
    #     </permit>
    #     ...
    #   </permits>
    # </cluster_level>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ClusterLevel]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Reference to the service that manages the collection of supported features for this cluster level.
    # 
    # @return [ClusterFeaturesService] A reference to `cluster_features` service.
    # 
    def cluster_features_service
      @cluster_features_service ||= ClusterFeaturesService.new(self, 'clusterfeatures')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'clusterfeatures'
        return cluster_features_service
      end
      if path.start_with?('clusterfeatures/')
        return cluster_features_service.service(path[16..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ClusterLevelsService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists the cluster levels supported by the system.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusterlevels
    # ----
    # 
    # This will return a list of available cluster levels.
    # 
    # [source,xml]
    # ----
    # <cluster_levels>
    #   <cluster_level id="4.0">
    #      ...
    #   </cluster_level>
    #   ...
    # </cluster_levels>
    # ----
    # 
    # The order of the returned cluster levels isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ClusterLevel>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that provides information about an specific cluster level.
    # 
    # @param id [String] The identifier of the `level`.
    # 
    # @return [ClusterLevelService] A reference to the `level` service.
    # 
    def level_service(id)
      ClusterLevelService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return level_service(path)
      end
      return level_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ClusterNetworkService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the cluster network details.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Unassigns the network from a cluster.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the network in the cluster.
    # 
    # @param network [Network] The cluster network.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def update(network, opts = {})
      internal_update(network, Network, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ClusterNetworksService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Assigns the network to a cluster.
    # 
    # Post a request like in the example below to assign the network to a cluster:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/123/networks
    # ----
    # 
    # Use the following example in its body:
    # 
    # [source,xml]
    # ----
    # <network id="123" />
    # ----
    # 
    # @param network [Network] The network object to be assigned to the cluster.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def add(network, opts = {})
      internal_add(network, Network, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists the networks that are assigned to the cluster.
    # 
    # The order of the returned clusters isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of networks to return. If not specified, all the networks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Network>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Access the cluster network service that manages the cluster network specified by an ID.
    # 
    # @param id [String] The identifier of the `network`.
    # 
    # @return [ClusterNetworkService] A reference to the `network` service.
    # 
    def network_service(id)
      ClusterNetworkService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return network_service(path)
      end
      return network_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ClustersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new cluster.
    # 
    # This requires the `name`, `cpu.type`, and `data_center` attributes. Identify the data center with either the `id`
    # or `name` attribute.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <cluster>
    #   <name>mycluster</name>
    #   <cpu>
    #     <type>Intel Nehalem Family</type>
    #   </cpu>
    #   <data_center id="123"/>
    # </cluster>
    # ----
    # 
    # To create a cluster with an external network provider to be deployed on
    # every host that is added to the cluster, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters
    # ----
    # 
    # With a request body containing a reference to the desired provider:
    # 
    # [source,xml]
    # ----
    # <cluster>
    #   <name>mycluster</name>
    #   <cpu>
    #     <type>Intel Nehalem Family</type>
    #   </cpu>
    #   <data_center id="123"/>
    #   <external_network_providers>
    #     <external_provider name="ovirt-provider-ovn"/>
    #   </external_network_providers>
    # </cluster>
    # ----
    # 
    # @param cluster [Cluster] The `cluster` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cluster]
    # 
    def add(cluster, opts = {})
      internal_add(cluster, Cluster, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of clusters of the system.
    # 
    # The order of the returned clusters is guaranteed only if the `sortby` clause is included in the
    # `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search should be performed taking case into account.
    #   The default value is `true`, which means that case is taken into account. To search
    #   ignoring case, set it to `false`.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of clusters to return. If not specified, all the clusters are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned clusters.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Cluster>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A reference to the service that manages a specific cluster.
    # 
    # @param id [String] The identifier of the `cluster`.
    # 
    # @return [ClusterService] A reference to the `cluster` service.
    # 
    def cluster_service(id)
      ClusterService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return cluster_service(path)
      end
      return cluster_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class CopyableService < Service
    
    COPY = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :COPY
    
    # 
    # Executes the `copy` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the copy should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def copy(opts = {})
      internal_action(:copy, nil, COPY, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class CpuProfileService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [CpuProfile]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified cpu profile in the system.
    # 
    # @param profile [CpuProfile] The `profile` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [CpuProfile]
    # 
    def update(profile, opts = {})
      internal_update(profile, CpuProfile, UPDATE, opts)
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class CpuProfilesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new cpu profile to the system.
    # 
    # @param profile [CpuProfile] The `profile` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [CpuProfile]
    # 
    def add(profile, opts = {})
      internal_add(profile, CpuProfile, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of CPU profiles of the system.
    # 
    # The order of the returned list of CPU profiles is random.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of profiles to return. If not specified, all the profiles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<CpuProfile>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `profile` service.
    # 
    # @param id [String] The identifier of the `profile`.
    # 
    # @return [CpuProfileService] A reference to the `profile` service.
    # 
    def profile_service(id)
      CpuProfileService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return profile_service(path)
      end
      return profile_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DataCenterService < Service
    
    CLEAN_FINISHED_TASKS = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :CLEAN_FINISHED_TASKS
    
    # 
    # Currently, the storage pool manager (SPM) fails to
    # switch to another host if the SPM has uncleared tasks.
    # Clearing all finished tasks enables the SPM switching.
    # 
    # For example, to clean all the finished tasks on a data center with ID `123` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/cleanfinishedtasks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def clean_finished_tasks(opts = {})
      internal_action(:cleanfinishedtasks, nil, CLEAN_FINISHED_TASKS, opts)
    end
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get a data center.
    # 
    # An example of getting a data center:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/datacenters/123
    # ----
    # 
    # [source,xml]
    # ----
    # <data_center href="/ovirt-engine/api/datacenters/123" id="123">
    #   <name>Default</name>
    #   <description>The default Data Center</description>
    #   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
    #   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
    #   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
    #   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
    #   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
    #   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
    #   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
    #   <local>false</local>
    #   <quota_mode>disabled</quota_mode>
    #   <status>up</status>
    #   <storage_format>v3</storage_format>
    #   <supported_versions>
    #     <version>
    #       <major>4</major>
    #       <minor>0</minor>
    #    </version>
    #   </supported_versions>
    #   <version>
    #     <major>4</major>
    #     <minor>0</minor>
    #   </version>
    #   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
    # </data_center>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DataCenter]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the data center.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/datacenters/123
    # ----
    # 
    # Without any special parameters, the storage domains attached to the data center are detached and then removed
    # from the storage. If something fails when performing this operation, for example if there is no host available to
    # remove the storage domains from the storage, the complete operation will fail.
    # 
    # If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
    # one storage domain, for example. The failure is just ignored and the data center is removed from the database
    # anyway.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Boolean] :force Indicates if the operation should succeed, and the storage domain removed from the database, even if
    #   something fails during the operation.
    #   
    #   This parameter is optional, and the default value is `false`.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    SET_MASTER = [
      [:async, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :SET_MASTER
    
    # 
    # Used for manually setting a storage domain in the data center as a master.
    # For example, for setting a storage domain with ID '456' as a master on a data center with ID '123',
    # send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/setmaster
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain id="456"/>
    # </action>
    # ----
    # 
    # The new master storage domain can be also specified by its name.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [StorageDomain] :storage_domain The new master storage domain for the data center.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def set_master(opts = {})
      internal_action(:setmaster, nil, SET_MASTER, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the data center.
    # 
    # The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
    # post-creation. For example, to change the name and description of data center `123` send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/datacenters/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <data_center>
    #   <name>myupdatedname</name>
    #   <description>An updated description for the data center</description>
    # </data_center>
    # ----
    # 
    # @param data_center [DataCenter] The data center that is being updated.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DataCenter]
    # 
    def update(data_center, opts = {})
      internal_update(data_center, DataCenter, UPDATE, opts)
    end
    
    # 
    # Locates the `clusters` service.
    # 
    # @return [ClustersService] A reference to `clusters` service.
    # 
    def clusters_service
      @clusters_service ||= ClustersService.new(self, 'clusters')
    end
    
    # 
    # Reference to the iSCSI bonds service.
    # 
    # @return [IscsiBondsService] A reference to `iscsi_bonds` service.
    # 
    def iscsi_bonds_service
      @iscsi_bonds_service ||= IscsiBondsService.new(self, 'iscsibonds')
    end
    
    # 
    # Returns a reference to the service, that manages the networks, that are associated with the data center.
    # 
    # @return [DataCenterNetworksService] A reference to `networks` service.
    # 
    def networks_service
      @networks_service ||= DataCenterNetworksService.new(self, 'networks')
    end
    
    # 
    # Reference to the permissions service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Reference to the QOSs service.
    # 
    # @return [QossService] A reference to `qoss` service.
    # 
    def qoss_service
      @qoss_service ||= QossService.new(self, 'qoss')
    end
    
    # 
    # Reference to the quotas service.
    # 
    # @return [QuotasService] A reference to `quotas` service.
    # 
    def quotas_service
      @quotas_service ||= QuotasService.new(self, 'quotas')
    end
    
    # 
    # Attach and detach storage domains to and from a data center.
    # 
    # For attaching a single storage domain we should use the following POST request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/storagedomains
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <storage_domain>
    #   <name>data1</name>
    # </storage_domain>
    # ----
    # 
    # For detaching a single storage domain we should use the following DELETE request:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/datacenters/123/storagedomains/123
    # ----
    # 
    # @return [AttachedStorageDomainsService] A reference to `storage_domains` service.
    # 
    def storage_domains_service
      @storage_domains_service ||= AttachedStorageDomainsService.new(self, 'storagedomains')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'clusters'
        return clusters_service
      end
      if path.start_with?('clusters/')
        return clusters_service.service(path[9..-1])
      end
      if path == 'iscsibonds'
        return iscsi_bonds_service
      end
      if path.start_with?('iscsibonds/')
        return iscsi_bonds_service.service(path[11..-1])
      end
      if path == 'networks'
        return networks_service
      end
      if path.start_with?('networks/')
        return networks_service.service(path[9..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'qoss'
        return qoss_service
      end
      if path.start_with?('qoss/')
        return qoss_service.service(path[5..-1])
      end
      if path == 'quotas'
        return quotas_service
      end
      if path.start_with?('quotas/')
        return quotas_service.service(path[7..-1])
      end
      if path == 'storagedomains'
        return storage_domains_service
      end
      if path.start_with?('storagedomains/')
        return storage_domains_service.service(path[15..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DataCenterNetworkService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the data center network details.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the network.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the network in the data center.
    # 
    # @param network [Network] The data center network.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def update(network, opts = {})
      internal_update(network, Network, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DataCenterNetworksService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Create a new network in a data center.
    # 
    # Post a request like in the example below to create a new network in a data center with an ID of `123`.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/networks
    # ----
    # 
    # Use the following example in its body:
    # 
    # [source,xml]
    # ----
    # <network>
    #   <name>mynetwork</name>
    # </network>
    # ----
    # 
    # @param network [Network] The network object to be created in the data center.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def add(network, opts = {})
      internal_add(network, Network, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists networks in the data center.
    # 
    # The order of the returned list of networks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of networks to return. If not specified, all the networks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Network>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Access the data center network service that manages the data center network specified by an ID.
    # 
    # @param id [String] The identifier of the `network`.
    # 
    # @return [DataCenterNetworkService] A reference to the `network` service.
    # 
    def network_service(id)
      DataCenterNetworkService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return network_service(path)
      end
      return network_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DataCentersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new data center.
    # 
    # Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
    # named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <data_center>
    #   <name>mydc</name>
    #   <local>false</local>
    # </data_center>
    # ----
    # 
    # @param data_center [DataCenter] The data center that is being added.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DataCenter]
    # 
    def add(data_center, opts = {})
      internal_add(data_center, DataCenter, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists the data centers.
    # 
    # The following request retrieves a representation of the data centers:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/datacenters
    # ----
    # 
    # The above request performed with `curl`:
    # 
    # [source,bash]
    # ----
    # curl \
    # --request GET \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --header "Version: 4" \
    # --header "Accept: application/xml" \
    # --user "admin@internal:mypassword" \
    # https://myengine.example.com/ovirt-engine/api/datacenters
    # ----
    # 
    # This is what an example response could look like:
    # 
    # [source,xml]
    # ----
    # <data_center href="/ovirt-engine/api/datacenters/123" id="123">
    #   <name>Default</name>
    #   <description>The default Data Center</description>
    #   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
    #   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
    #   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
    #   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
    #   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
    #   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
    #   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
    #   <local>false</local>
    #   <quota_mode>disabled</quota_mode>
    #   <status>up</status>
    #   <supported_versions>
    #     <version>
    #       <major>4</major>
    #       <minor>0</minor>
    #     </version>
    #   </supported_versions>
    #   <version>
    #     <major>4</major>
    #     <minor>0</minor>
    #   </version>
    # </data_center>
    # ----
    # 
    # Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
    # resources of your virtual environment.
    # 
    # The data center also contains a link to the storage domains collection. The data center uses this collection to
    # attach storage domains from the storage domains main collection.
    # 
    # The order of the returned list of data centers is guaranteed only if the `sortby` clause is included in the
    # `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of data centers to return. If not specified all the data centers are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned data centers.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<DataCenter>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific data center.
    # 
    # @param id [String] The identifier of the `data_center`.
    # 
    # @return [DataCenterService] A reference to the `data_center` service.
    # 
    def data_center_service(id)
      DataCenterService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return data_center_service(path)
      end
      return data_center_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DiskAttachmentService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the details of the attachment, including the bootable flag and link to the disk.
    # 
    # An example of getting a disk attachment:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/vms/123/diskattachments/456
    # ----
    # 
    # [source,xml]
    # ----
    # <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
    #   <active>true</active>
    #   <bootable>true</bootable>
    #   <interface>virtio</interface>
    #   <disk href="/ovirt-engine/api/disks/456" id="456"/>
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    # </disk_attachment>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskAttachment]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:detach_only, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the disk attachment.
    # 
    # This will only detach the disk from the virtual machine, but won't remove it from
    # the system, unless the `detach_only` parameter is `false`.
    # 
    # An example of removing a disk attachment:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :detach_only Indicates if the disk should only be detached from the virtual machine, but not removed from the system.
    #   The default value is `true`, which won't remove the disk from the system.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the disk attachment and the disk properties within it.
    # 
    # [source]
    # ----
    # PUT /vms/{vm:id}/disksattachments/{attachment:id}
    # <disk_attachment>
    #   <bootable>true</bootable>
    #   <interface>ide</interface>
    #   <active>true</active>
    #   <disk>
    #     <name>mydisk</name>
    #     <provisioned_size>1024</provisioned_size>
    #     ...
    #   </disk>
    # </disk_attachment>
    # ----
    # 
    # @param disk_attachment [DiskAttachment] The `disk_attachment` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskAttachment]
    # 
    def update(disk_attachment, opts = {})
      internal_update(disk_attachment, DiskAttachment, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DiskAttachmentsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
    # the disk already exists:
    # 
    # [source,xml]
    # ----
    # <disk_attachment>
    #   <bootable>true</bootable>
    #   <pass_discard>true</pass_discard>
    #   <interface>ide</interface>
    #   <active>true</active>
    #   <disk id="123"/>
    # </disk_attachment>
    # ----
    # 
    # Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
    # 
    # [source,xml]
    # ----
    # <disk_attachment>
    #   <bootable>true</bootable>
    #   <pass_discard>true</pass_discard>
    #   <interface>ide</interface>
    #   <active>true</active>
    #   <disk>
    #     <name>mydisk</name>
    #     <provisioned_size>1024</provisioned_size>
    #     ...
    #   </disk>
    # </disk_attachment>
    # ----
    # 
    # In this case the disk will be created and then attached to the virtual machine.
    # 
    # In both cases, use the following URL for a virtual machine with an id `345`:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/345/diskattachments
    # ----
    # 
    # IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
    # undefined. In some cases the disk will be automatically activated and in other cases it won't. To
    # avoid issues it is strongly recommended to always include the `active` attribute with the desired
    # value.
    # 
    # @param attachment [DiskAttachment] The disk attachment to add to the virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskAttachment]
    # 
    def add(attachment, opts = {})
      internal_add(attachment, DiskAttachment, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the disk that are attached to the virtual machine.
    # 
    # The order of the returned list of disks attachments isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<DiskAttachment>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    ADD_PROVIDING_DISK_ID = [
    ].freeze
    
    private_constant :ADD_PROVIDING_DISK_ID
    
    # 
    # Adds a new `attachment`.
    # 
    # @param attachment [DiskAttachment] The disk attachment to add to the virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskAttachment]
    # 
    def add_providing_disk_id(attachment, opts = {})
      internal_add(attachment, DiskAttachment, ADD_PROVIDING_DISK_ID, opts)
    end
    
    ADD_SIGNATURE1 = [
    ].freeze
    
    private_constant :ADD_SIGNATURE1
    
    # 
    # Adds a new `attachment`.
    # 
    # @param attachment [DiskAttachment] The disk attachment to add to the virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskAttachment]
    # 
    def add_signature1(attachment, opts = {})
      internal_add(attachment, DiskAttachment, ADD_SIGNATURE1, opts)
    end
    
    # 
    # Reference to the service that manages a specific attachment.
    # 
    # @param id [String] The identifier of the `attachment`.
    # 
    # @return [DiskAttachmentService] A reference to the `attachment` service.
    # 
    def attachment_service(id)
      DiskAttachmentService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return attachment_service(path)
      end
      return attachment_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DiskProfileService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskProfile]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified disk profile in the system.
    # 
    # @param profile [DiskProfile] The `profile` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskProfile]
    # 
    def update(profile, opts = {})
      internal_update(profile, DiskProfile, UPDATE, opts)
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DiskProfilesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new disk profile to the system.
    # 
    # @param profile [DiskProfile] The `profile` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskProfile]
    # 
    def add(profile, opts = {})
      internal_add(profile, DiskProfile, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disk profiles of the system.
    # 
    # The order of the returned list of disk profiles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of profiles to return. If not specified all the profiles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<DiskProfile>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `disk_profile` service.
    # 
    # @param id [String] The identifier of the `disk_profile`.
    # 
    # @return [DiskProfileService] A reference to the `disk_profile` service.
    # 
    def disk_profile_service(id)
      DiskProfileService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_profile_service(path)
      end
      return disk_profile_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DiskSnapshotService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskSnapshot]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DiskSnapshotsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:include_active, TrueClass].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disk snapshots of the storage domain.
    # 
    # The order of the returned list of disk snapshots isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Boolean] :include_active If true return also active snapshots. If not specified active snapshots are not returned.
    # 
    # @option opts [Integer] :max Sets the maximum number of snapshots to return. If not specified all the snapshots are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<DiskSnapshot>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `snapshot` service.
    # 
    # @param id [String] The identifier of the `snapshot`.
    # 
    # @return [DiskSnapshotService] A reference to the `snapshot` service.
    # 
    def snapshot_service(id)
      DiskSnapshotService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return snapshot_service(path)
      end
      return snapshot_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DisksService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new floating disk.
    # 
    # There are three types of disks that can be added - disk image, direct LUN and
    #  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
    # 
    # *Adding a new image disk:*
    # 
    # When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
    # and `format` attributes.
    # 
    # Note that block storage domains (i.e., storage domains with the <<types/storage_type, storage type>> of iSCSI or
    # FCP) don't support the combination of the raw `format` with `sparse=true`, so `sparse=false` must be stated
    # explicitly.
    # 
    # To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
    # with an id `123`, send a request as follows:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/disks
    # ----
    # 
    # With a request body as follows:
    # 
    # [source,xml]
    # ----
    # <disk>
    #   <storage_domains>
    #     <storage_domain id="123"/>
    #   </storage_domains>
    #   <name>mydisk</name>
    #   <provisioned_size>1048576</provisioned_size>
    #   <format>cow</format>
    # </disk>
    # ----
    # 
    # 
    # *Adding a new direct LUN disk:*
    # 
    # When adding a new floating direct LUN via the API, there are two flavors that can be used:
    # 
    # . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
    # to retrieve basic information about the LUN (e.g., size and serial).
    # . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
    # accessed.
    # 
    # To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
    # `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
    # send a request as follows:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/disks
    # ----
    # 
    # With a request body as follows:
    # 
    # [source,xml]
    # ----
    # <disk>
    #   <alias>mylun</alias>
    #   <lun_storage>
    #     <host id="123"/>
    #     <type>iscsi</type>
    #     <logical_units>
    #       <logical_unit id="456">
    #         <address>10.35.10.20</address>
    #         <port>3260</port>
    #         <target>iqn.2017-01.com.myhost:444</target>
    #       </logical_unit>
    #     </logical_units>
    #   </lun_storage>
    # </disk>
    # ----
    # 
    # To create a new floating direct LUN disk without using a host, remove the `host` element.
    # 
    # 
    # *Adding a new Cinder disk:*
    # 
    # To create a new floating Cinder disk, send a request as follows:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/disks
    # ----
    # 
    # With a request body as follows:
    # 
    # [source,xml]
    # ----
    # <disk>
    #   <openstack_volume_type>
    #     <name>myceph</name>
    #   </openstack_volume_type>
    #   <storage_domains>
    #     <storage_domain>
    #       <name>cinderDomain</name>
    #     </storage_domain>
    #   </storage_domains>
    #   <provisioned_size>1073741824</provisioned_size>
    #   <interface>virtio</interface>
    #   <format>raw</format>
    # </disk>
    # ----
    # 
    # 
    # *Adding a floating disks in order to upload disk snapshots:*
    # 
    # Since version 4.2 of the engine it is possible to upload disks with
    # snapshots. This request should be used to create the base image of the
    # images chain (The consecutive disk snapshots (images), should be created
    # using `disk-attachments` element when creating a snapshot).
    # 
    # The disk has to be created with the same disk identifier and image identifier
    # of the uploaded image. I.e. the identifiers should be saved as part of the
    # backup process. The image identifier can be also fetched using the
    # `qemu-img info` command. For example, if the disk image is stored into
    # a file named `b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img`:
    # 
    # [source,shell]
    # ----
    # $ qemu-img info b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img
    # image: b548366b-fb51-4b41-97be-733c887fe305
    # file format: qcow2
    # virtual size: 1.0G (1073741824 bytes)
    # disk size: 196K
    # cluster_size: 65536
    # backing file: ad58716a-1fe9-481f-815e-664de1df04eb
    # backing file format: raw
    # ----
    # 
    # To create a disk with with the disk identifier and image identifier obtained
    # with the `qemu-img info` command shown above, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/disks
    # ----
    # 
    # With a request body as follows:
    # 
    # [source,xml]
    # ----
    # <disk id="b7a4c6c5-443b-47c5-967f-6abc79675e8b">
    #   <image_id>b548366b-fb51-4b41-97be-733c887fe305</image_id>
    #   <storage_domains>
    #     <storage_domain id="123"/>
    #   </storage_domains>
    #   <name>mydisk</name>
    #   <provisioned_size>1048576</provisioned_size>
    #   <format>cow</format>
    # </disk>
    # ----
    # 
    # @param disk [Disk] The disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def add(disk, opts = {})
      internal_add(disk, Disk, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get list of disks.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/disks
    # ----
    # 
    # You will get a XML response which will look like this one:
    # 
    # [source,xml]
    # ----
    # <disks>
    #   <disk id="123">
    #     <actions>...</actions>
    #     <name>MyDisk</name>
    #     <description>MyDisk description</description>
    #     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
    #     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
    #     <actual_size>5345845248</actual_size>
    #     <alias>MyDisk alias</alias>
    #     ...
    #     <status>ok</status>
    #     <storage_type>image</storage_type>
    #     <wipe_after_delete>false</wipe_after_delete>
    #     <disk_profile id="123"/>
    #     <quota id="123"/>
    #     <storage_domains>...</storage_domains>
    #   </disk>
    #   ...
    # </disks>
    # ----
    # 
    # The order of the returned list of disks is guaranteed only if the `sortby` clause is included in the
    # `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified all the disks are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned disks.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    ADD_LUN = [
    ].freeze
    
    private_constant :ADD_LUN
    
    # 
    # Add a new lun disk to the storage domain.
    # 
    # @param disk [Disk] The disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def add_lun(disk, opts = {})
      internal_add(disk, Disk, ADD_LUN, opts)
    end
    
    ADD_ON_STORAGE_DOMAIN = [
    ].freeze
    
    private_constant :ADD_ON_STORAGE_DOMAIN
    
    # 
    # Add a new disk to the storage domain with the specified size allocating space from the storage domain.
    # 
    # @param disk [Disk] The disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def add_on_storage_domain(disk, opts = {})
      internal_add(disk, Disk, ADD_ON_STORAGE_DOMAIN, opts)
    end
    
    # 
    # Reference to a service managing a specific disk.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [DiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      DiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DomainService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the authentication domain information.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/domains/5678
    # ....
    # 
    # Will return the domain information:
    # 
    # [source,xml]
    # ----
    # <domain href="/ovirt-engine/api/domains/5678" id="5678">
    #   <name>internal-authz</name>
    #   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
    #   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
    #   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
    #   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
    # </domain>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Domain]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Reference to a service to manage domain groups.
    # 
    # @return [DomainGroupsService] A reference to `groups` service.
    # 
    def groups_service
      @groups_service ||= DomainGroupsService.new(self, 'groups')
    end
    
    # 
    # Reference to a service to manage domain users.
    # 
    # @return [DomainUsersService] A reference to `users` service.
    # 
    def users_service
      @users_service ||= DomainUsersService.new(self, 'users')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'groups'
        return groups_service
      end
      if path.start_with?('groups/')
        return groups_service.service(path[7..-1])
      end
      if path == 'users'
        return users_service
      end
      if path.start_with?('users/')
        return users_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DomainGroupService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Group]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DomainGroupsService < Service
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of groups.
    # 
    # The order of the returned list of groups isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of groups to return. If not specified all the groups are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned groups.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Group>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `group` service.
    # 
    # @param id [String] The identifier of the `group`.
    # 
    # @return [DomainGroupService] A reference to the `group` service.
    # 
    def group_service(id)
      DomainGroupService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return group_service(path)
      end
      return group_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DomainUserService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the domain user information.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/domains/5678/users/1234
    # ....
    # 
    # Will return the domain user information:
    # 
    # [source,xml]
    # ----
    # <user href="/ovirt-engine/api/users/1234" id="1234">
    #   <name>admin</name>
    #   <namespace>*</namespace>
    #   <principal>admin</principal>
    #   <user_name>admin@internal-authz</user_name>
    #   <domain href="/ovirt-engine/api/domains/5678" id="5678">
    #     <name>internal-authz</name>
    #   </domain>
    #   <groups/>
    # </user>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [User]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DomainUserGroupsService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of groups that the user is a member of.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Group>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DomainUsersService < Service
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all the users in the domain.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/domains/5678/users
    # ....
    # 
    # Will return the list of users in the domain:
    # 
    # [source,xml]
    # ----
    # <users>
    #   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
    #     <name>admin</name>
    #     <namespace>*</namespace>
    #     <principal>admin</principal>
    #     <user_name>admin@internal-authz</user_name>
    #     <domain href="/ovirt-engine/api/domains/5678" id="5678">
    #       <name>internal-authz</name>
    #     </domain>
    #     <groups/>
    #   </user>
    # </users>
    # ----
    # 
    # The order of the returned list of users isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of users to return. If not specified all the users are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned users.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<User>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to a service to view details of a domain user.
    # 
    # @param id [String] The identifier of the `user`.
    # 
    # @return [DomainUserService] A reference to the `user` service.
    # 
    def user_service(id)
      DomainUserService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return user_service(path)
      end
      return user_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class DomainsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all the authentication domains in the system.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/domains
    # ....
    # 
    # Will return the list of domains:
    # 
    # [source,xml]
    # ----
    # <domains>
    #   <domain href="/ovirt-engine/api/domains/5678" id="5678">
    #     <name>internal-authz</name>
    #     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
    #     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
    #     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
    #     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
    #   </domain>
    # </domains>
    # ----
    # 
    # The order of the returned list of domains isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of domains to return. If not specified all the domains are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Domain>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to a service to view details of a domain.
    # 
    # @param id [String] The identifier of the `domain`.
    # 
    # @return [DomainService] A reference to the `domain` service.
    # 
    def domain_service(id)
      DomainService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return domain_service(path)
      end
      return domain_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class EventService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get an event.
    # 
    # An example of getting an event:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/events/123
    # ----
    # 
    # [source,xml]
    # ----
    # <event href="/ovirt-engine/api/events/123" id="123">
    #   <description>Host example.com was added by admin@internal-authz.</description>
    #   <code>42</code>
    #   <correlation_id>135</correlation_id>
    #   <custom_id>-1</custom_id>
    #   <flood_rate>30</flood_rate>
    #   <origin>oVirt</origin>
    #   <severity>normal</severity>
    #   <time>2016-12-11T11:13:44.654+02:00</time>
    #   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
    #   <host href="/ovirt-engine/api/hosts/789" id="789"/>
    #   <user href="/ovirt-engine/api/users/987" id="987"/>
    # </event>
    # ----
    # 
    # Note that the number of fields changes according to the information that resides on the event.
    # For example, for storage domain related events you will get the storage domain reference,
    # as well as the reference for the data center this storage domain resides in.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Event]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes an event from internal audit log.
    # 
    # An event can be removed by sending following request
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/events/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class EventSubscriptionService < Service
    
    GET = [
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the information about the event-subscription.
    # 
    # For example to retrieve the information about the subscription of user '123' to
    # the event 'vm_console_detected':
    # 
    # ....
    # GET /ovirt-engine/api/users/123/vm_console_detected
    # ....
    # 
    # [source,xml]
    # ----
    # <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_console_detected">
    #   <event>vm_console_detected</event>
    #   <notification_method>smtp</notification_method>
    #   <user href="/ovirt-engine/api/users/123" id="123"/>
    #   <address>a@b.com</address>
    # </event-subscription>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [EventSubscription]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the event-subscription from the system.
    # 
    # For example to remove user 123's subscription to `vm_console_detected` event:
    # 
    # ....
    # DELETE /ovirt-engine/api/users/123/vm_console_detected
    # ....
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class EventSubscriptionsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new event-subscription to the system.
    # 
    # An event-subscription is always added in the context of a user. For example, to add new
    # event-subscription for `host_high_cpu_use` for user `123`, and have the notification
    # sent to the e-mail address: `a@b.com`, send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/users/123/eventsubscriptions
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <event_subscription>
    #     <event>host_high_cpu_use</event>
    #     <address>a@b.com</address>
    # </event_subscription>
    # ----
    # 
    # The event name will become the ID of the new event-subscription entity:
    # GET .../api/users/123/eventsubscriptions/host_high_cpu_use
    # 
    # Note that no user id is provided in the request body. This is because the user-id (in this case 123)
    # is already known to the API from the context. Note also that event-subscription entity contains
    # notification-method field, but it is not provided either in the request body. This is because currently
    # it's always set to SMTP as SNMP notifications are still unsupported by the API layer.
    # 
    # @param event_subscription [EventSubscription] The added event-subscription.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [EventSubscription]
    # 
    def add(event_subscription, opts = {})
      internal_add(event_subscription, EventSubscription, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the event-subscriptions for the provided user.
    # 
    # For example to list event-subscriptions for user `123`:
    # 
    # ....
    # GET /ovirt-engine/api/users/123/event-subscriptions
    # ....
    # 
    # [source,xml]
    # ----
    # <event-subscriptions>
    #   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/host_install_failed">
    #     <event>host_install_failed</event>
    #     <notification_method>smtp</notification_method>
    #     <user href="/ovirt-engine/api/users/123" id="123"/>
    #     <address>a@b.com</address>
    #   </event-subscription>
    #   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_paused">
    #     <event>vm_paused</event>
    #     <notification_method>smtp</notification_method>
    #     <user href="/ovirt-engine/api/users/123" id="123"/>
    #     <address>a@b.com</address>
    #   </event-subscription>
    # </event-subscriptions>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of event-subscriptions to return.
    #   If not specified all the event-subscriptions are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<EventSubscription>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific event-subscription.
    # 
    # @param id [String] The identifier of the `event_subscription`.
    # 
    # @return [EventSubscriptionService] A reference to the `event_subscription` service.
    # 
    def event_subscription_service(id)
      EventSubscriptionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return event_subscription_service(path)
      end
      return event_subscription_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class EventsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds an external event to the internal audit log.
    # 
    # This is intended for integration with external systems that detect or produce events relevant for the
    # administrator of the system. For example, an external monitoring tool may be able to detect that a file system
    # is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
    # log sending a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/events
    # <event>
    #   <description>File system /home is full</description>
    #   <severity>alert</severity>
    #   <origin>mymonitor</origin>
    #   <custom_id>1467879754</custom_id>
    # </event>
    # ----
    # 
    # Events can also be linked to specific objects. For example, the above event could be linked to the specific
    # virtual machine where it happened, using the `vm` link:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/events
    # <event>
    #   <description>File system /home is full</description>
    #   <severity>alert</severity>
    #   <origin>mymonitor</origin>
    #   <custom_id>1467879754</custom_id>
    #   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
    # </event>
    # ----
    # 
    # NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
    # attribute, if provided, is simply ignored.
    # 
    # @param event [Event] The `event` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Event]
    # 
    def add(event, opts = {})
      internal_add(event, Event, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:from, Integer].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get list of events.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/events
    # ----
    # 
    # To the above request we get following response:
    # 
    # [source,xml]
    # ----
    # <events>
    #   <event href="/ovirt-engine/api/events/2" id="2">
    #     <description>User admin@internal-authz logged out.</description>
    #     <code>31</code>
    #     <correlation_id>1e892ea9</correlation_id>
    #     <custom_id>-1</custom_id>
    #     <flood_rate>30</flood_rate>
    #     <origin>oVirt</origin>
    #     <severity>normal</severity>
    #     <time>2016-09-14T12:14:34.541+02:00</time>
    #     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
    #   </event>
    #   <event href="/ovirt-engine/api/events/1" id="1">
    #     <description>User admin logged in.</description>
    #     <code>30</code>
    #     <correlation_id>1fbd81f4</correlation_id>
    #     <custom_id>-1</custom_id>
    #     <flood_rate>30</flood_rate>
    #     <origin>oVirt</origin>
    #     <severity>normal</severity>
    #     <time>2016-09-14T11:54:35.229+02:00</time>
    #     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
    #   </event>
    # </events>
    # ----
    # 
    # The following events occur:
    # 
    # * id="1" - The API logs in the admin user account.
    # * id="2" - The API logs out of the admin user account.
    # 
    # The order of the returned list of events is always garanteed. If the `sortby` clause is included in the
    # `search` parameter, then the events will be ordered according to that clause. If the `sortby` clause isn't
    # included, then the events will be sorted by the numeric value of the `id` attribute, starting with the
    # highest value. This, combined with the `max` parameter, simplifies obtaining the most recent event:
    # 
    # ....
    # GET /ovirt-engine/api/events?max=1
    # ....
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :from Indicates the event index after which events should be returned. The indexes of events are
    #   strictly increasing, so when this parameter is used only the events with greater indexes
    #   will be returned. For example, the following request will return only the events
    #   with indexes greater than `123`:
    #   
    #   [source]
    #   ----
    #   GET /ovirt-engine/api/events?from=123
    #   ----
    #   
    #   This parameter is optional, and if not specified then the first event returned will be most recently
    #   generated.
    # 
    # @option opts [Integer] :max Sets the maximum number of events to return. If not specified all the events are returned.
    # 
    # @option opts [String] :search The events service provides search queries similar to other resource services.
    #   
    #   We can search by providing specific severity.
    #   
    #   [source]
    #   ----
    #   GET /ovirt-engine/api/events?search=severity%3Dnormal
    #   ----
    #   
    #   To the above request we get a list of events which severity is equal to `normal`:
    #   
    #   [source,xml]
    #   ----
    #   <events>
    #     <event href="/ovirt-engine/api/events/2" id="2">
    #       <description>User admin@internal-authz logged out.</description>
    #       <code>31</code>
    #       <correlation_id>1fbd81f4</correlation_id>
    #       <custom_id>-1</custom_id>
    #       <flood_rate>30</flood_rate>
    #       <origin>oVirt</origin>
    #       <severity>normal</severity>
    #       <time>2016-09-14T11:54:35.229+02:00</time>
    #       <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
    #     </event>
    #     <event href="/ovirt-engine/api/events/1" id="1">
    #       <description>Affinity Rules Enforcement Manager started.</description>
    #       <code>10780</code>
    #       <custom_id>-1</custom_id>
    #       <flood_rate>30</flood_rate>
    #       <origin>oVirt</origin>
    #       <severity>normal</severity>
    #       <time>2016-09-14T11:52:18.861+02:00</time>
    #     </event>
    #   </events>
    #   ----
    #   
    #   A virtualization environment generates a large amount of events after
    #   a period of time. However, the API only displays a default number of
    #   events for one search query. To display more than the default, the API
    #   separates results into pages with the page command in a search query.
    #   The following search query tells the API to paginate results using a
    #   page value in combination with the sortby clause:
    #   
    #   [source]
    #   ----
    #   sortby time asc page 1
    #   ----
    #   
    #   Below example paginates event resources. The URL-encoded request is:
    #   
    #   [source]
    #   ----
    #   GET /ovirt-engine/api/events?search=sortby%20time%20asc%20page%201
    #   ----
    #   
    #   Increase the page value to view the next page of results.
    #   
    #   [source]
    #   ----
    #   GET /ovirt-engine/api/events?search=sortby%20time%20asc%20page%202
    #   ----
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Event>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    UNDELETE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UNDELETE
    
    # 
    # Executes the `undelete` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the un-delete should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def undelete(opts = {})
      internal_action(:undelete, nil, UNDELETE, opts)
    end
    
    # 
    # Reference to the service that manages a specific event.
    # 
    # @param id [String] The identifier of the `event`.
    # 
    # @return [EventService] A reference to the `event` service.
    # 
    def event_service(id)
      EventService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return event_service(path)
      end
      return event_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalComputeResourceService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves external compute resource details.
    # 
    # For example, to get the details of compute resource `234` of provider `123`, send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/externalhostproviders/123/computeresources/234
    # ....
    # 
    # It will return a response like this:
    # 
    # [source,xml]
    # ----
    # <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
    #   <name>hostname</name>
    #   <provider>oVirt</provider>
    #   <url>https://hostname/api</url>
    #   <user>admin@internal</user>
    #   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
    # </external_compute_resource>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalComputeResource]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ExternalComputeResourcesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves a list of external compute resources.
    # 
    # For example, to retrieve the compute resources of external host provider `123`, send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/externalhostproviders/123/computeresources
    # ....
    # 
    # It will return a response like this:
    # 
    # [source,xml]
    # ----
    # <external_compute_resources>
    #   <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
    #     <name>hostname</name>
    #     <provider>oVirt</provider>
    #     <url>https://address/api</url>
    #     <user>admin@internal</user>
    #     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
    #    </external_compute_resource>
    #    ...
    # </external_compute_resources>
    # ----
    # 
    # The order of the returned list of compute resources isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of resources to return. If not specified all the resources are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ExternalComputeResource>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # This service manages compute resource instance
    # 
    # @param id [String] The identifier of the `resource`.
    # 
    # @return [ExternalComputeResourceService] A reference to the `resource` service.
    # 
    def resource_service(id)
      ExternalComputeResourceService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return resource_service(path)
      end
      return resource_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalDiscoveredHostService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get discovered host info.
    # 
    # Retrieves information about an host that is managed in external provider management system, such as Foreman. The
    # information includes hostname, address, subnet, base image and more.
    # 
    # For example, to get the details of host `234` from provider `123`, send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/externalhostproviders/123/discoveredhosts/234
    # ....
    # 
    # The result will be like this:
    # 
    # [source,xml]
    # ----
    # <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/234" id="234">
    #  <name>mac001a4ad04040</name>
    #  <ip>10.34.67.43</ip>
    #  <last_report>2017-04-24 11:05:41 UTC</last_report>
    #  <mac>00:1a:4a:d0:40:40</mac>
    #  <subnet_name>sat0</subnet_name>
    #  <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
    # </external_discovered_host>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalDiscoveredHost]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ExternalDiscoveredHostsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get list of discovered hosts' information.
    # 
    # Discovered hosts are fetched from third-party providers such as Foreman.
    # 
    # To list all discovered hosts for provider `123` send the following:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/externalhostproviders/123/discoveredhost
    # ----
    # 
    # [source,xml]
    # ----
    # <external_discovered_hosts>
    #  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/456" id="456">
    #   <name>mac001a4ad04031</name>
    #   <ip>10.34.67.42</ip>
    #   <last_report>2017-04-24 11:05:41 UTC</last_report>
    #   <mac>00:1a:4a:d0:40:31</mac>
    #   <subnet_name>sat0</subnet_name>
    #   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
    #  </external_discovered_host>
    #  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/789" id="789">
    #   <name>mac001a4ad04040</name>
    #   <ip>10.34.67.43</ip>
    #   <last_report>2017-04-24 11:05:41 UTC</last_report>
    #   <mac>00:1a:4a:d0:40:40</mac>
    #   <subnet_name>sat0</subnet_name>
    #   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
    #  </external_discovered_host>
    #  ...
    # </external_discovered_hosts>
    # ----
    # 
    # The order of the returned list of hosts isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of hosts to return. If not specified all the hosts are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ExternalDiscoveredHost>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `host` service.
    # 
    # @param id [String] The identifier of the `host`.
    # 
    # @return [ExternalDiscoveredHostService] A reference to the `host` service.
    # 
    def host_service(id)
      ExternalDiscoveredHostService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return host_service(path)
      end
      return host_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalHostService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalHost]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ExternalHostGroupService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get host group information.
    # 
    # For example, to get the details of hostgroup `234` of provider `123`, send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/externalhostproviders/123/hostgroups/234
    # ....
    # 
    # It will return a response like this:
    # 
    # [source,xml]
    # ----
    # <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
    #   <name>rhel7</name>
    #   <architecture_name>x86_64</architecture_name>
    #   <domain_name>s.com</domain_name>
    #   <operating_system_name>RedHat 7.3</operating_system_name>
    #   <subnet_name>sat0</subnet_name>
    #   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
    # </external_host_group>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalHostGroup]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ExternalHostGroupsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get host groups list from external host provider.
    # 
    # Host group is a term of host providers - the host group includes provision details. This API returns all possible
    # hostgroups exposed by the external provider.
    # 
    # For example, to get the details of all host groups of provider `123`, send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/externalhostproviders/123/hostgroups
    # ....
    # 
    # The response will be like this:
    # 
    # [source,xml]
    # ----
    # <external_host_groups>
    #   <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
    #     <name>rhel7</name>
    #     <architecture_name>x86_64</architecture_name>
    #     <domain_name>example.com</domain_name>
    #     <operating_system_name>RedHat 7.3</operating_system_name>
    #     <subnet_name>sat0</subnet_name>
    #     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
    #   </external_host_group>
    #   ...
    # </external_host_groups>
    # ----
    # 
    # The order of the returned list of host groups isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of groups to return. If not specified all the groups are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ExternalHostGroup>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # This service manages hostgroup instance.
    # 
    # @param id [String] The identifier of the `group`.
    # 
    # @return [ExternalHostGroupService] A reference to the `group` service.
    # 
    def group_service(id)
      ExternalHostGroupService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return group_service(path)
      end
      return group_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalHostProvidersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new external host provider to the system.
    # 
    # @param provider [ExternalHostProvider] The `provider` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalHostProvider]
    # 
    def add(provider, opts = {})
      internal_add(provider, ExternalHostProvider, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of external host providers.
    # 
    # The order of the returned list of host providers isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of providers to return. If not specified all the providers are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned external host providers.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ExternalHostProvider>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `provider` service.
    # 
    # @param id [String] The identifier of the `provider`.
    # 
    # @return [ExternalHostProviderService] A reference to the `provider` service.
    # 
    def provider_service(id)
      ExternalHostProviderService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return provider_service(path)
      end
      return provider_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalHostsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Return the list of external hosts.
    # 
    # The order of the returned list of hosts isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of hosts to return. If not specified all the hosts are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ExternalHost>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `host` service.
    # 
    # @param id [String] The identifier of the `host`.
    # 
    # @return [ExternalHostService] A reference to the `host` service.
    # 
    def host_service(id)
      ExternalHostService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return host_service(path)
      end
      return host_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalNetworkProviderConfigurationService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the information about an external network provider on the host.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalNetworkProviderConfiguration]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ExternalNetworkProviderConfigurationsService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of all external network providers on the host.
    # 
    # The order of the returned list of networks is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ExternalNetworkProviderConfiguration>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `configuration` service.
    # 
    # @param id [String] The identifier of the `configuration`.
    # 
    # @return [ExternalNetworkProviderConfigurationService] A reference to the `configuration` service.
    # 
    def configuration_service(id)
      ExternalNetworkProviderConfigurationService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return configuration_service(path)
      end
      return configuration_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalProviderService < Service
    
    IMPORT_CERTIFICATES = [
      [:certificates, List].freeze,
    ].freeze
    
    private_constant :IMPORT_CERTIFICATES
    
    # 
    # Import the SSL certificates of the external host provider.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Array<Certificate>] :certificates 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import_certificates(opts = {})
      internal_action(:importcertificates, nil, IMPORT_CERTIFICATES, opts)
    end
    
    TEST_CONNECTIVITY = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :TEST_CONNECTIVITY
    
    # 
    # In order to test connectivity for external provider we need
    # to run following request where 123 is an id of a provider.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the test should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def test_connectivity(opts = {})
      internal_action(:testconnectivity, nil, TEST_CONNECTIVITY, opts)
    end
    
    # 
    # A service to view certificates for this external provider.
    # 
    # @return [ExternalProviderCertificatesService] A reference to `certificates` service.
    # 
    def certificates_service
      @certificates_service ||= ExternalProviderCertificatesService.new(self, 'certificates')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'certificates'
        return certificates_service
      end
      if path.start_with?('certificates/')
        return certificates_service.service(path[13..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ExternalProviderCertificateService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get specific certificate.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/externalhostproviders/123/certificate/0
    # ----
    # 
    # And here is sample response:
    # 
    # [source,xml]
    # ----
    # <certificate id="0">
    #   <organization>provider.example.com</organization>
    #   <subject>CN=provider.example.com</subject>
    #   <content>...</content>
    # </certificate>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Certificate]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ExternalProviderCertificatesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the chain of certificates presented by the external provider.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/externalhostproviders/123/certificates
    # ----
    # 
    # And here is sample response:
    # 
    # [source,xml]
    # ----
    # <certificates>
    #   <certificate id="789">...</certificate>
    #   ...
    # </certificates>
    # ----
    # 
    # The order of the returned certificates is always guaranteed to be the sign order: the first is the
    # certificate of the server itself, the second the certificate of the CA that signs the first, so on.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of certificates to return. If not specified all the certificates are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Certificate>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to service that manages a specific certificate
    # for this external provider.
    # 
    # @param id [String] The identifier of the `certificate`.
    # 
    # @return [ExternalProviderCertificateService] A reference to the `certificate` service.
    # 
    def certificate_service(id)
      ExternalProviderCertificateService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return certificate_service(path)
      end
      return certificate_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalVmImportsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
    # 
    # For example import of a virtual machine from VMware can be facilitated using the following request:
    # 
    # [source]
    # ----
    # POST /externalvmimports
    # ----
    # 
    # With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
    # 
    # [source,xml]
    # ----
    # <external_vm_import>
    #   <vm>
    #     <name>my_vm</name>
    #   </vm>
    #   <cluster id="360014051136c20574f743bdbd28177fd" />
    #   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
    #   <name>vm_name_as_is_in_vmware</name>
    #   <sparse>true</sparse>
    #   <username>vmware_user</username>
    #   <password>123456</password>
    #   <provider>VMWARE</provider>
    #   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
    #   <drivers_iso id="virtio-win-1.6.7.iso" />
    # </external_vm_import>
    # ----
    # 
    # @param import [ExternalVmImport] The `import` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalVmImport]
    # 
    def add(import, opts = {})
      internal_add(import, ExternalVmImport, ADD, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class FenceAgentService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets details of this fence agent.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/hosts/123/fenceagents/0
    # ----
    # 
    # And here is sample response:
    # 
    # [source,xml]
    # ----
    # <agent id="0">
    #   <type>apc</type>
    #   <order>1</order>
    #   <ip>192.168.1.101</ip>
    #   <user>user</user>
    #   <password>xxx</password>
    #   <port>9</port>
    #   <options>name1=value1, name2=value2</options>
    # </agent>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Agent]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a fence agent for a specific host.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/hosts/123/fenceagents/0
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update a fencing-agent.
    # 
    # @param agent [Agent] Fence agent details.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Agent]
    # 
    def update(agent, opts = {})
      internal_update(agent, Agent, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class FenceAgentsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new fencing-agent to the host.
    # 
    # [source]
    # 
    # ----
    # POST /ovirt-engine/api/hosts/123/fenceagents
    # 
    # You should consult the /usr/sbin/fence_<agent_name> manual page for
    # the legal parameters to [name1=value1, name2=value2,...] in the options field.
    # If any parameter in options appears by name that means that it is mandatory.
    # For example in <options>slot=7[,name1=value1, name2=value2,...]</options>
    # slot is mandatory.
    # ----
    # 
    # apc, bladecenter, wti fencing agent/s sample request:
    # 
    # [source,xml]
    # 
    #   <agent>
    #     <type>apc</type>
    #     <order>1</order>
    #     <ip>192.168.1.101</ip>
    #     <user>user</user>
    #     <password>xxx</password>
    #     <port>9</port>
    #     <options>slot=7[,name1=value1, name2=value2,...]</options>
    #   </agent>
    # 
    # apc_snmp, hpblade, ilo, ilo2, ilo_ssh, redfish, rsa fencing agent/s sample request:
    # 
    # [source,xml]
    # 
    #   <agent>
    #     <type>apc_snmp</type>
    #     <order>1</order>
    #     <ip>192.168.1.101</ip>
    #     <user>user</user>
    #     <password>xxx</password>
    #     <port>9</port>
    #     <options>[name1=value1, name2=value2,...]</options>
    #   </agent>
    # 
    # 
    # cisco_ucs, drac5, eps fencing agent/s sample request:
    # 
    # [source,xml]
    # 
    #   <agent>
    #     <type>cisco_ucs</type>
    #     <order>1</order>
    #     <ip>192.168.1.101</ip>
    #     <user>user</user>
    #     <password>xxx</password>
    #     <options>slot=7[,name1=value1, name2=value2,...]</options>
    #   </agent>
    # 
    # drac7, ilo3, ilo4, ipmilan, rsb fencing agent/s sample request:
    # 
    # [source,xml]
    # 
    #   <agent>
    #     <type>drac7</type>
    #     <order>1</order>
    #     <ip>192.168.1.101</ip>
    #     <user>user</user>
    #     <password>xxx</password>
    #     <options>[name1=value1, name2=value2,...]</options>
    #   </agent>
    # 
    # @param agent [Agent] The `agent` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Agent]
    # 
    def add(agent, opts = {})
      internal_add(agent, Agent, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of fencing agents configured for the host.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/hosts/123/fenceagents
    # ----
    # 
    # And here is sample response:
    # 
    # [source,xml]
    # ----
    # <agents>
    #   <agent id="0">
    #     <type>apc</type>
    #     <order>1</order>
    #     <ip>192.168.1.101</ip>
    #     <user>user</user>
    #     <password>xxx</password>
    #     <port>9</port>
    #     <options>name1=value1, name2=value2</options>
    #   </agent>
    # </agents>
    # ----
    # 
    # The order of the returned list of fencing agents isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of agents to return. If not specified all the agents are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Agent>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to service that manages a specific fence agent
    # for this host.
    # 
    # @param id [String] The identifier of the `agent`.
    # 
    # @return [FenceAgentService] A reference to the `agent` service.
    # 
    def agent_service(id)
      FenceAgentService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return agent_service(path)
      end
      return agent_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class FileService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [File]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class FilesService < Service
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:refresh, TrueClass].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of ISO images and virtual floppy disks available in the storage domain. The order of
    # the returned list is not guaranteed.
    # 
    # If the `refresh` parameter is `false`, the returned list may not reflect recent changes to the storage domain;
    # for example, it may not contain a new ISO file that was recently added. This is because the
    # server caches the list of files to improve performance. To get the very latest results, set the `refresh`
    # parameter to `true`.
    # 
    # The default value of the `refresh` parameter is `true`, but it can be changed using the configuration value
    # `ForceRefreshDomainFilesByDefault`:
    # 
    # [source]
    # ----
    # # engine-config -s ForceRefreshDomainFilesByDefault=false
    # ----
    # 
    # IMPORTANT: Setting the value of the `refresh` parameter to `true` has an impact on the performance of the
    # server. Use it only if necessary.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should take case into
    #   account. The default value is `true`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of files to return. If not specified, all the files are returned.
    # 
    # @option opts [Boolean] :refresh Indicates whether the list of files should be refreshed from the storage domain, rather than showing cached
    #   results that are updated at certain intervals.
    # 
    # @option opts [String] :search A query string used to restrict the returned files.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<File>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `file` service.
    # 
    # @param id [String] The identifier of the `file`.
    # 
    # @return [FileService] A reference to the `file` service.
    # 
    def file_service(id)
      FileService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return file_service(path)
      end
      return file_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class FilterService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Filter]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class FiltersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a filter to a specified user defined scheduling policy.
    # 
    # @param filter [Filter] The `filter` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Filter]
    # 
    def add(filter, opts = {})
      internal_add(filter, Filter, ADD, opts)
    end
    
    LIST = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of filters used by the scheduling policy.
    # 
    # The order of the returned list of filters isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of filters to return. If not specified all the filters are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Filter>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `filter` service.
    # 
    # @param id [String] The identifier of the `filter`.
    # 
    # @return [FilterService] A reference to the `filter` service.
    # 
    def filter_service(id)
      FilterService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return filter_service(path)
      end
      return filter_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class FollowService < Service
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class GlusterBricksService < Service
    
    ACTIVATE = [
      [:async, TrueClass].freeze,
      [:bricks, List].freeze,
    ].freeze
    
    private_constant :ACTIVATE
    
    # 
    # Activate the bricks post data migration of remove brick operation.
    # 
    # Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
    # bricks. The bricks that were previously marked for removal will now be used as normal bricks.
    # 
    # For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
    # this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <bricks>
    #     <brick>
    #       <name>host1:/rhgs/brick1</name>
    #     </brick>
    #   </bricks>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the activation should be performed asynchronously.
    # 
    # @option opts [Array<GlusterBrick>] :bricks The list of bricks that need to be re-activated.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def activate(opts = {})
      internal_action(:activate, nil, ACTIVATE, opts)
    end
    
    ADD = [
      [:replica_count, Integer].freeze,
      [:stripe_count, Integer].freeze,
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a list of bricks to gluster volume.
    # 
    # Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
    # needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
    # equivalent to the number of replica sets.
    # 
    # For example, to add bricks to gluster volume `123`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <bricks>
    #   <brick>
    #     <server_id>111</server_id>
    #     <brick_dir>/export/data/brick3</brick_dir>
    #   </brick>
    # </bricks>
    # ----
    # 
    # @param bricks [Array<GlusterBrick>] The list of bricks to be added to the volume
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Integer] :replica_count Replica count of volume post add operation.
    # 
    # @option opts [Integer] :stripe_count Stripe count of volume post add operation.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<GlusterBrick>]
    # 
    def add(bricks, opts = {})
      internal_add(bricks, List, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists the bricks of a gluster volume.
    # 
    # For example, to list bricks of gluster volume `123`, send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
    # ----
    # 
    # Provides an output as below:
    # 
    # [source,xml]
    # ----
    # <bricks>
    #   <brick id="234">
    #     <name>host1:/rhgs/data/brick1</name>
    #     <brick_dir>/rhgs/data/brick1</brick_dir>
    #     <server_id>111</server_id>
    #     <status>up</status>
    #   </brick>
    #   <brick id="233">
    #     <name>host2:/rhgs/data/brick1</name>
    #     <brick_dir>/rhgs/data/brick1</brick_dir>
    #     <server_id>222</server_id>
    #     <status>up</status>
    #   </brick>
    # </bricks>
    # ----
    # 
    # The order of the returned list is based on the brick order provided at gluster volume creation.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of bricks to return. If not specified all the bricks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<GlusterBrick>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    MIGRATE = [
      [:async, TrueClass].freeze,
      [:bricks, List].freeze,
    ].freeze
    
    private_constant :MIGRATE
    
    # 
    # Start migration of data prior to removing bricks.
    # 
    # Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
    # bricks. Once migration is completed the removal of bricks is confirmed via the API
    # <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
    # <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
    # 
    # For instance, to delete a brick from a gluster volume with id `123`, send a request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <bricks>
    #     <brick>
    #       <name>host1:/rhgs/brick1</name>
    #     </brick>
    #   </bricks>
    # </action>
    # ----
    # 
    # The migration process can be tracked from the job id returned from the API using
    # <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the migration should be performed asynchronously.
    # 
    # @option opts [Array<GlusterBrick>] :bricks List of bricks for which data migration needs to be started.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def migrate(opts = {})
      internal_action(:migrate, nil, MIGRATE, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
      [:bricks, List].freeze,
      [:replica_count, Integer].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes bricks from gluster volume.
    # 
    # The recommended way to remove bricks without data loss is to first migrate the data using
    # <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
    # bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
    # 
    # For example, to delete the bricks from gluster volume `123`, send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <bricks>
    #   <brick>
    #     <name>host:brick_directory</name>
    #   </brick>
    # </bricks>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Array<GlusterBrick>] :bricks The list of bricks to be removed
    # @option opts [Integer] :replica_count Replica count of volume post add operation.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    STOP_MIGRATE = [
      [:async, TrueClass].freeze,
      [:bricks, List].freeze,
    ].freeze
    
    private_constant :STOP_MIGRATE
    
    # 
    # Stops migration of data from bricks for a remove brick operation.
    # 
    # To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
    # continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
    # operation.
    # 
    # For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <bricks>
    #   <brick>
    #     <name>host:brick_directory</name>
    #   </brick>
    # </bricks>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Array<GlusterBrick>] :bricks List of bricks for which data migration needs to be stopped. This list should match the arguments passed to
    #   <<services/gluster_bricks/methods/migrate, migrate>>.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def stop_migrate(opts = {})
      internal_action(:stopmigrate, nil, STOP_MIGRATE, opts)
    end
    
    # 
    # Returns a reference to the service managing a single gluster brick.
    # 
    # @param id [String] The identifier of the `brick`.
    # 
    # @return [GlusterBrickService] A reference to the `brick` service.
    # 
    def brick_service(id)
      GlusterBrickService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return brick_service(path)
      end
      return brick_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class GlusterHookService < Service
    
    DISABLE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :DISABLE
    
    # 
    # Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
    # cluster. This updates the hook status to `DISABLED` in database.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def disable(opts = {})
      internal_action(:disable, nil, DISABLE, opts)
    end
    
    ENABLE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :ENABLE
    
    # 
    # Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
    # cluster. This updates the hook status to `DISABLED` in database.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def enable(opts = {})
      internal_action(:enable, nil, ENABLE, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GlusterHook]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the this Gluster hook from all servers in cluster and deletes it from the database.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    RESOLVE = [
      [:async, TrueClass].freeze,
      [:host, Host].freeze,
      [:resolution_type, String].freeze,
    ].freeze
    
    private_constant :RESOLVE
    
    # 
    # Resolves missing hook conflict depending on the resolution type.
    # 
    # For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
    # engine maintains a list of all servers where hook is missing.
    # 
    # For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
    # the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
    # id is passed as parameter, the hook content from the server is used as the master to copy to other servers
    # in cluster.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Host] :host 
    # 
    # @option opts [String] :resolution_type 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def resolve(opts = {})
      internal_action(:resolve, nil, RESOLVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class GlusterHooksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of hooks.
    # 
    # The order of the returned list of hooks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of hooks to return. If not specified all the hooks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<GlusterHook>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `hook` service.
    # 
    # @param id [String] The identifier of the `hook`.
    # 
    # @return [GlusterHookService] A reference to the `hook` service.
    # 
    def hook_service(id)
      GlusterHookService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return hook_service(path)
      end
      return hook_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class GlusterVolumesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new gluster volume.
    # 
    # The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
    # `bricks` are required.
    # 
    # For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/123/glustervolumes
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <gluster_volume>
    #   <name>myvolume</name>
    #   <volume_type>replicate</volume_type>
    #   <replica_count>3</replica_count>
    #   <bricks>
    #     <brick>
    #       <server_id>server1</server_id>
    #       <brick_dir>/exp1</brick_dir>
    #     </brick>
    #     <brick>
    #       <server_id>server2</server_id>
    #       <brick_dir>/exp1</brick_dir>
    #     </brick>
    #     <brick>
    #       <server_id>server3</server_id>
    #       <brick_dir>/exp1</brick_dir>
    #     </brick>
    #   <bricks>
    # </gluster_volume>
    # ----
    # 
    # @param volume [GlusterVolume] The gluster volume definition from which to create the volume is passed as input and the newly created
    #   volume is returned.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GlusterVolume]
    # 
    def add(volume, opts = {})
      internal_add(volume, GlusterVolume, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all gluster volumes in the cluster.
    # 
    # For example, to list all Gluster Volumes in cluster `456`, send a request like
    # this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusters/456/glustervolumes
    # ----
    # 
    # The order of the returned list of volumes isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of volumes to return. If not specified all the volumes are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned volumes.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<GlusterVolume>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to a service managing gluster volume.
    # 
    # @param id [String] The identifier of the `volume`.
    # 
    # @return [GlusterVolumeService] A reference to the `volume` service.
    # 
    def volume_service(id)
      GlusterVolumeService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return volume_service(path)
      end
      return volume_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class GroupService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the system group information.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/groups/123
    # ....
    # 
    # Will return the group information:
    # 
    # [source,xml]
    # ----
    # <group href="/ovirt-engine/api/groups/123" id="123">
    #   <name>mygroup</name>
    #   <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
    #   <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
    #   <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
    #   <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
    #   <namespace>DC=example,DC=com</namespace>
    #   <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
    #     <name>myextension-authz</name>
    #   </domain>
    # </group>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Group]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the system group.
    # 
    # Usage:
    # 
    # ....
    # DELETE /ovirt-engine/api/groups/123
    # ....
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Reference to the service that manages the collection of permissions assigned to this system group.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Reference to the service that manages the collection of roles assigned to this system group.
    # 
    # @return [AssignedRolesService] A reference to `roles` service.
    # 
    def roles_service
      @roles_service ||= AssignedRolesService.new(self, 'roles')
    end
    
    # 
    # Reference to the service that manages the collection of tags assigned to this system group.
    # 
    # @return [AssignedTagsService] A reference to `tags` service.
    # 
    def tags_service
      @tags_service ||= AssignedTagsService.new(self, 'tags')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'roles'
        return roles_service
      end
      if path.start_with?('roles/')
        return roles_service.service(path[6..-1])
      end
      if path == 'tags'
        return tags_service
      end
      if path.start_with?('tags/')
        return tags_service.service(path[5..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class GroupsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add group from a directory service. Please note that domain name is name of the authorization provider.
    # 
    # For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
    # like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/groups
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <group>
    #   <name>Developers</name>
    #   <domain>
    #     <name>internal-authz</name>
    #   </domain>
    # </group>
    # ----
    # 
    # @param group [Group] The group to be added.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Group]
    # 
    def add(group, opts = {})
      internal_add(group, Group, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all the groups in the system.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/groups
    # ....
    # 
    # Will return the list of groups:
    # 
    # [source,xml]
    # ----
    # <groups>
    #   <group href="/ovirt-engine/api/groups/123" id="123">
    #     <name>mygroup</name>
    #     <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
    #     <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
    #     <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
    #     <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
    #     <namespace>DC=example,DC=com</namespace>
    #     <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
    #       <name>myextension-authz</name>
    #     </domain>
    #   </group>
    #   ...
    # </groups>
    # ----
    # 
    # The order of the returned list of groups isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of groups to return. If not specified all the groups are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned groups.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Group>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific group.
    # 
    # @param id [String] The identifier of the `group`.
    # 
    # @return [GroupService] A reference to the `group` service.
    # 
    def group_service(id)
      GroupService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return group_service(path)
      end
      return group_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class HostDeviceService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieve information about a particular host's device.
    # 
    # An example of getting a host device:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/hosts/123/devices/456
    # ----
    # 
    # [source,xml]
    # ----
    # <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
    #   <name>usb_1_9_1_1_0</name>
    #   <capability>usb</capability>
    #   <host href="/ovirt-engine/api/hosts/123" id="123"/>
    #   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
    #     <name>usb_1_9_1</name>
    #   </parent_device>
    # </host_device>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [HostDevice]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class HostDevicesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the devices of a host.
    # 
    # The order of the returned list of devices isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of devices to return. If not specified all the devices are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<HostDevice>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that can be used to access a specific host device.
    # 
    # @param id [String] The identifier of the `device`.
    # 
    # @return [HostDeviceService] A reference to the `device` service.
    # 
    def device_service(id)
      HostDeviceService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return device_service(path)
      end
      return device_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class HostHookService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Hook]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class HostHooksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of hooks configured for the host.
    # 
    # The order of the returned list of hooks is random.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of hooks to return. If not specified, all the hooks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Hook>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `hook` service.
    # 
    # @param id [String] The identifier of the `hook`.
    # 
    # @return [HostHookService] A reference to the `hook` service.
    # 
    def hook_service(id)
      HostHookService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return hook_service(path)
      end
      return hook_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class HostNicsService < Service
    
    LIST = [
      [:all_content, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of network interfaces of the host.
    # 
    # The order of the returned list of network interfaces isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all of the attributes of the host network interface should be included in the response.
    #   
    #   By default the following attributes are excluded:
    #   
    #   - `virtual_functions_configuration`
    #   
    #   For example, to retrieve the complete representation of network interface '456' of host '123':
    #   
    #   ....
    #   GET /ovirt-engine/api/hosts/123/nics?all_content=true
    #   ....
    #   
    #   NOTE: These attributes are not included by default because retrieving them impacts performance. They are
    #   seldom used and require additional queries to the database. Use this parameter with caution and only when
    #   specifically required.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of NICs to return. If not specified all the NICs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<HostNic>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a single network interface.
    # 
    # @param id [String] The identifier of the `nic`.
    # 
    # @return [HostNicService] A reference to the `nic` service.
    # 
    def nic_service(id)
      HostNicService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return nic_service(path)
      end
      return nic_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class HostNumaNodesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of NUMA nodes of the host.
    # 
    # The order of the returned list of NUMA nodes isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of nodes to return. If not specified all the nodes are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<NumaNode>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `node` service.
    # 
    # @param id [String] The identifier of the `node`.
    # 
    # @return [HostNumaNodeService] A reference to the `node` service.
    # 
    def node_service(id)
      HostNumaNodeService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return node_service(path)
      end
      return node_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class HostStorageService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:report_status, TrueClass].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get list of storages.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/hosts/123/storage
    # ----
    # 
    # The XML response you get will be like this one:
    # 
    # [source,xml]
    # ----
    # <host_storages>
    #   <host_storage id="123">
    #     ...
    #   </host_storage>
    #   ...
    # </host_storages>
    # ----
    # 
    # The order of the returned list of storages isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Boolean] :report_status Indicates if the status of the LUNs in the storage should be checked.
    #   Checking the status of the LUN is an heavy weight operation and
    #   this data is not always needed by the user.
    #   This parameter will give the option to not perform the status check of the LUNs.
    #   
    #   The default is `true` for backward compatibility.
    #   
    #   Here an example with the LUN status :
    #   
    #   [source,xml]
    #   ----
    #   <host_storage id="123">
    #     <logical_units>
    #       <logical_unit id="123">
    #         <lun_mapping>0</lun_mapping>
    #         <paths>1</paths>
    #         <product_id>lun0</product_id>
    #         <serial>123</serial>
    #         <size>10737418240</size>
    #         <status>used</status>
    #         <vendor_id>LIO-ORG</vendor_id>
    #         <volume_group_id>123</volume_group_id>
    #       </logical_unit>
    #     </logical_units>
    #     <type>iscsi</type>
    #     <host id="123"/>
    #   </host_storage>
    #   ----
    #   
    #   Here an example without the LUN status :
    #   
    #   [source,xml]
    #   ----
    #   <host_storage id="123">
    #     <logical_units>
    #       <logical_unit id="123">
    #         <lun_mapping>0</lun_mapping>
    #         <paths>1</paths>
    #         <product_id>lun0</product_id>
    #         <serial>123</serial>
    #         <size>10737418240</size>
    #         <vendor_id>LIO-ORG</vendor_id>
    #         <volume_group_id>123</volume_group_id>
    #       </logical_unit>
    #     </logical_units>
    #     <type>iscsi</type>
    #     <host id="123"/>
    #   </host_storage>
    #   ----
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<HostStorage>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to a service managing the storage.
    # 
    # @param id [String] The identifier of the `storage`.
    # 
    # @return [StorageService] A reference to the `storage` service.
    # 
    def storage_service(id)
      StorageService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return storage_service(path)
      end
      return storage_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class HostsService < Service
    
    ADD = [
      [:activate, TrueClass].freeze,
      [:deploy_hosted_engine, TrueClass].freeze,
      [:reboot, TrueClass].freeze,
      [:undeploy_hosted_engine, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new host.
    # 
    # The host is created based on the attributes of the `host` parameter. The `name`, `address`, and `root_password`
    # properties are required.
    # 
    # For example, to add a host, send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <host>
    #   <name>myhost</name>
    #   <address>myhost.example.com</address>
    #   <root_password>myrootpassword</root_password>
    # </host>
    # ----
    # 
    # NOTE: The `root_password` element is only included in the client-provided initial representation and is not
    # exposed in the representations returned from subsequent requests.
    # 
    # IMPORTANT: Since version 4.1.2 of the engine, when a host is newly added, the host's firewall
    # definitions are overridden by default.
    # 
    # To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
    # ----
    # 
    # If the cluster has a default external network provider that is supported for automatic deployment,
    # the external network provider is deployed when adding the host.
    # Only external network providers for OVN are supported for the automatic deployment.
    # To deploy an external network provider other than the one defined in the clusters, overwrite the external
    # network provider when adding hosts, by sending the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts
    # ----
    # 
    # With a request body that contains a reference to the desired provider in the
    # `external_network_provider_configuration`:
    # 
    # [source,xml]
    # ----
    # <host>
    #   <name>myhost</name>
    #   <address>myhost.example.com</address>
    #   <root_password>123456</root_password>
    #   <external_network_provider_configurations>
    #     <external_network_provider_configuration>
    #       <external_network_provider name="ovirt-provider-ovn"/>
    #     </external_network_provider_configuration>
    #   </external_network_provider_configurations>
    # </host>
    # ----
    # 
    # @param host [Host] The host definition with which the new host is created is passed as a parameter, and the newly created host
    #   is returned.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to `true`, this host will be activated after its installation completes. When set to `false`
    #   the host will remain in `maintenance` status after its installation. Absence of this parameter will be
    #   interpreted as `true`, since the desired default behavior is activating the host after install.
    # 
    # @option opts [Boolean] :deploy_hosted_engine When set to `true`, this host deploys the hosted engine components. A missing value is treated
    #   as `true`, i.e., deploy the hosted engine components. Omitting this parameter equals `false`, and
    #   the host performs no operation in the hosted engine area.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [Boolean] :undeploy_hosted_engine When set to `true`, this host un-deploys the hosted engine components and does not
    #   function as part of the High Availability cluster. A missing value is treated as `true`, i.e., un-deploy.
    #   Omitting this parameter equals `false` and the host performs no operation in the hosted engine area.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def add(host, opts = {})
      internal_add(host, Host, ADD, opts)
    end
    
    LIST = [
      [:all_content, TrueClass].freeze,
      [:case_sensitive, TrueClass].freeze,
      [:check_vms_in_affinity_closure, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:migration_target_of, String].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get a list of all available hosts.
    # 
    # For example, to list the hosts send the following request:
    # 
    # ....
    # GET /ovirt-engine/api/hosts
    # ....
    # 
    # The response body will be similar to this:
    # 
    # [source,xml]
    # ----
    # <hosts>
    #   <host href="/ovirt-engine/api/hosts/123" id="123">
    #     ...
    #   </host>
    #   <host href="/ovirt-engine/api/hosts/456" id="456">
    #     ...
    #   </host>
    #   ...
    # </host>
    # ----
    # 
    # The order of the returned list of hosts is guaranteed only if the `sortby` clause is included in
    # the `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all of the attributes of the hosts should be included in the response.
    #   
    #   By default the following host attributes are excluded:
    #   
    #   - `hosted_engine`
    #   
    #   For example, to retrieve the complete representation of the hosts:
    #   
    #   ....
    #   GET /ovirt-engine/api/hosts?all_content=true
    #   ....
    #   
    #   NOTE: These attributes are not included by default because retrieving them impacts performance. They are
    #   seldom used and require additional queries to the database. Use this parameter with caution and only when
    #   specifically required.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [Boolean] :check_vms_in_affinity_closure This parameter can be used with `migration_target_of`
    #   to get valid migration targets for the listed virtual machines
    #   and all other virtual machines that are in positive enforcing
    #   affinity with the listed virtual machines.
    #   
    #   This is useful in case the virtual machines will be migrated
    #   together with others in positive affinity groups.
    #   
    #   The default value is `false`.
    #   
    #   ....
    #   GET /ovirt-engine/api/hosts?migration_target_of=123,456&check_vms_in_affinity_closure=true
    #   ....
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of hosts to return. If not specified all the hosts are returned.
    # 
    # @option opts [String] :migration_target_of Accepts a comma-separated list of virtual machine IDs and returns the hosts
    #   that these virtual machines can be migrated to.
    #   
    #   For example, to retrieve the list of hosts to which the virtual machine with ID 123 and
    #   the virtual machine with ID 456 can be migrated to, send the following request:
    #   
    #   ....
    #   GET /ovirt-engine/api/hosts?migration_target_of=123,456
    #   ....
    # 
    # @option opts [String] :search A query string used to restrict the returned hosts.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Host>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    ADD_USING_ROOT_PASSWORD = [
      [:activate, TrueClass].freeze,
      [:deploy_hosted_engine, TrueClass].freeze,
      [:reboot, TrueClass].freeze,
      [:undeploy_hosted_engine, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_USING_ROOT_PASSWORD
    
    # 
    # Add a new host to the system providing the host root password. This has been deprecated and provided for backwards compatibility.
    # 
    # @param host [Host] The host definition with which the new host is created is passed as a parameter, and the newly created host
    #   is returned.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to `true`, this host will be activated after its installation completes. When set to `false`
    #   the host will remain in `maintenance` status after its installation. Absence of this parameter will be
    #   interpreted as `true`, since the desired default behavior is activating the host after install.
    # 
    # @option opts [Boolean] :deploy_hosted_engine When set to `true`, this host deploys the hosted engine components. A missing value is treated
    #   as `true`, i.e., deploy the hosted engine components. Omitting this parameter equals `false`, and
    #   the host performs no operation in the hosted engine area.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [Boolean] :undeploy_hosted_engine When set to `true`, this host un-deploys the hosted engine components and does not
    #   function as part of the High Availability cluster. A missing value is treated as `true`, i.e., un-deploy.
    #   Omitting this parameter equals `false` and the host performs no operation in the hosted engine area.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def add_using_root_password(host, opts = {})
      internal_add(host, Host, ADD_USING_ROOT_PASSWORD, opts)
    end
    
    ADD_USING_SSH = [
      [:activate, TrueClass].freeze,
      [:deploy_hosted_engine, TrueClass].freeze,
      [:reboot, TrueClass].freeze,
      [:undeploy_hosted_engine, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_USING_SSH
    
    # 
    # Add a new host to the system providing the ssh password, fingerprint or public key.
    # 
    # @param host [Host] The host definition with which the new host is created is passed as a parameter, and the newly created host
    #   is returned.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to `true`, this host will be activated after its installation completes. When set to `false`
    #   the host will remain in `maintenance` status after its installation. Absence of this parameter will be
    #   interpreted as `true`, since the desired default behavior is activating the host after install.
    # 
    # @option opts [Boolean] :deploy_hosted_engine When set to `true`, this host deploys the hosted engine components. A missing value is treated
    #   as `true`, i.e., deploy the hosted engine components. Omitting this parameter equals `false`, and
    #   the host performs no operation in the hosted engine area.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [Boolean] :undeploy_hosted_engine When set to `true`, this host un-deploys the hosted engine components and does not
    #   function as part of the High Availability cluster. A missing value is treated as `true`, i.e., un-deploy.
    #   Omitting this parameter equals `false` and the host performs no operation in the hosted engine area.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def add_using_ssh(host, opts = {})
      internal_add(host, Host, ADD_USING_SSH, opts)
    end
    
    # 
    # A Reference to service managing a specific host.
    # 
    # @param id [String] The identifier of the `host`.
    # 
    # @return [HostService] A reference to the `host` service.
    # 
    def host_service(id)
      HostService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return host_service(path)
      end
      return host_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class IconService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get an icon.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/icons/123
    # ----
    # 
    # You will get a XML response like this one:
    # 
    # [source,xml]
    # ----
    # <icon id="123">
    #   <data>Some binary data here</data>
    #   <media_type>image/png</media_type>
    # </icon>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Icon]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class IconsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get a list of icons.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/icons
    # ----
    # 
    # You will get a XML response which is similar to this one:
    # 
    # [source,xml]
    # ----
    # <icons>
    #   <icon id="123">
    #     <data>...</data>
    #     <media_type>image/png</media_type>
    #   </icon>
    #   ...
    # </icons>
    # ----
    # 
    # The order of the returned list of icons isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of icons to return. If not specified all the icons are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Icon>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages an specific icon.
    # 
    # @param id [String] The identifier of the `icon`.
    # 
    # @return [IconService] A reference to the `icon` service.
    # 
    def icon_service(id)
      IconService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return icon_service(path)
      end
      return icon_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ImageService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Image]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT = [
      [:async, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:disk, Disk].freeze,
      [:import_as_template, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
      [:template, Template].freeze,
    ].freeze
    
    private_constant :IMPORT
    
    # 
    # Imports an image.
    # 
    # If the `import_as_template` parameter is `true` then the image will be imported as a template, otherwise it will
    # be imported as a disk.
    # 
    # When imported as a template, the name of the template can be specified by the optional `template.name`
    # parameter. If that parameter is not specified, then the name of the template will be automatically assigned by the
    # engine as `GlanceTemplate-x` (where `x` will be seven random hexadecimal characters).
    # 
    # When imported as a disk, the name of the disk can be specified by the optional `disk.name` parameter. If
    # that parameter is not specified, then the name of the disk will be automatically assigned by the engine as
    # `GlanceDisk-x` (where `x` will be the seven hexadecimal characters of the image identifier).
    # 
    # It is recommended to always explicitly specify the template or disk name, to avoid these automatic names
    # generated by the engine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the import should be performed asynchronously.
    # 
    # @option opts [Cluster] :cluster The cluster to which the image should be imported if the `import_as_template` parameter
    #   is set to `true`.
    # 
    # @option opts [Disk] :disk The disk to import.
    # 
    # @option opts [Boolean] :import_as_template Specifies if a template should be created from the imported disk.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain to which the disk should be imported.
    # 
    # @option opts [Template] :template The name of the template being created if the
    #   `import_as_template` parameter is set to `true`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import(opts = {})
      internal_action(:import, nil, IMPORT, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ImageTransferService < Service
    
    CANCEL = [
    ].freeze
    
    private_constant :CANCEL
    
    # 
    # Cancel the image transfer session. This terminates the transfer operation and removes the partial image.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def cancel(opts = {})
      internal_action(:cancel, nil, CANCEL, opts)
    end
    
    EXTEND = [
    ].freeze
    
    private_constant :EXTEND
    
    # 
    # Extend the image transfer session.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def extend(opts = {})
      internal_action(:extend, nil, EXTEND, opts)
    end
    
    FINALIZE = [
    ].freeze
    
    private_constant :FINALIZE
    
    # 
    # After finishing to transfer the data, finalize the transfer.
    # 
    # This will make sure that the data being transferred is valid and fits the
    # image entity that was targeted in the transfer. Specifically, will verify that
    # if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
    # and that the image doesn't have a backing file.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def finalize(opts = {})
      internal_action(:finalize, nil, FINALIZE, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get the image transfer entity.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ImageTransfer]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    PAUSE = [
    ].freeze
    
    private_constant :PAUSE
    
    # 
    # Pause the image transfer session.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def pause(opts = {})
      internal_action(:pause, nil, PAUSE, opts)
    end
    
    RESUME = [
    ].freeze
    
    private_constant :RESUME
    
    # 
    # Resume the image transfer session. The client will need to poll the transfer's phase until
    # it is different than `resuming`. For example:
    # 
    # [source,python]
    # ----
    # transfer_service = transfers_service.image_transfer_service(transfer.id)
    # transfer_service.resume()
    # transfer = transfer_service.get()
    # 
    # while transfer.phase == types.ImageTransferPhase.RESUMING:
    #    time.sleep(1)
    #    transfer = transfer_service.get()
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def resume(opts = {})
      internal_action(:resume, nil, RESUME, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class ImageTransfersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new image transfer. An image, disk or disk snapshot needs to be specified
    # in order to make a new transfer.
    # 
    # IMPORTANT: The `image` attribute is deprecated since version 4.2 of the engine.
    # Use the `disk` or `snapshot` attributes instead.
    # 
    # *Creating a new image transfer for downloading or uploading a `disk`:*
    # 
    # To create an image transfer to download or upload a disk with id `123`,
    # send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/imagetransfers
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <image_transfer>
    #   <disk id="123"/>
    #   <direction>upload|download</direction>
    # </image_transfer>
    # ----
    # 
    # 
    # *Creating a new image transfer for downloading or uploading a `disk_snapshot`:*
    # 
    # To create an image transfer to download or upload a `disk_snapshot` with id `456`,
    # send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/imagetransfers
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <image_transfer>
    #   <snapshot id="456"/>
    #   <direction>download|upload</direction>
    # </image_transfer>
    # ----
    # 
    # @param image_transfer [ImageTransfer] The image transfer to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ImageTransfer]
    # 
    def add(image_transfer, opts = {})
      internal_add(image_transfer, ImageTransfer, ADD, opts)
    end
    
    ADD_FOR_DISK = [
    ].freeze
    
    private_constant :ADD_FOR_DISK
    
    # 
    # Adds a new `image_transfer`.
    # 
    # @param image_transfer [ImageTransfer] The image transfer to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ImageTransfer]
    # 
    def add_for_disk(image_transfer, opts = {})
      internal_add(image_transfer, ImageTransfer, ADD_FOR_DISK, opts)
    end
    
    ADD_FOR_IMAGE = [
    ].freeze
    
    private_constant :ADD_FOR_IMAGE
    
    # 
    # Adds a new `image_transfer`.
    # 
    # @param image_transfer [ImageTransfer] The image transfer to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ImageTransfer]
    # 
    def add_for_image(image_transfer, opts = {})
      internal_add(image_transfer, ImageTransfer, ADD_FOR_IMAGE, opts)
    end
    
    ADD_FOR_SNAPSHOT = [
    ].freeze
    
    private_constant :ADD_FOR_SNAPSHOT
    
    # 
    # Adds a new `image_transfer`.
    # 
    # @param image_transfer [ImageTransfer] The image transfer to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ImageTransfer]
    # 
    def add_for_snapshot(image_transfer, opts = {})
      internal_add(image_transfer, ImageTransfer, ADD_FOR_SNAPSHOT, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the list of image transfers that are currently
    # being performed.
    # 
    # The order of the returned list of image transfers is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ImageTransfer>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages an
    # specific image transfer.
    # 
    # @param id [String] The identifier of the `image_transfer`.
    # 
    # @return [ImageTransferService] A reference to the `image_transfer` service.
    # 
    def image_transfer_service(id)
      ImageTransferService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return image_transfer_service(path)
      end
      return image_transfer_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ImagesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of images available in the storage domain or provider.
    # 
    # The order of the returned list of images isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of images to return. If not specified all the images are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Image>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `image` service.
    # 
    # @param id [String] The identifier of the `image`.
    # 
    # @return [ImageService] A reference to the `image` service.
    # 
    def image_service(id)
      ImageService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return image_service(path)
      end
      return image_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class InstanceTypeService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get a specific instance type and it's attributes.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/instancetypes/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [InstanceType]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a specific instance type from the system.
    # 
    # If a virtual machine was created using an instance type X after removal of the instance type
    # the virtual machine's instance type will be set to `custom`.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/instancetypes/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update a specific instance type and it's attributes.
    # 
    # All the attributes are editable after creation.
    # If a virtual machine was created using an instance type X and some configuration in instance
    # type X was updated, the virtual machine's configuration will be updated automatically by the
    # engine.
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/instancetypes/123
    # ----
    # 
    # For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
    # to 2 sockets and 1 core, send a request like this:
    # 
    # [source, xml]
    # ----
    # 
    # <instance_type>
    #   <memory>1073741824</memory>
    #   <cpu>
    #     <topology>
    #       <cores>1</cores>
    #       <sockets>2</sockets>
    #       <threads>1</threads>
    #     </topology>
    #   </cpu>
    # </instance_type>
    # ----
    # 
    # @param instance_type [InstanceType] The `instance_type` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [InstanceType]
    # 
    def update(instance_type, opts = {})
      internal_update(instance_type, InstanceType, UPDATE, opts)
    end
    
    # 
    # Reference to the service that manages the graphic consoles that are attached to this
    # instance type.
    # 
    # @return [InstanceTypeGraphicsConsolesService] A reference to `graphics_consoles` service.
    # 
    def graphics_consoles_service
      @graphics_consoles_service ||= InstanceTypeGraphicsConsolesService.new(self, 'graphicsconsoles')
    end
    
    # 
    # Reference to the service that manages the NICs that are attached to this instance type.
    # 
    # @return [InstanceTypeNicsService] A reference to `nics` service.
    # 
    def nics_service
      @nics_service ||= InstanceTypeNicsService.new(self, 'nics')
    end
    
    # 
    # Reference to the service that manages the watchdogs that are attached to this instance type.
    # 
    # @return [InstanceTypeWatchdogsService] A reference to `watchdogs` service.
    # 
    def watchdogs_service
      @watchdogs_service ||= InstanceTypeWatchdogsService.new(self, 'watchdogs')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'graphicsconsoles'
        return graphics_consoles_service
      end
      if path.start_with?('graphicsconsoles/')
        return graphics_consoles_service.service(path[17..-1])
      end
      if path == 'nics'
        return nics_service
      end
      if path.start_with?('nics/')
        return nics_service.service(path[5..-1])
      end
      if path == 'watchdogs'
        return watchdogs_service
      end
      if path.start_with?('watchdogs/')
        return watchdogs_service.service(path[10..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class InstanceTypeGraphicsConsoleService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets graphics console configuration of the instance type.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GraphicsConsole]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the graphics console from the instance type.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class InstanceTypeGraphicsConsolesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add new graphics console to the instance type.
    # 
    # @param console [GraphicsConsole] The `console` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GraphicsConsole]
    # 
    def add(console, opts = {})
      internal_add(console, GraphicsConsole, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all the configured graphics consoles of the instance type.
    # 
    # The order of the returned list of graphics consoles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of consoles to return. If not specified all the consoles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<GraphicsConsole>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific instance type graphics console.
    # 
    # @param id [String] The identifier of the `console`.
    # 
    # @return [InstanceTypeGraphicsConsoleService] A reference to the `console` service.
    # 
    def console_service(id)
      InstanceTypeGraphicsConsoleService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return console_service(path)
      end
      return console_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class InstanceTypeNicService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets network interface configuration of the instance type.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the network interface from the instance type.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the network interface configuration of the instance type.
    # 
    # @param nic [Nic] The `nic` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def update(nic, opts = {})
      internal_update(nic, Nic, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class InstanceTypeNicsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add new network interface to the instance type.
    # 
    # @param nic [Nic] The `nic` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def add(nic, opts = {})
      internal_add(nic, Nic, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all the configured network interface of the instance type.
    # 
    # The order of the returned list of network interfaces isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of NICs to return. If not specified all the NICs are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned templates.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Nic>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `nic` service.
    # 
    # @param id [String] The identifier of the `nic`.
    # 
    # @return [InstanceTypeNicService] A reference to the `nic` service.
    # 
    def nic_service(id)
      InstanceTypeNicService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return nic_service(path)
      end
      return nic_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class InstanceTypeWatchdogService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets watchdog configuration of the instance type.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove a watchdog from the instance type.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the watchdog configuration of the instance type.
    # 
    # @param watchdog [Watchdog] The `watchdog` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def update(watchdog, opts = {})
      internal_update(watchdog, Watchdog, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class InstanceTypeWatchdogsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add new watchdog to the instance type.
    # 
    # @param watchdog [Watchdog] The `watchdog` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def add(watchdog, opts = {})
      internal_add(watchdog, Watchdog, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all the configured watchdogs of the instance type.
    # 
    # The order of the returned list of watchdogs isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of watchdogs to return. If not specified all the watchdogs are
    #   returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned templates.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Watchdog>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `watchdog` service.
    # 
    # @param id [String] The identifier of the `watchdog`.
    # 
    # @return [InstanceTypeWatchdogService] A reference to the `watchdog` service.
    # 
    def watchdog_service(id)
      InstanceTypeWatchdogService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return watchdog_service(path)
      end
      return watchdog_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class InstanceTypesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new instance type.
    # 
    # This requires only a name attribute and can include all hardware configurations of the
    # virtual machine.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/instancetypes
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <instance_type>
    #   <name>myinstancetype</name>
    # </template>
    # ----
    # 
    # Creating an instance type with all hardware configurations with a request body like this:
    # 
    # [source,xml]
    # ----
    # <instance_type>
    #   <name>myinstancetype</name>
    #   <console>
    #     <enabled>true</enabled>
    #   </console>
    #   <cpu>
    #     <topology>
    #       <cores>2</cores>
    #       <sockets>2</sockets>
    #       <threads>1</threads>
    #     </topology>
    #   </cpu>
    #   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
    #   <custom_emulated_machine>q35</custom_emulated_machine>
    #   <display>
    #     <monitors>1</monitors>
    #     <single_qxl_pci>true</single_qxl_pci>
    #     <smartcard_enabled>true</smartcard_enabled>
    #     <type>spice</type>
    #   </display>
    #   <high_availability>
    #     <enabled>true</enabled>
    #     <priority>1</priority>
    #   </high_availability>
    #   <io>
    #     <threads>2</threads>
    #   </io>
    #   <memory>4294967296</memory>
    #   <memory_policy>
    #     <ballooning>true</ballooning>
    #     <guaranteed>268435456</guaranteed>
    #   </memory_policy>
    #   <migration>
    #     <auto_converge>inherit</auto_converge>
    #     <compressed>inherit</compressed>
    #     <policy id="00000000-0000-0000-0000-000000000000"/>
    #   </migration>
    #   <migration_downtime>2</migration_downtime>
    #   <os>
    #     <boot>
    #       <devices>
    #         <device>hd</device>
    #       </devices>
    #     </boot>
    #   </os>
    #   <rng_device>
    #     <rate>
    #       <bytes>200</bytes>
    #       <period>2</period>
    #     </rate>
    #     <source>urandom</source>
    #   </rng_device>
    #   <soundcard_enabled>true</soundcard_enabled>
    #   <usb>
    #     <enabled>true</enabled>
    #     <type>native</type>
    #   </usb>
    #   <virtio_scsi>
    #     <enabled>true</enabled>
    #   </virtio_scsi>
    # </instance_type>
    # ----
    # 
    # @param instance_type [InstanceType] The `instance_type` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [InstanceType]
    # 
    def add(instance_type, opts = {})
      internal_add(instance_type, InstanceType, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all existing instance types in the system.
    # 
    # The order of the returned list of instance types isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed
    #   taking case into account. The default value is `true`, which means that case is taken
    #   into account. If you want to search ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of instance types to return. If not specified all the instance
    #   types are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned templates.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<InstanceType>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `instance_type` service.
    # 
    # @param id [String] The identifier of the `instance_type`.
    # 
    # @return [InstanceTypeService] A reference to the `instance_type` service.
    # 
    def instance_type_service(id)
      InstanceTypeService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return instance_type_service(path)
      end
      return instance_type_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class IscsiBondService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [IscsiBond]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes of an existing iSCSI bond.
    # 
    # For example, to remove the iSCSI bond `456` send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates an iSCSI bond.
    # 
    # Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
    # update the iSCSI bond `456` of data center `123`, send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
    # ----
    # 
    # The request body should look like this:
    # 
    # [source,xml]
    # ----
    # <iscsi_bond>
    #    <name>mybond</name>
    #    <description>My iSCSI bond</description>
    # </iscsi_bond>
    # ----
    # 
    # @param bond [IscsiBond] The iSCSI bond to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [IscsiBond]
    # 
    def update(bond, opts = {})
      internal_update(bond, IscsiBond, UPDATE, opts)
    end
    
    # 
    # Locates the `networks` service.
    # 
    # @return [NetworksService] A reference to `networks` service.
    # 
    def networks_service
      @networks_service ||= NetworksService.new(self, 'networks')
    end
    
    # 
    # Locates the `storage_server_connections` service.
    # 
    # @return [StorageServerConnectionsService] A reference to `storage_server_connections` service.
    # 
    def storage_server_connections_service
      @storage_server_connections_service ||= StorageServerConnectionsService.new(self, 'storageserverconnections')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'networks'
        return networks_service
      end
      if path.start_with?('networks/')
        return networks_service.service(path[9..-1])
      end
      if path == 'storageserverconnections'
        return storage_server_connections_service
      end
      if path.start_with?('storageserverconnections/')
        return storage_server_connections_service.service(path[25..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class IscsiBondsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Create a new iSCSI bond on a data center.
    # 
    # For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
    # request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/iscsibonds
    # ----
    # 
    # The request body should look like this:
    # 
    # [source,xml]
    # ----
    # <iscsi_bond>
    #   <name>mybond</name>
    #   <storage_connections>
    #     <storage_connection id="456"/>
    #     <storage_connection id="789"/>
    #   </storage_connections>
    #   <networks>
    #     <network id="abc"/>
    #   </networks>
    # </iscsi_bond>
    # ----
    # 
    # @param bond [IscsiBond] The `bond` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [IscsiBond]
    # 
    def add(bond, opts = {})
      internal_add(bond, IscsiBond, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of iSCSI bonds configured in the data center.
    # 
    # The order of the returned list of iSCSI bonds isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of bonds to return. If not specified all the bonds are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<IscsiBond>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `iscsi_bond` service.
    # 
    # @param id [String] The identifier of the `iscsi_bond`.
    # 
    # @return [IscsiBondService] A reference to the `iscsi_bond` service.
    # 
    def iscsi_bond_service(id)
      IscsiBondService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return iscsi_bond_service(path)
      end
      return iscsi_bond_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class JobService < Service
    
    CLEAR = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :CLEAR
    
    # 
    # Set an external job execution to be cleared by the system.
    # 
    # For example, to set a job with identifier `123` send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/jobs/clear
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def clear(opts = {})
      internal_action(:clear, nil, CLEAR, opts)
    end
    
    END_ = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
      [:succeeded, TrueClass].freeze,
    ].freeze
    
    private_constant :END_
    
    # 
    # Marks an external job execution as ended.
    # 
    # For example, to terminate a job with identifier `123` send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/jobs/end
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <force>true</force>
    #   <status>finished</status>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the job should be forcibly terminated.
    # 
    # @option opts [Boolean] :succeeded Indicates if the job should be marked as successfully finished or as failed.
    #   
    #   This parameter is optional, and the default value is `true`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def end_(opts = {})
      internal_action(:end, nil, END_, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves a job.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/jobs/123
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <job href="/ovirt-engine/api/jobs/123" id="123">
    #   <actions>
    #     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
    #     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
    #   </actions>
    #   <description>Adding Disk</description>
    #   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
    #   <auto_cleared>true</auto_cleared>
    #   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
    #   <external>false</external>
    #   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
    #   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
    #   <status>failed</status>
    #   <owner href="/ovirt-engine/api/users/456" id="456"/>
    # </job>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Job]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # List all the steps of the job.
    # 
    # The order of the returned list of steps isn't guaranteed.
    # 
    # @return [StepsService] A reference to `steps` service.
    # 
    def steps_service
      @steps_service ||= StepsService.new(self, 'steps')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'steps'
        return steps_service
      end
      if path.start_with?('steps/')
        return steps_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class JobsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add an external job.
    # 
    # For example, to add a job with the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/jobs
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <job>
    #   <description>Doing some work</description>
    #   <auto_cleared>true</auto_cleared>
    # </job>
    # ----
    # 
    # The response should look like:
    # 
    # [source,xml]
    # ----
    # <job href="/ovirt-engine/api/jobs/123" id="123">
    #   <actions>
    #     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
    #     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
    #   </actions>
    #   <description>Doing some work</description>
    #   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
    #   <auto_cleared>true</auto_cleared>
    #   <external>true</external>
    #   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
    #   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
    #   <status>started</status>
    #   <owner href="/ovirt-engine/api/users/456" id="456"/>
    # </job>
    # ----
    # 
    # @param job [Job] Job that will be added.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Job]
    # 
    def add(job, opts = {})
      internal_add(job, Job, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the representation of the jobs.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/jobs
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <jobs>
    #   <job href="/ovirt-engine/api/jobs/123" id="123">
    #     <actions>
    #       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
    #       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
    #     </actions>
    #     <description>Adding Disk</description>
    #     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
    #     <auto_cleared>true</auto_cleared>
    #     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
    #     <external>false</external>
    #     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
    #     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
    #     <status>failed</status>
    #     <owner href="/ovirt-engine/api/users/456" id="456"/>
    #   </job>
    #   ...
    # </jobs>
    # ----
    # 
    # The order of the returned list of jobs isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of jobs to return. If not specified all the jobs are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned jobs.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Job>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the job service.
    # 
    # @param id [String] The identifier of the `job`.
    # 
    # @return [JobService] A reference to the `job` service.
    # 
    def job_service(id)
      JobService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return job_service(path)
      end
      return job_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class KatelloErrataService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the representation of the Katello errata.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/katelloerrata
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <katello_errata>
    #   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
    #     <name>RHBA-2013:XYZ</name>
    #     <description>The description of the erratum</description>
    #     <title>some bug fix update</title>
    #     <type>bugfix</type>
    #     <issued>2013-11-20T02:00:00.000+02:00</issued>
    #     <solution>Few guidelines regarding the solution</solution>
    #     <summary>Updated packages that fix one bug are now available for XYZ</summary>
    #     <packages>
    #       <package>
    #         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
    #       </package>
    #       ...
    #     </packages>
    #   </katello_erratum>
    #   ...
    # </katello_errata>
    # ----
    # 
    # The order of the returned list of erratum isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of errata to return. If not specified all the errata are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<KatelloErratum>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the Katello erratum service.
    # Use this service to view the erratum by its id.
    # 
    # @param id [String] The identifier of the `katello_erratum`.
    # 
    # @return [KatelloErratumService] A reference to the `katello_erratum` service.
    # 
    def katello_erratum_service(id)
      KatelloErratumService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return katello_erratum_service(path)
      end
      return katello_erratum_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class KatelloErratumService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves a Katello erratum.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/katelloerrata/123
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
    #   <name>RHBA-2013:XYZ</name>
    #   <description>The description of the erratum</description>
    #   <title>some bug fix update</title>
    #   <type>bugfix</type>
    #   <issued>2013-11-20T02:00:00.000+02:00</issued>
    #   <solution>Few guidelines regarding the solution</solution>
    #   <summary>Updated packages that fix one bug are now available for XYZ</summary>
    #   <packages>
    #     <package>
    #       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
    #     </package>
    #     ...
    #   </packages>
    # </katello_erratum>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [KatelloErratum]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class LinkLayerDiscoveryProtocolService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Fetches information elements received by LLDP.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<LinkLayerDiscoveryProtocolElement>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class MacPoolService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [MacPool]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a MAC address pool.
    # 
    # For example, to remove the MAC address pool having id `123` send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/macpools/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates a MAC address pool.
    # 
    # The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
    # 
    # For example, to update the MAC address pool of id `123` send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/macpools/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <mac_pool>
    #   <name>UpdatedMACPool</name>
    #   <description>An updated MAC address pool</description>
    #   <allow_duplicates>false</allow_duplicates>
    #   <ranges>
    #     <range>
    #       <from>00:1A:4A:16:01:51</from>
    #       <to>00:1A:4A:16:01:e6</to>
    #     </range>
    #     <range>
    #       <from>02:1A:4A:01:00:00</from>
    #       <to>02:1A:4A:FF:FF:FF</to>
    #     </range>
    #   </ranges>
    # </mac_pool>
    # ----
    # 
    # @param pool [MacPool] The `pool` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [MacPool]
    # 
    def update(pool, opts = {})
      internal_update(pool, MacPool, UPDATE, opts)
    end
    
    # 
    # Returns a reference to the service that manages the permissions that are associated with the MacPool.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class MacPoolsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new MAC address pool.
    # 
    # Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
    # 
    # For example, to create MAC address pool send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/macpools
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <mac_pool>
    #   <name>MACPool</name>
    #   <description>A MAC address pool</description>
    #   <allow_duplicates>true</allow_duplicates>
    #   <default_pool>false</default_pool>
    #   <ranges>
    #     <range>
    #       <from>00:1A:4A:16:01:51</from>
    #       <to>00:1A:4A:16:01:e6</to>
    #     </range>
    #   </ranges>
    # </mac_pool>
    # ----
    # 
    # @param pool [MacPool] The `pool` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [MacPool]
    # 
    def add(pool, opts = {})
      internal_add(pool, MacPool, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Return the list of MAC address pools of the system.
    # 
    # The returned list of MAC address pools isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of pools to return. If not specified all the pools are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<MacPool>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `mac_pool` service.
    # 
    # @param id [String] The identifier of the `mac_pool`.
    # 
    # @return [MacPoolService] A reference to the `mac_pool` service.
    # 
    def mac_pool_service(id)
      MacPoolService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return mac_pool_service(path)
      end
      return mac_pool_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class MeasurableService < Service
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class MoveableService < Service
    
    MOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :MOVE
    
    # 
    # Executes the `move` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the move should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def move(opts = {})
      internal_action(:move, nil, MOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class NetworkService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets a logical network.
    # 
    # For example:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/networks/123
    # ----
    # 
    # Will respond:
    # 
    # [source,xml]
    # ----
    # <network href="/ovirt-engine/api/networks/123" id="123">
    #   <name>ovirtmgmt</name>
    #   <description>Default Management Network</description>
    #   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
    #   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
    #   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
    #   <mtu>0</mtu>
    #   <stp>false</stp>
    #   <usages>
    #     <usage>vm</usage>
    #   </usages>
    #   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
    # </network>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a logical network, or the association of a logical network to a data center.
    # 
    # For example, to remove the logical network `123` send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/networks/123
    # ----
    # 
    # Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
    # result as if we would just remove that network. However it might be more specific to say we're removing network
    # `456` of data center `123`.
    # 
    # For example, to remove the association of network `456` to data center `123` send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/datacenters/123/networks/456
    # ----
    # 
    # NOTE: To remove an external logical network, the network has to be removed directly from its provider by
    # https://developer.openstack.org/api-ref/network[OpenStack Networking API].
    # The entity representing the external network inside {product-name} is removed automatically,
    # if <<types/open_stack_network_provider/attributes/auto_sync,`auto_sync`>> is enabled for the provider,
    # otherwise the entity has to be removed using this method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates a logical network.
    # 
    # The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
    # 
    # For example, to update the description of the logical network `123` send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/networks/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <network>
    #   <description>My updated description</description>
    # </network>
    # ----
    # 
    # 
    # The maximum transmission unit of a network is set using a PUT request to
    # specify the integer value of the `mtu` attribute.
    # 
    # For example, to set the maximum transmission unit send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/datacenters/123/networks/456
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <network>
    #   <mtu>1500</mtu>
    # </network>
    # ----
    # 
    # NOTE: Updating external networks is not propagated to the provider.
    # 
    # @param network [Network] The `network` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def update(network, opts = {})
      internal_update(network, Network, UPDATE, opts)
    end
    
    # 
    # Reference to the service that manages the network labels assigned to this network.
    # 
    # @return [NetworkLabelsService] A reference to `network_labels` service.
    # 
    def network_labels_service
      @network_labels_service ||= NetworkLabelsService.new(self, 'networklabels')
    end
    
    # 
    # Reference to the service that manages the permissions assigned to this network.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Reference to the service that manages the vNIC profiles assigned to this network.
    # 
    # @return [AssignedVnicProfilesService] A reference to `vnic_profiles` service.
    # 
    def vnic_profiles_service
      @vnic_profiles_service ||= AssignedVnicProfilesService.new(self, 'vnicprofiles')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'networklabels'
        return network_labels_service
      end
      if path.start_with?('networklabels/')
        return network_labels_service.service(path[14..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'vnicprofiles'
        return vnic_profiles_service
      end
      if path.start_with?('vnicprofiles/')
        return vnic_profiles_service.service(path[13..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class NetworkAttachmentService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkAttachment]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified network attachment on the host.
    # 
    # @param attachment [NetworkAttachment] The `attachment` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkAttachment]
    # 
    def update(attachment, opts = {})
      internal_update(attachment, NetworkAttachment, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class NetworkAttachmentsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new network attachment to the network interface.
    # 
    # @param attachment [NetworkAttachment] The `attachment` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkAttachment]
    # 
    def add(attachment, opts = {})
      internal_add(attachment, NetworkAttachment, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of network attachments of the host or host NIC.
    # 
    # The order of the returned list of network attachments isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of attachments to return. If not specified all the attachments are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<NetworkAttachment>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `attachment` service.
    # 
    # @param id [String] The identifier of the `attachment`.
    # 
    # @return [NetworkAttachmentService] A reference to the `attachment` service.
    # 
    def attachment_service(id)
      NetworkAttachmentService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return attachment_service(path)
      end
      return attachment_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class NetworkFilterService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves a representation of the network filter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkFilter]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class NetworkFiltersService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the representations of the network filters.
    # 
    # The order of the returned list of network filters isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<NetworkFilter>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `network_filter` service.
    # 
    # @param id [String] The identifier of the `network_filter`.
    # 
    # @return [NetworkFilterService] A reference to the `network_filter` service.
    # 
    def network_filter_service(id)
      NetworkFilterService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return network_filter_service(path)
      end
      return network_filter_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class NetworkLabelService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkLabel]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a label from a logical network.
    # 
    # For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/networks/123/networklabels/exemplary
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class NetworkLabelsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Attaches label to logical network.
    # 
    # You can attach labels to a logical network to automate the association of that logical network with physical host
    # network interfaces to which the same label has been attached.
    # 
    # For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/networks/123/networklabels
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <network_label id="mylabel"/>
    # ----
    # 
    # @param label [NetworkLabel] The `label` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkLabel]
    # 
    def add(label, opts = {})
      internal_add(label, NetworkLabel, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of labels attached to the network or host NIC.
    # 
    # The order of the returned list of labels isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of labels to return. If not specified all the labels are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<NetworkLabel>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `label` service.
    # 
    # @param id [String] The identifier of the `label`.
    # 
    # @return [NetworkLabelService] A reference to the `label` service.
    # 
    def label_service(id)
      NetworkLabelService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return label_service(path)
      end
      return label_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class NetworksService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new logical network, or associates an existing network with a data center.
    # 
    # Creation of a new network requires the `name` and `data_center` elements.
    # 
    # For example, to create a network named `mynetwork` for data center `123` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/networks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <network>
    #   <name>mynetwork</name>
    #   <data_center id="123"/>
    # </network>
    # ----
    # 
    # 
    # To associate the existing network `456` with the data center `123` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/networks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <network>
    #   <name>ovirtmgmt</name>
    # </network>
    # ----
    # 
    # To create a network named `exnetwork` on top of an external _OpenStack_ network provider `456` send a request
    # like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/networks
    # ----
    # 
    # [source,xml]
    # ----
    # <network>
    #   <name>exnetwork</name>
    #   <external_provider id="456"/>
    #   <data_center id="123"/>
    # </network>
    # ----
    # 
    # @param network [Network] The `network` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def add(network, opts = {})
      internal_add(network, Network, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List logical networks.
    # 
    # For example:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/networks
    # ----
    # 
    # Will respond:
    # 
    # [source,xml]
    # ----
    # <networks>
    #   <network href="/ovirt-engine/api/networks/123" id="123">
    #     <name>ovirtmgmt</name>
    #     <description>Default Management Network</description>
    #     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
    #     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
    #     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
    #     <mtu>0</mtu>
    #     <stp>false</stp>
    #     <usages>
    #       <usage>vm</usage>
    #     </usages>
    #     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
    #   </network>
    #   ...
    # </networks>
    # ----
    # 
    # The order of the returned list of networks is guaranteed only if the `sortby` clause is included in the
    # `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of networks to return. If not specified all the networks are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned networks.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Network>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific network.
    # 
    # @param id [String] The identifier of the `network`.
    # 
    # @return [NetworkService] A reference to the `network` service.
    # 
    def network_service(id)
      NetworkService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return network_service(path)
      end
      return network_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class NicNetworkFilterParameterService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves a representation of the network filter parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkFilterParameter]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the filter parameter.
    # 
    # For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
    # send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the network filter parameter.
    # 
    # For example, to update the network filter parameter having with with id `123` on NIC `456` of
    # virtual machine `789` send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <network_filter_parameter>
    #   <name>updatedName</name>
    #   <value>updatedValue</value>
    # </network_filter_parameter>
    # ----
    # 
    # @param parameter [NetworkFilterParameter] The network filter parameter that is being updated.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkFilterParameter]
    # 
    def update(parameter, opts = {})
      internal_update(parameter, NetworkFilterParameter, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class NicNetworkFilterParametersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a network filter parameter.
    # 
    # For example, to add the parameter for the network filter on NIC `456` of
    # virtual machine `789` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <network_filter_parameter>
    #   <name>IP</name>
    #   <value>10.0.1.2</value>
    # </network_filter_parameter>
    # ----
    # 
    # @param parameter [NetworkFilterParameter] The network filter parameter that is being added.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NetworkFilterParameter]
    # 
    def add(parameter, opts = {})
      internal_add(parameter, NetworkFilterParameter, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the representations of the network filter parameters.
    # 
    # The order of the returned list of network filters isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<NetworkFilterParameter>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific network filter parameter.
    # 
    # @param id [String] The identifier of the `parameter`.
    # 
    # @return [NicNetworkFilterParameterService] A reference to the `parameter` service.
    # 
    def parameter_service(id)
      NicNetworkFilterParameterService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return parameter_service(path)
      end
      return parameter_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackImageService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackImage]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT = [
      [:async, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:disk, Disk].freeze,
      [:import_as_template, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
      [:template, Template].freeze,
    ].freeze
    
    private_constant :IMPORT
    
    # 
    # Imports a virtual machine from a Glance image storage domain.
    # 
    # For example, to import the image with identifier `456` from the
    # storage domain with identifier `123` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain>
    #     <name>images0</name>
    #   </storage_domain>
    #   <cluster>
    #     <name>images0</name>
    #   </cluster>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the import should be performed asynchronously.
    # 
    # @option opts [Cluster] :cluster This parameter is mandatory in case of using `import_as_template` and indicates which cluster should be used
    #   for import glance image as template.
    # 
    # @option opts [Disk] :disk 
    # 
    # @option opts [Boolean] :import_as_template Indicates whether the image should be imported as a template.
    # 
    # @option opts [StorageDomain] :storage_domain 
    # 
    # @option opts [Template] :template 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import(opts = {})
      internal_action(:import, nil, IMPORT, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackImageProviderService < ExternalProviderService
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackImageProvider]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT_CERTIFICATES = [
      [:certificates, List].freeze,
    ].freeze
    
    private_constant :IMPORT_CERTIFICATES
    
    # 
    # Import the SSL certificates of the external host provider.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Array<Certificate>] :certificates 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import_certificates(opts = {})
      internal_action(:importcertificates, nil, IMPORT_CERTIFICATES, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    TEST_CONNECTIVITY = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :TEST_CONNECTIVITY
    
    # 
    # In order to test connectivity for external provider we need
    # to run following request where 123 is an id of a provider.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the test should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def test_connectivity(opts = {})
      internal_action(:testconnectivity, nil, TEST_CONNECTIVITY, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified OpenStack image provider in the system.
    # 
    # @param provider [OpenStackImageProvider] The `provider` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackImageProvider]
    # 
    def update(provider, opts = {})
      internal_update(provider, OpenStackImageProvider, UPDATE, opts)
    end
    
    # 
    # A service to view certificates for this external provider.
    # 
    # @return [ExternalProviderCertificatesService] A reference to `certificates` service.
    # 
    def certificates_service
      @certificates_service ||= ExternalProviderCertificatesService.new(self, 'certificates')
    end
    
    # 
    # Locates the `images` service.
    # 
    # @return [OpenstackImagesService] A reference to `images` service.
    # 
    def images_service
      @images_service ||= OpenstackImagesService.new(self, 'images')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'certificates'
        return certificates_service
      end
      if path.start_with?('certificates/')
        return certificates_service.service(path[13..-1])
      end
      if path == 'images'
        return images_service
      end
      if path.start_with?('images/')
        return images_service.service(path[7..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackImageProvidersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new OpenStack image provider to the system.
    # 
    # @param provider [OpenStackImageProvider] The `provider` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackImageProvider]
    # 
    def add(provider, opts = {})
      internal_add(provider, OpenStackImageProvider, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of providers.
    # 
    # The order of the returned list of providers isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of providers to return. If not specified all the providers are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned OpenStack image providers.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenStackImageProvider>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `provider` service.
    # 
    # @param id [String] The identifier of the `provider`.
    # 
    # @return [OpenstackImageProviderService] A reference to the `provider` service.
    # 
    def provider_service(id)
      OpenstackImageProviderService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return provider_service(path)
      end
      return provider_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackImagesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists the images of a Glance image storage domain.
    # 
    # The order of the returned list of images isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of images to return. If not specified all the images are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenStackImage>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific image.
    # 
    # @param id [String] The identifier of the `image`.
    # 
    # @return [OpenstackImageService] A reference to the `image` service.
    # 
    def image_service(id)
      OpenstackImageService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return image_service(path)
      end
      return image_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackNetworkService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackNetwork]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT = [
      [:async, TrueClass].freeze,
      [:data_center, DataCenter].freeze,
    ].freeze
    
    private_constant :IMPORT
    
    # 
    # This operation imports an external network into {product-name}.
    # The network will be added to the specified data center.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the import should be performed asynchronously.
    # 
    # @option opts [DataCenter] :data_center The data center into which the network is to be imported.
    #   Data center is mandatory, and can be specified
    #   using the `id` or `name` attributes. The rest of
    #   the attributes will be ignored.
    #   
    #   NOTE: If <<types/open_stack_network_provider/attributes/auto_sync,`auto_sync`>> is
    #   enabled for the provider, the network might be imported automatically. To
    #   prevent this, automatic import can be disabled by setting the `auto_sync` to false,
    #   and enabling it again after importing the network.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import(opts = {})
      internal_action(:import, nil, IMPORT, opts)
    end
    
    # 
    # Locates the `subnets` service.
    # 
    # @return [OpenstackSubnetsService] A reference to `subnets` service.
    # 
    def subnets_service
      @subnets_service ||= OpenstackSubnetsService.new(self, 'subnets')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'subnets'
        return subnets_service
      end
      if path.start_with?('subnets/')
        return subnets_service.service(path[8..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackNetworkProviderService < ExternalProviderService
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/openstacknetworkproviders/1234
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackNetworkProvider]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT_CERTIFICATES = [
      [:certificates, List].freeze,
    ].freeze
    
    private_constant :IMPORT_CERTIFICATES
    
    # 
    # Import the SSL certificates of the external host provider.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Array<Certificate>] :certificates 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import_certificates(opts = {})
      internal_action(:importcertificates, nil, IMPORT_CERTIFICATES, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the provider.
    # 
    # For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/openstacknetworkproviders/1234
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    TEST_CONNECTIVITY = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :TEST_CONNECTIVITY
    
    # 
    # In order to test connectivity for external provider we need
    # to run following request where 123 is an id of a provider.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the test should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def test_connectivity(opts = {})
      internal_action(:testconnectivity, nil, TEST_CONNECTIVITY, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the provider.
    # 
    # For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
    # for the OpenStack network provider with identifier `1234`, send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/openstacknetworkproviders/1234
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <openstack_network_provider>
    #   <name>ovn-network-provider</name>
    #   <requires_authentication>false</requires_authentication>
    #   <url>http://some_server_url.domain.com:9696</url>
    #   <tenant_name>oVirt</tenant_name>
    #   <type>external</type>
    # </openstack_network_provider>
    # ----
    # 
    # @param provider [OpenStackNetworkProvider] The provider to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackNetworkProvider]
    # 
    def update(provider, opts = {})
      internal_update(provider, OpenStackNetworkProvider, UPDATE, opts)
    end
    
    # 
    # A service to view certificates for this external provider.
    # 
    # @return [ExternalProviderCertificatesService] A reference to `certificates` service.
    # 
    def certificates_service
      @certificates_service ||= ExternalProviderCertificatesService.new(self, 'certificates')
    end
    
    # 
    # Reference to OpenStack networks service.
    # 
    # @return [OpenstackNetworksService] A reference to `networks` service.
    # 
    def networks_service
      @networks_service ||= OpenstackNetworksService.new(self, 'networks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'certificates'
        return certificates_service
      end
      if path.start_with?('certificates/')
        return certificates_service.service(path[13..-1])
      end
      if path == 'networks'
        return networks_service
      end
      if path.start_with?('networks/')
        return networks_service.service(path[9..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackNetworkProvidersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # The operation adds a new network provider to the system.
    # If the `type` property is not present, a default value of `NEUTRON` will be used.
    # 
    # @param provider [OpenStackNetworkProvider] The `provider` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackNetworkProvider]
    # 
    def add(provider, opts = {})
      internal_add(provider, OpenStackNetworkProvider, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of providers.
    # 
    # The order of the returned list of providers isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of providers to return. If not specified all the providers are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned OpenStack network providers.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenStackNetworkProvider>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to OpenStack network provider service.
    # 
    # @param id [String] The identifier of the `provider`.
    # 
    # @return [OpenstackNetworkProviderService] A reference to the `provider` service.
    # 
    def provider_service(id)
      OpenstackNetworkProviderService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return provider_service(path)
      end
      return provider_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackNetworksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of networks.
    # 
    # The order of the returned list of networks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of networks to return. If not specified all the networks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenStackNetwork>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `network` service.
    # 
    # @param id [String] The identifier of the `network`.
    # 
    # @return [OpenstackNetworkService] A reference to the `network` service.
    # 
    def network_service(id)
      OpenstackNetworkService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return network_service(path)
      end
      return network_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackSubnetService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackSubnet]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackSubnetsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new `subnet`.
    # 
    # @param subnet [OpenStackSubnet] The `subnet` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackSubnet]
    # 
    def add(subnet, opts = {})
      internal_add(subnet, OpenStackSubnet, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of sub-networks.
    # 
    # The order of the returned list of sub-networks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of sub-networks to return. If not specified all the sub-networks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenStackSubnet>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `subnet` service.
    # 
    # @param id [String] The identifier of the `subnet`.
    # 
    # @return [OpenstackSubnetService] A reference to the `subnet` service.
    # 
    def subnet_service(id)
      OpenstackSubnetService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return subnet_service(path)
      end
      return subnet_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackVolumeAuthenticationKeyService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenstackVolumeAuthenticationKey]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified authentication key.
    # 
    # @param key [OpenstackVolumeAuthenticationKey] The `key` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenstackVolumeAuthenticationKey]
    # 
    def update(key, opts = {})
      internal_update(key, OpenstackVolumeAuthenticationKey, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackVolumeAuthenticationKeysService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new authentication key to the OpenStack volume provider.
    # 
    # @param key [OpenstackVolumeAuthenticationKey] The `key` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenstackVolumeAuthenticationKey]
    # 
    def add(key, opts = {})
      internal_add(key, OpenstackVolumeAuthenticationKey, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of authentication keys.
    # 
    # The order of the returned list of authentication keys isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of keys to return. If not specified all the keys are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenstackVolumeAuthenticationKey>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `key` service.
    # 
    # @param id [String] The identifier of the `key`.
    # 
    # @return [OpenstackVolumeAuthenticationKeyService] A reference to the `key` service.
    # 
    def key_service(id)
      OpenstackVolumeAuthenticationKeyService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return key_service(path)
      end
      return key_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackVolumeProviderService < ExternalProviderService
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackVolumeProvider]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT_CERTIFICATES = [
      [:certificates, List].freeze,
    ].freeze
    
    private_constant :IMPORT_CERTIFICATES
    
    # 
    # Import the SSL certificates of the external host provider.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Array<Certificate>] :certificates 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import_certificates(opts = {})
      internal_action(:importcertificates, nil, IMPORT_CERTIFICATES, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Boolean] :force Indicates if the operation should succeed, and the provider removed from the database,
    #   even if something fails during the operation.
    #   
    #   This parameter is optional, and the default value is `false`.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    TEST_CONNECTIVITY = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :TEST_CONNECTIVITY
    
    # 
    # In order to test connectivity for external provider we need
    # to run following request where 123 is an id of a provider.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the test should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def test_connectivity(opts = {})
      internal_action(:testconnectivity, nil, TEST_CONNECTIVITY, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified OpenStack volume provider in the system.
    # 
    # @param provider [OpenStackVolumeProvider] The `provider` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackVolumeProvider]
    # 
    def update(provider, opts = {})
      internal_update(provider, OpenStackVolumeProvider, UPDATE, opts)
    end
    
    # 
    # Locates the `authentication_keys` service.
    # 
    # @return [OpenstackVolumeAuthenticationKeysService] A reference to `authentication_keys` service.
    # 
    def authentication_keys_service
      @authentication_keys_service ||= OpenstackVolumeAuthenticationKeysService.new(self, 'authenticationkeys')
    end
    
    # 
    # A service to view certificates for this external provider.
    # 
    # @return [ExternalProviderCertificatesService] A reference to `certificates` service.
    # 
    def certificates_service
      @certificates_service ||= ExternalProviderCertificatesService.new(self, 'certificates')
    end
    
    # 
    # Locates the `volume_types` service.
    # 
    # @return [OpenstackVolumeTypesService] A reference to `volume_types` service.
    # 
    def volume_types_service
      @volume_types_service ||= OpenstackVolumeTypesService.new(self, 'volumetypes')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'authenticationkeys'
        return authentication_keys_service
      end
      if path.start_with?('authenticationkeys/')
        return authentication_keys_service.service(path[19..-1])
      end
      if path == 'certificates'
        return certificates_service
      end
      if path.start_with?('certificates/')
        return certificates_service.service(path[13..-1])
      end
      if path == 'volumetypes'
        return volume_types_service
      end
      if path.start_with?('volumetypes/')
        return volume_types_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackVolumeProvidersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new volume provider.
    # 
    # For example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/openstackvolumeproviders
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <openstack_volume_provider>
    #   <name>mycinder</name>
    #   <url>https://mycinder.example.com:8776</url>
    #   <data_center>
    #     <name>mydc</name>
    #   </data_center>
    #   <requires_authentication>true</requires_authentication>
    #   <username>admin</username>
    #   <password>mypassword</password>
    #   <tenant_name>mytenant</tenant_name>
    # </openstack_volume_provider>
    # ----
    # 
    # @param provider [OpenStackVolumeProvider] The `provider` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackVolumeProvider]
    # 
    def add(provider, opts = {})
      internal_add(provider, OpenStackVolumeProvider, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the list of volume providers.
    # 
    # The order of the returned list of volume providers isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of providers to return. If not specified all the providers are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned volume providers.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenStackVolumeProvider>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `provider` service.
    # 
    # @param id [String] The identifier of the `provider`.
    # 
    # @return [OpenstackVolumeProviderService] A reference to the `provider` service.
    # 
    def provider_service(id)
      OpenstackVolumeProviderService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return provider_service(path)
      end
      return provider_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OpenstackVolumeTypeService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OpenStackVolumeType]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OpenstackVolumeTypesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of volume types.
    # 
    # The order of the returned list of volume types isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of volume types to return. If not specified all the volume types are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OpenStackVolumeType>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `type` service.
    # 
    # @param id [String] The identifier of the `type`.
    # 
    # @return [OpenstackVolumeTypeService] A reference to the `type` service.
    # 
    def type_service(id)
      OpenstackVolumeTypeService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return type_service(path)
      end
      return type_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class OperatingSystemService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [OperatingSystemInfo]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class OperatingSystemsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of types of operating system available in the system.
    # 
    # The order of the returned list of operating systems isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of networks to return. If not specified all the networks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<OperatingSystemInfo>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `operating_system` service.
    # 
    # @param id [String] The identifier of the `operating_system`.
    # 
    # @return [OperatingSystemService] A reference to the `operating_system` service.
    # 
    def operating_system_service(id)
      OperatingSystemService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return operating_system_service(path)
      end
      return operating_system_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class PermissionService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class PermitService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the information about the permit of the role.
    # 
    # For example to retrieve the information about the permit with the id `456` of the role with the id `123`
    # send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/roles/123/permits/456
    # ....
    # 
    # [source,xml]
    # ----
    # <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
    #   <name>change_vm_cd</name>
    #   <administrative>false</administrative>
    #   <role href="/ovirt-engine/api/roles/123" id="123"/>
    # </permit>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permit]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the permit from the role.
    # 
    # For example to remove the permit with id `456` from the role with id `123` send a request like this:
    # 
    # ....
    # DELETE /ovirt-engine/api/roles/123/permits/456
    # ....
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class PermitsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
    # 
    # For example to assign a permit `create_vm` to the role with id `123` send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/roles/123/permits
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <permit>
    #   <name>create_vm</name>
    # </permit>
    # ----
    # 
    # @param permit [Permit] The permit to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permit]
    # 
    def add(permit, opts = {})
      internal_add(permit, Permit, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the permits of the role.
    # 
    # For example to list the permits of the role with the id `123` send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/roles/123/permits
    # ....
    # 
    # [source,xml]
    # ----
    # <permits>
    #   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
    #     <name>change_vm_cd</name>
    #     <administrative>false</administrative>
    #     <role href="/ovirt-engine/api/roles/123" id="123"/>
    #   </permit>
    #   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
    #     <name>connect_to_vm</name>
    #     <administrative>false</administrative>
    #     <role href="/ovirt-engine/api/roles/123" id="123"/>
    #   </permit>
    # </permits>
    # ----
    # 
    # The order of the returned list of permits isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of permits to return. If not specified all the permits are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Permit>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Sub-resource locator method, returns individual permit resource on which the remainder of the URI is dispatched.
    # 
    # @param id [String] The identifier of the `permit`.
    # 
    # @return [PermitService] A reference to the `permit` service.
    # 
    def permit_service(id)
      PermitService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return permit_service(path)
      end
      return permit_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class QosService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get specified QoS in the data center.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/datacenters/123/qoss/123
    # ----
    # 
    # You will get response like this one below:
    # 
    # [source,xml]
    # ----
    # <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
    #   <name>123</name>
    #   <description>123</description>
    #   <max_iops>1</max_iops>
    #   <max_throughput>1</max_throughput>
    #   <type>storage</type>
    #   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
    # </qos>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Qos]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove specified QoS from datacenter.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/datacenters/123/qoss/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified QoS in the dataCenter.
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/datacenters/123/qoss/123
    # ----
    # 
    # For example with curl:
    # 
    # [source]
    # ----
    # curl -u admin@internal:123456 -X PUT -H "content-type: application/xml" -d \
    # "<qos><name>321</name><description>321</description><max_iops>10</max_iops></qos>" \
    # https://engine/ovirt-engine/api/datacenters/123/qoss/123
    # ----
    # 
    # You will receive response like this:
    # 
    # [source,xml]
    # ----
    # <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
    #   <name>321</name>
    #   <description>321</description>
    #   <max_iops>10</max_iops>
    #   <max_throughput>1</max_throughput>
    #   <type>storage</type>
    #   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
    # </qos>
    # ----
    # 
    # @param qos [Qos] Updated QoS object.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Qos]
    # 
    def update(qos, opts = {})
      internal_update(qos, Qos, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class QossService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new QoS to the dataCenter.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/qoss
    # ----
    # 
    # The response will look as follows:
    # 
    # [source,xml]
    # ----
    # <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
    #   <name>123</name>
    #   <description>123</description>
    #   <max_iops>10</max_iops>
    #   <type>storage</type>
    #   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
    # </qos>
    # ----
    # 
    # @param qos [Qos] Added QoS object.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Qos]
    # 
    def add(qos, opts = {})
      internal_add(qos, Qos, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of _quality of service_ configurations available in the data center.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/datacenter/123/qoss
    # ----
    # 
    # You will get response which will look like this:
    # 
    # [source, xml]
    # ----
    # <qoss>
    #   <qos href="/ovirt-engine/api/datacenters/123/qoss/1" id="1">...</qos>
    #   <qos href="/ovirt-engine/api/datacenters/123/qoss/2" id="2">...</qos>
    #   <qos href="/ovirt-engine/api/datacenters/123/qoss/3" id="3">...</qos>
    # </qoss>
    # ----
    # 
    # The returned list of quality of service configurations isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of QoS descriptors to return. If not specified all the descriptors are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Qos>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A reference to a service managing a specific QoS.
    # 
    # @param id [String] The identifier of the `qos`.
    # 
    # @return [QosService] A reference to the `qos` service.
    # 
    def qos_service(id)
      QosService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return qos_service(path)
      end
      return qos_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class QuotaService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves a quota.
    # 
    # An example of retrieving a quota:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/datacenters/123/quotas/456
    # ----
    # 
    # [source,xml]
    # ----
    # <quota id="456">
    #   <name>myquota</name>
    #   <description>My new quota for virtual machines</description>
    #   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
    #   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
    #   <storage_hard_limit_pct>20</storage_hard_limit_pct>
    #   <storage_soft_limit_pct>80</storage_soft_limit_pct>
    # </quota>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Quota]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Delete a quota.
    # 
    # An example of deleting a quota:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
    # -0472718ab224 HTTP/1.1
    # Accept: application/xml
    # Content-type: application/xml
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates a quota.
    # 
    # An example of updating a quota:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/datacenters/123/quotas/456
    # ----
    # 
    # [source,xml]
    # ----
    # <quota>
    #   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
    #   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
    #   <storage_hard_limit_pct>20</storage_hard_limit_pct>
    #   <storage_soft_limit_pct>80</storage_soft_limit_pct>
    # </quota>
    # ----
    # 
    # @param quota [Quota] The `quota` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Quota]
    # 
    def update(quota, opts = {})
      internal_update(quota, Quota, UPDATE, opts)
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `quota_cluster_limits` service.
    # 
    # @return [QuotaClusterLimitsService] A reference to `quota_cluster_limits` service.
    # 
    def quota_cluster_limits_service
      @quota_cluster_limits_service ||= QuotaClusterLimitsService.new(self, 'quotaclusterlimits')
    end
    
    # 
    # Locates the `quota_storage_limits` service.
    # 
    # @return [QuotaStorageLimitsService] A reference to `quota_storage_limits` service.
    # 
    def quota_storage_limits_service
      @quota_storage_limits_service ||= QuotaStorageLimitsService.new(self, 'quotastoragelimits')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'quotaclusterlimits'
        return quota_cluster_limits_service
      end
      if path.start_with?('quotaclusterlimits/')
        return quota_cluster_limits_service.service(path[19..-1])
      end
      if path == 'quotastoragelimits'
        return quota_storage_limits_service
      end
      if path.start_with?('quotastoragelimits/')
        return quota_storage_limits_service.service(path[19..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class QuotaClusterLimitService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [QuotaClusterLimit]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class QuotaClusterLimitsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a cluster limit to a specified Quota.
    # 
    # @param limit [QuotaClusterLimit] The `limit` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [QuotaClusterLimit]
    # 
    def add(limit, opts = {})
      internal_add(limit, QuotaClusterLimit, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the set of quota limits configured for the cluster.
    # 
    # The returned list of quota limits isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of limits to return. If not specified all the limits are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<QuotaClusterLimit>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `limit` service.
    # 
    # @param id [String] The identifier of the `limit`.
    # 
    # @return [QuotaClusterLimitService] A reference to the `limit` service.
    # 
    def limit_service(id)
      QuotaClusterLimitService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return limit_service(path)
      end
      return limit_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class QuotaStorageLimitService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [QuotaStorageLimit]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class QuotaStorageLimitsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a storage limit to a specified quota.
    # 
    # To create a 100GiB storage limit for all storage domains in a data center, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <quota_storage_limit>
    #   <limit>100</limit>
    # </quota_storage_limit>
    # ----
    # 
    # To create a 50GiB storage limit for a storage domain with the ID `000`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <quota_storage_limit>
    #   <limit>50</limit>
    #   <storage_domain id="000"/>
    # </quota_storage_limit>
    # ----
    # 
    # @param limit [QuotaStorageLimit] The `limit` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [QuotaStorageLimit]
    # 
    def add(limit, opts = {})
      internal_add(limit, QuotaStorageLimit, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of storage limits configured for the quota.
    # 
    # The order of the returned list of storage limits is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of limits to return. If not specified, all the limits are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<QuotaStorageLimit>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `limit` service.
    # 
    # @param id [String] The identifier of the `limit`.
    # 
    # @return [QuotaStorageLimitService] A reference to the `limit` service.
    # 
    def limit_service(id)
      QuotaStorageLimitService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return limit_service(path)
      end
      return limit_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class QuotasService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new quota.
    # 
    # An example of creating a new quota:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/datacenters/123/quotas
    # ----
    # 
    # [source,xml]
    # ----
    # <quota>
    #   <name>myquota</name>
    #   <description>My new quota for virtual machines</description>
    # </quota>
    # ----
    # 
    # @param quota [Quota] The `quota` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Quota]
    # 
    def add(quota, opts = {})
      internal_add(quota, Quota, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists quotas of a data center.
    # 
    # The order of the returned list of quotas isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of quota descriptors to return. If not specified all the descriptors are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Quota>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `quota` service.
    # 
    # @param id [String] The identifier of the `quota`.
    # 
    # @return [QuotaService] A reference to the `quota` service.
    # 
    def quota_service(id)
      QuotaService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return quota_service(path)
      end
      return quota_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class RoleService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get the role.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/roles/123
    # ----
    # 
    # You will receive XML response like this one:
    # 
    # [source,xml]
    # ----
    # <role id="123">
    #   <name>MyRole</name>
    #   <description>MyRole description</description>
    #   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
    #   <administrative>true</administrative>
    #   <mutable>false</mutable>
    # </role>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Role]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the role.
    # 
    # To remove the role you need to know its id, then send request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/roles/{role_id}
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
    # created. Within this endpoint you can't add or remove roles permits you need to use
    # <<services/permits, service>> that manages permits of role.
    # 
    # For example to update role's `name`, `description` and `administrative` attributes send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/roles/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <role>
    #   <name>MyNewRoleName</name>
    #   <description>My new description of the role</description>
    #   <administrative>true</administrative>
    # </group>
    # ----
    # 
    # @param role [Role] Updated role.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Role]
    # 
    def update(role, opts = {})
      internal_update(role, Role, UPDATE, opts)
    end
    
    # 
    # Sub-resource locator method, returns permits service.
    # 
    # @return [PermitsService] A reference to `permits` service.
    # 
    def permits_service
      @permits_service ||= PermitsService.new(self, 'permits')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permits'
        return permits_service
      end
      if path.start_with?('permits/')
        return permits_service.service(path[8..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class RolesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Create a new role. The role can be administrative or non-administrative and can have different permits.
    # 
    # For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
    # send a request like this (note that you have to pass permit id):
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/roles
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <role>
    #   <name>MyRole</name>
    #   <description>My custom role to create virtual machines</description>
    #   <administrative>false</administrative>
    #   <permits>
    #     <permit id="1"/>
    #     <permit id="1300"/>
    #   </permits>
    # </group>
    # ----
    # 
    # @param role [Role] Role that will be added.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Role]
    # 
    def add(role, opts = {})
      internal_add(role, Role, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List roles.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/roles
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <roles>
    #   <role id="123">
    #      <name>SuperUser</name>
    #      <description>Roles management administrator</description>
    #      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
    #      <administrative>true</administrative>
    #      <mutable>false</mutable>
    #   </role>
    #   ...
    # </roles>
    # ----
    # 
    # The order of the returned list of roles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of roles to return. If not specified all the roles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Role>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
    # 
    # @param id [String] The identifier of the `role`.
    # 
    # @return [RoleService] A reference to the `role` service.
    # 
    def role_service(id)
      RoleService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return role_service(path)
      end
      return role_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SchedulingPoliciesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new scheduling policy to the system.
    # 
    # @param policy [SchedulingPolicy] The `policy` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SchedulingPolicy]
    # 
    def add(policy, opts = {})
      internal_add(policy, SchedulingPolicy, ADD, opts)
    end
    
    LIST = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of scheduling policies available in the system.
    # 
    # The order of the returned list of scheduling policies isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of policies to return. If not specified all the policies are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<SchedulingPolicy>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `policy` service.
    # 
    # @param id [String] The identifier of the `policy`.
    # 
    # @return [SchedulingPolicyService] A reference to the `policy` service.
    # 
    def policy_service(id)
      SchedulingPolicyService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return policy_service(path)
      end
      return policy_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SchedulingPolicyService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SchedulingPolicy]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified user defined scheduling policy in the system.
    # 
    # @param policy [SchedulingPolicy] The `policy` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SchedulingPolicy]
    # 
    def update(policy, opts = {})
      internal_update(policy, SchedulingPolicy, UPDATE, opts)
    end
    
    # 
    # Locates the `balances` service.
    # 
    # @return [BalancesService] A reference to `balances` service.
    # 
    def balances_service
      @balances_service ||= BalancesService.new(self, 'balances')
    end
    
    # 
    # Locates the `filters` service.
    # 
    # @return [FiltersService] A reference to `filters` service.
    # 
    def filters_service
      @filters_service ||= FiltersService.new(self, 'filters')
    end
    
    # 
    # Locates the `weights` service.
    # 
    # @return [WeightsService] A reference to `weights` service.
    # 
    def weights_service
      @weights_service ||= WeightsService.new(self, 'weights')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'balances'
        return balances_service
      end
      if path.start_with?('balances/')
        return balances_service.service(path[9..-1])
      end
      if path == 'filters'
        return filters_service
      end
      if path.start_with?('filters/')
        return filters_service.service(path[8..-1])
      end
      if path == 'weights'
        return weights_service
      end
      if path.start_with?('weights/')
        return weights_service.service(path[8..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SchedulingPolicyUnitService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SchedulingPolicyUnit]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SchedulingPolicyUnitsService < Service
    
    LIST = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of scheduling policy units available in the system.
    # 
    # The order of the returned list of scheduling policy units isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of policy units to return. If not specified all the policy units are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<SchedulingPolicyUnit>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `unit` service.
    # 
    # @param id [String] The identifier of the `unit`.
    # 
    # @return [SchedulingPolicyUnitService] A reference to the `unit` service.
    # 
    def unit_service(id)
      SchedulingPolicyUnitService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return unit_service(path)
      end
      return unit_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SnapshotService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Snapshot]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:all_content, TrueClass].freeze,
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all the attributes of the virtual machine snapshot should be included in the response.
    #   
    #   By default the attribute `initialization.configuration.data` is excluded.
    #   
    #   For example, to retrieve the complete representation of the snapshot with id `456` of the virtual machine
    #   with id `123` send a request like this:
    #   
    #   ....
    #   GET /ovirt-engine/api/vms/123/snapshots/456?all_content=true
    #   ....
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    RESTORE = [
      [:async, TrueClass].freeze,
      [:disks, List].freeze,
      [:restore_memory, TrueClass].freeze,
    ].freeze
    
    private_constant :RESTORE
    
    # 
    # Restores a virtual machine snapshot.
    # 
    # For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
    # request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/snapshots/456/restore
    # ----
    # 
    # With an empty `action` in the body:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # NOTE: Confirm that the commit operation is finished and the virtual machine is down before running the virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the restore should be performed asynchronously.
    # 
    # @option opts [Array<Disk>] :disks Specify the disks included in the snapshot's restore.
    #   
    #   For each disk parameter, it is also required to specify its `image_id`.
    #   
    #   For example, to restore a snapshot with an identifier `456` of a virtual machine with identifier `123`, including
    #   a disk with identifier `111` and `image_id` of `222`, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/vms/123/snapshots/456/restore
    #   ----
    #   
    #   Request body:
    #   
    #   [source,xml]
    #   ----
    #   <action>
    #     <disks>
    #       <disk id="111">
    #         <image_id>222</image_id>
    #       </disk>
    #     </disks>
    #   </action>
    #   ----
    # 
    # @option opts [Boolean] :restore_memory 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def restore(opts = {})
      internal_action(:restore, nil, RESTORE, opts)
    end
    
    # 
    # Locates the `cdroms` service.
    # 
    # @return [SnapshotCdromsService] A reference to `cdroms` service.
    # 
    def cdroms_service
      @cdroms_service ||= SnapshotCdromsService.new(self, 'cdroms')
    end
    
    # 
    # Locates the `disks` service.
    # 
    # @return [SnapshotDisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= SnapshotDisksService.new(self, 'disks')
    end
    
    # 
    # Locates the `nics` service.
    # 
    # @return [SnapshotNicsService] A reference to `nics` service.
    # 
    def nics_service
      @nics_service ||= SnapshotNicsService.new(self, 'nics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'cdroms'
        return cdroms_service
      end
      if path.start_with?('cdroms/')
        return cdroms_service.service(path[7..-1])
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      if path == 'nics'
        return nics_service
      end
      if path.start_with?('nics/')
        return nics_service.service(path[5..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SnapshotCdromService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cdrom]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SnapshotCdromsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of CD-ROM devices of the snapshot.
    # 
    # The order of the returned list of CD-ROM devices isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of CDROMS to return. If not specified all the CDROMS are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Cdrom>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `cdrom` service.
    # 
    # @param id [String] The identifier of the `cdrom`.
    # 
    # @return [SnapshotCdromService] A reference to the `cdrom` service.
    # 
    def cdrom_service(id)
      SnapshotCdromService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return cdrom_service(path)
      end
      return cdrom_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SnapshotDiskService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SnapshotDisksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disks of the snapshot.
    # 
    # The order of the returned list of disks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified all the disks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `disk` service.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [SnapshotDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      SnapshotDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SnapshotNicService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SnapshotNicsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of NICs of the snapshot.
    # 
    # The order of the returned list of NICs isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of NICs to return. If not specified all the NICs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Nic>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `nic` service.
    # 
    # @param id [String] The identifier of the `nic`.
    # 
    # @return [SnapshotNicService] A reference to the `nic` service.
    # 
    def nic_service(id)
      SnapshotNicService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return nic_service(path)
      end
      return nic_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SnapshotsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a virtual machine snapshot.
    # 
    # For example, to create a new snapshot for virtual machine `123` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/snapshots
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <snapshot>
    #   <description>My snapshot</description>
    # </snapshot>
    # ----
    # 
    # For including only a sub-set of disks in the snapshots, add `disk_attachments` element to the
    # request body. Note that disks which are not specified in `disk_attachments` element will not be a
    # part of the snapshot. If an empty `disk_attachments` element is passed, the snapshot will include
    # only the virtual machine configuration. If no `disk_attachments` element is passed, then all
    # the disks will be included in the snapshot.
    # 
    # For each disk, `image_id` element can be specified for setting the new active image id.
    # This is used in order to restore a chain of images from backup. I.e. when restoring
    # a disk with snapshots, the relevant `image_id` should be specified for each snapshot
    # (so the identifiers of the disk snapshots are identical to the backup).
    # 
    # [source,xml]
    # ----
    # <snapshot>
    #   <description>My snapshot</description>
    #   <disk_attachments>
    #     <disk_attachment>
    #       <disk id="123">
    #         <image_id>456</image_id>
    #       </disk>
    #     </disk_attachment>
    #   </disk_attachments>
    # </snapshot>
    # ----
    # 
    # [IMPORTANT]
    # ====
    # When a snapshot is created the default value for the <<types/snapshot/attributes/persist_memorystate,
    # persist_memorystate>> attribute is `true`. That means that the content of the memory of the virtual
    # machine will be included in the snapshot, and it also means that the virtual machine will be paused
    # for a longer time. That can negatively affect applications that are very sensitive to timing (NTP
    # servers, for example). In those cases make sure that you set the attribute to `false`:
    # 
    # [source,xml]
    # ----
    # <snapshot>
    #   <description>My snapshot</description>
    #   <persist_memorystate>false</persist_memorystate>
    # </snapshot>
    # ----
    # ====
    # 
    # @param snapshot [Snapshot] The `snapshot` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Snapshot]
    # 
    def add(snapshot, opts = {})
      internal_add(snapshot, Snapshot, ADD, opts)
    end
    
    LIST = [
      [:all_content, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of snapshots of the storage domain or virtual machine.
    # 
    # The order of the returned list of snapshots isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all the attributes of the virtual machine snapshot should be included in the response.
    #   
    #   By default the attribute `initialization.configuration.data` is excluded.
    #   
    #   For example, to retrieve the complete representation of the virtual machine with id `123` snapshots send a
    #   request like this:
    #   
    #   ....
    #   GET /ovirt-engine/api/vms/123/snapshots?all_content=true
    #   ....
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of snapshots to return. If not specified all the snapshots are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Snapshot>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `snapshot` service.
    # 
    # @param id [String] The identifier of the `snapshot`.
    # 
    # @return [SnapshotService] A reference to the `snapshot` service.
    # 
    def snapshot_service(id)
      SnapshotService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return snapshot_service(path)
      end
      return snapshot_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SshPublicKeyService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SshPublicKey]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the `key`.
    # 
    # @param key [SshPublicKey] The `key` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SshPublicKey]
    # 
    def update(key, opts = {})
      internal_update(key, SshPublicKey, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SshPublicKeysService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new `key`.
    # 
    # @param key [SshPublicKey] The `key` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SshPublicKey]
    # 
    def add(key, opts = {})
      internal_add(key, SshPublicKey, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns a list of SSH public keys of the user.
    # 
    # For example, to retrieve the list of SSH keys of user with identifier `123`,
    # send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/users/123/sshpublickeys
    # ----
    # 
    # The result will be the following XML document:
    # 
    # [source,xml]
    # ----
    # <ssh_public_keys>
    #   <ssh_public_key href="/ovirt-engine/api/users/123/sshpublickeys/456" id="456">
    #     <content>ssh-rsa ...</content>
    #     <user href="/ovirt-engine/api/users/123" id="123"/>
    #   </ssh_public_key>
    # </ssh_public_keys>
    # ----
    # 
    # Or the following JSON object
    # 
    # [source,json]
    # ----
    # {
    #   "ssh_public_key": [
    #     {
    #       "content": "ssh-rsa ...",
    #       "user": {
    #         "href": "/ovirt-engine/api/users/123",
    #         "id": "123"
    #       },
    #       "href": "/ovirt-engine/api/users/123/sshpublickeys/456",
    #       "id": "456"
    #     }
    #   ]
    # }
    # ----
    # 
    # The order of the returned list of keys is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of keys to return. If not specified all the keys are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<SshPublicKey>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `key` service.
    # 
    # @param id [String] The identifier of the `key`.
    # 
    # @return [SshPublicKeyService] A reference to the `key` service.
    # 
    def key_service(id)
      SshPublicKeyService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return key_service(path)
      end
      return key_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StatisticService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Statistic]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StatisticsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves a list of statistics.
    # 
    # For example, to retrieve the statistics for virtual machine `123` send a
    # request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/vms/123/statistics
    # ----
    # 
    # The result will be like this:
    # 
    # [source,xml]
    # ----
    # <statistics>
    #   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
    #     <name>memory.installed</name>
    #     <description>Total memory configured</description>
    #     <kind>gauge</kind>
    #     <type>integer</type>
    #     <unit>bytes</unit>
    #     <values>
    #       <value>
    #         <datum>1073741824</datum>
    #       </value>
    #     </values>
    #     <vm href="/ovirt-engine/api/vms/123" id="123"/>
    #   </statistic>
    #   ...
    # </statistics>
    # ----
    # 
    # Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/vms/123/statistics/456
    # ----
    # 
    # Outputs:
    # 
    # [source,xml]
    # ----
    # <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
    #   <name>memory.installed</name>
    #   <description>Total memory configured</description>
    #   <kind>gauge</kind>
    #   <type>integer</type>
    #   <unit>bytes</unit>
    #   <values>
    #     <value>
    #       <datum>1073741824</datum>
    #     </value>
    #   </values>
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    # </statistic>
    # ----
    # 
    # The order of the returned list of statistics isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of statistics to return. If not specified all the statistics are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Statistic>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `statistic` service.
    # 
    # @param id [String] The identifier of the `statistic`.
    # 
    # @return [StatisticService] A reference to the `statistic` service.
    # 
    def statistic_service(id)
      StatisticService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return statistic_service(path)
      end
      return statistic_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StepService < MeasurableService
    
    END_ = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
      [:succeeded, TrueClass].freeze,
    ].freeze
    
    private_constant :END_
    
    # 
    # Marks an external step execution as ended.
    # 
    # For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
    # following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/jobs/123/steps/456/end
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <force>true</force>
    #   <succeeded>true</succeeded>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the step should be forcibly terminated.
    # 
    # @option opts [Boolean] :succeeded Indicates if the step should be marked as successfully finished or as failed.
    #   
    #   This parameter is optional, and the default value is `true`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def end_(opts = {})
      internal_action(:end, nil, END_, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves a step.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/jobs/123/steps/456
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
    #   <actions>
    #     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
    #   </actions>
    #   <description>Validating</description>
    #   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
    #   <external>false</external>
    #   <number>0</number>
    #   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
    #   <status>finished</status>
    #   <type>validating</type>
    #   <job href="/ovirt-engine/api/jobs/123" id="123"/>
    # </step>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Step]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StepsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add an external step to an existing job or to an existing step.
    # 
    # For example, to add a step to `job` with identifier `123` send the
    # following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/jobs/123/steps
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <step>
    #   <description>Validating</description>
    #   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
    #   <status>started</status>
    #   <type>validating</type>
    # </step>
    # ----
    # 
    # The response should look like:
    # 
    # [source,xml]
    # ----
    # <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
    #   <actions>
    #     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
    #   </actions>
    #   <description>Validating</description>
    #   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
    #   <external>true</external>
    #   <number>2</number>
    #   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
    #   <status>started</status>
    #   <type>validating</type>
    #   <job href="/ovirt-engine/api/jobs/123" id="123"/>
    # </step>
    # ----
    # 
    # @param step [Step] Step that will be added.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Step]
    # 
    def add(step, opts = {})
      internal_add(step, Step, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the representation of the steps.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/job/123/steps
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <steps>
    #   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
    #     <actions>
    #       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
    #     </actions>
    #     <description>Validating</description>
    #     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
    #     <external>true</external>
    #     <number>2</number>
    #     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
    #     <status>started</status>
    #     <type>validating</type>
    #     <job href="/ovirt-engine/api/jobs/123" id="123"/>
    #   </step>
    #   ...
    # </steps>
    # ----
    # 
    # The order of the returned list of steps isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of steps to return. If not specified all the steps are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Step>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the step service.
    # 
    # @param id [String] The identifier of the `step`.
    # 
    # @return [StepService] A reference to the `step` service.
    # 
    def step_service(id)
      StepService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return step_service(path)
      end
      return step_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageService < Service
    
    GET = [
      [:follow, String].freeze,
      [:report_status, TrueClass].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Boolean] :report_status Indicates if the status of the LUNs in the storage should be checked.
    #   Checking the status of the LUN is an heavy weight operation and
    #   this data is not always needed by the user.
    #   This parameter will give the option to not perform the status check of the LUNs.
    #   
    #   The default is `true` for backward compatibility.
    #   
    #   Here an example with the LUN status :
    #   
    #   [source,xml]
    #   ----
    #   <host_storage id="360014051136c20574f743bdbd28177fd">
    #     <logical_units>
    #       <logical_unit id="360014051136c20574f743bdbd28177fd">
    #         <lun_mapping>0</lun_mapping>
    #         <paths>1</paths>
    #         <product_id>lun0</product_id>
    #         <serial>SLIO-ORG_lun0_1136c205-74f7-43bd-bd28-177fd5ce6993</serial>
    #         <size>10737418240</size>
    #         <status>used</status>
    #         <vendor_id>LIO-ORG</vendor_id>
    #         <volume_group_id>O9Du7I-RahN-ECe1-dZ1w-nh0b-64io-MNzIBZ</volume_group_id>
    #       </logical_unit>
    #     </logical_units>
    #     <type>iscsi</type>
    #     <host id="8bb5ade5-e988-4000-8b93-dbfc6717fe50"/>
    #   </host_storage>
    #   ----
    #   
    #   Here an example without the LUN status :
    #   
    #   [source,xml]
    #   ----
    #   <host_storage id="360014051136c20574f743bdbd28177fd">
    #     <logical_units>
    #       <logical_unit id="360014051136c20574f743bdbd28177fd">
    #         <lun_mapping>0</lun_mapping>
    #         <paths>1</paths>
    #         <product_id>lun0</product_id>
    #         <serial>SLIO-ORG_lun0_1136c205-74f7-43bd-bd28-177fd5ce6993</serial>
    #         <size>10737418240</size>
    #         <vendor_id>LIO-ORG</vendor_id>
    #         <volume_group_id>O9Du7I-RahN-ECe1-dZ1w-nh0b-64io-MNzIBZ</volume_group_id>
    #       </logical_unit>
    #     </logical_units>
    #     <type>iscsi</type>
    #     <host id="8bb5ade5-e988-4000-8b93-dbfc6717fe50"/>
    #   </host_storage>
    #   ----
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [HostStorage]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the description of the storage domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IS_ATTACHED = [
      [:async, TrueClass].freeze,
      [:host, Host].freeze,
    ].freeze
    
    private_constant :IS_ATTACHED
    
    # 
    # Used for querying if the storage domain is already attached to a data center using
    # the is_attached boolean field, which is part of the storage server. IMPORTANT:
    # Executing this API will cause the host to disconnect from the storage domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Host] :host Indicates the data center's host.
    # 
    # @option opts [Boolean] :is_attached Indicates whether the storage domain is attached to the data center.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def is_attached(opts = {})
      internal_action(:isattached, :is_attached, IS_ATTACHED, opts)
    end
    
    REDUCE_LUNS = [
      [:logical_units, List].freeze,
    ].freeze
    
    private_constant :REDUCE_LUNS
    
    # 
    # This operation reduces logical units from the storage domain.
    # 
    # In order to do so the data stored on the provided logical units will be moved to other logical units of the
    # storage domain and only then they will be reduced from the storage domain.
    # 
    # For example, in order to reduce two logical units from a storage domain send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/storageDomains/123/reduceluns
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    #  <action>
    #    <logical_units>
    #      <logical_unit id="1IET_00010001"/>
    #      <logical_unit id="1IET_00010002"/>
    #    </logical_units>
    #  </action>
    # ----
    # 
    #  Note that this operation is only applicable to block storage domains (i.e., storage domains with the
    #  <<types/storage_type, storage type> of iSCSI or FCP).
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Array<LogicalUnit>] :logical_units The logical units that need to be reduced from the storage domain.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reduce_luns(opts = {})
      internal_action(:reduceluns, nil, REDUCE_LUNS, opts)
    end
    
    REFRESH_LUNS = [
      [:async, TrueClass].freeze,
      [:logical_units, List].freeze,
    ].freeze
    
    private_constant :REFRESH_LUNS
    
    # 
    # This operation refreshes the LUN size.
    # 
    # After increasing the size of the underlying LUN on the storage server,
    # the user can refresh the LUN size.
    # This action forces a rescan of the provided LUNs and
    # updates the database with the new size, if required.
    # 
    # For example, in order to refresh the size of two LUNs send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/storageDomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    #  <action>
    #    <logical_units>
    #      <logical_unit id="1IET_00010001"/>
    #      <logical_unit id="1IET_00010002"/>
    #    </logical_units>
    #  </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the refresh should be performed asynchronously.
    # 
    # @option opts [Array<LogicalUnit>] :logical_units The LUNs that need to be refreshed.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def refresh_luns(opts = {})
      internal_action(:refreshluns, nil, REFRESH_LUNS, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
      [:destroy, TrueClass].freeze,
      [:format, TrueClass].freeze,
      [:host, String].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the storage domain.
    # 
    # Without any special parameters, the storage domain is detached from the system and removed from the database. The
    # storage domain can then be imported to the same or to a different setup, with all the data on it. If the storage is
    # not accessible the operation will fail.
    # 
    # If the `destroy` parameter is `true` then the operation will always succeed, even if the storage is not
    # accessible, the failure is just ignored and the storage domain is removed from the database anyway.
    # 
    # If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
    # LUN or directory, so it can no longer be imported to the same or to a different setup.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Boolean] :destroy Indicates if the operation should succeed, and the storage domain removed from the database, even if the
    #   storage is not accessible.
    #   
    #   [source]
    #   ----
    #   DELETE /ovirt-engine/api/storageDomains/123?destroy=true
    #   ----
    #   
    #   This parameter is optional, and the default value is `false`.
    #   When the value of `destroy` is `true` the `host` parameter will be ignored.
    # @option opts [Boolean] :format Indicates if the actual storage should be formatted, removing all the metadata from the underlying LUN or
    #   directory:
    #   
    #   [source]
    #   ----
    #   DELETE /ovirt-engine/api/storageDomains/123?format=true
    #   ----
    #   
    #   This parameter is optional, and the default value is `false`.
    # @option opts [String] :host Indicates which host should be used to remove the storage domain.
    #   
    #   This parameter is mandatory, except if the `destroy` parameter is included and its value is `true`, in that
    #   case the `host` parameter will be ignored.
    #   
    #   The value should contain the name or the identifier of the host. For example, to use the host named `myhost`
    #   to remove the storage domain with identifier `123` send a request like this:
    #   
    #   [source]
    #   ----
    #   DELETE /ovirt-engine/api/storageDomains/123?host=myhost
    #   ----
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates a storage domain.
    # 
    # Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable after creation. Those that can be
    # updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
    # `wipe_after_delete.` (Note that changing the `wipe_after_delete` attribute will not change the wipe after delete
    # property of disks that already exist).
    # 
    # To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
    # request as follows:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/storageDomains/123
    # ----
    # 
    # With a request body as follows:
    # 
    # [source,xml]
    # ----
    # <storage_domain>
    #   <name>data2</name>
    #   <wipe_after_delete>true</wipe_after_delete>
    # </storage_domain>
    # ----
    # 
    # @param storage_domain [StorageDomain] The updated storage domain.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def update(storage_domain, opts = {})
      internal_update(storage_domain, StorageDomain, UPDATE, opts)
    end
    
    UPDATE_OVF_STORE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_OVF_STORE
    
    # 
    # This operation forces the update of the `OVF_STORE`
    # of this storage domain.
    # 
    # The `OVF_STORE` is a disk image that contains the metadata
    # of virtual machines and disks that reside in the
    # storage domain. This metadata is used in case the
    # domain is imported or exported to or from a different
    # data center or a different installation.
    # 
    # By default the `OVF_STORE` is updated periodically
    # (set by default to 60 minutes) but users might want to force an
    # update after an important change, or when the they believe the
    # `OVF_STORE` is corrupt.
    # 
    # When initiated by the user, `OVF_STORE` update will be performed whether
    # an update is needed or not.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the `OVF_STORE` update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def update_ovf_store(opts = {})
      internal_action(:updateovfstore, nil, UPDATE_OVF_STORE, opts)
    end
    
    # 
    # Locates the `disk_profiles` service.
    # 
    # @return [AssignedDiskProfilesService] A reference to `disk_profiles` service.
    # 
    def disk_profiles_service
      @disk_profiles_service ||= AssignedDiskProfilesService.new(self, 'diskprofiles')
    end
    
    # 
    # Locates the `disk_snapshots` service.
    # 
    # @return [DiskSnapshotsService] A reference to `disk_snapshots` service.
    # 
    def disk_snapshots_service
      @disk_snapshots_service ||= DiskSnapshotsService.new(self, 'disksnapshots')
    end
    
    # 
    # Reference to the service that manages the disks available in the storage domain.
    # 
    # @return [StorageDomainDisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= StorageDomainDisksService.new(self, 'disks')
    end
    
    # 
    # Returns a reference to the service that manages the files available in the storage domain.
    # 
    # @return [FilesService] A reference to `files` service.
    # 
    def files_service
      @files_service ||= FilesService.new(self, 'files')
    end
    
    # 
    # Locates the `images` service.
    # 
    # @return [ImagesService] A reference to `images` service.
    # 
    def images_service
      @images_service ||= ImagesService.new(self, 'images')
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Returns a reference to the service that manages the storage connections.
    # 
    # @return [StorageDomainServerConnectionsService] A reference to `storage_connections` service.
    # 
    def storage_connections_service
      @storage_connections_service ||= StorageDomainServerConnectionsService.new(self, 'storageconnections')
    end
    
    # 
    # Locates the `templates` service.
    # 
    # @return [StorageDomainTemplatesService] A reference to `templates` service.
    # 
    def templates_service
      @templates_service ||= StorageDomainTemplatesService.new(self, 'templates')
    end
    
    # 
    # Locates the `vms` service.
    # 
    # @return [StorageDomainVmsService] A reference to `vms` service.
    # 
    def vms_service
      @vms_service ||= StorageDomainVmsService.new(self, 'vms')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'diskprofiles'
        return disk_profiles_service
      end
      if path.start_with?('diskprofiles/')
        return disk_profiles_service.service(path[13..-1])
      end
      if path == 'disksnapshots'
        return disk_snapshots_service
      end
      if path.start_with?('disksnapshots/')
        return disk_snapshots_service.service(path[14..-1])
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      if path == 'files'
        return files_service
      end
      if path.start_with?('files/')
        return files_service.service(path[6..-1])
      end
      if path == 'images'
        return images_service
      end
      if path.start_with?('images/')
        return images_service.service(path[7..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'storageconnections'
        return storage_connections_service
      end
      if path.start_with?('storageconnections/')
        return storage_connections_service.service(path[19..-1])
      end
      if path == 'templates'
        return templates_service
      end
      if path.start_with?('templates/')
        return templates_service.service(path[10..-1])
      end
      if path == 'vms'
        return vms_service
      end
      if path.start_with?('vms/')
        return vms_service.service(path[4..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainContentDiskService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainContentDisksService < Service
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disks available in the storage domain.
    # 
    # The order of the returned list of disks is guaranteed only if the `sortby` clause is included in
    # the `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified all the disks are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned disks.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `disk` service.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [StorageDomainContentDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      StorageDomainContentDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageDomainDiskService < MeasurableService
    
    COPY = [
      [:disk, Disk].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :COPY
    
    # 
    # Copies a disk to the specified storage domain.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Disk] :disk Description of the resulting disk.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain where the new disk will be created.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def copy(opts = {})
      internal_action(:copy, nil, COPY, opts)
    end
    
    EXPORT = [
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT
    
    # 
    # Exports a disk to an export storage domain.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [StorageDomain] :storage_domain The export storage domain where the disk should be exported to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export(opts = {})
      internal_action(:export, nil, EXPORT, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the description of the disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    MOVE = [
      [:async, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :MOVE
    
    # 
    # Moves a disk to another storage domain.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the move should be performed asynchronously.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain where the disk will be moved to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def move(opts = {})
      internal_action(:move, nil, MOVE, opts)
    end
    
    REDUCE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REDUCE
    
    # 
    # Reduces the size of the disk image.
    # 
    # Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
    # This is applicable for floating disks and disks attached to non-running virtual machines.
    # There is no need to specify the size as the optimal size is calculated automatically.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reduce(opts = {})
      internal_action(:reduce, nil, REDUCE, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a disk.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    SPARSIFY = [
    ].freeze
    
    private_constant :SPARSIFY
    
    # 
    # Sparsify the disk.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def sparsify(opts = {})
      internal_action(:sparsify, nil, SPARSIFY, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the disk.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To update a disk use the
    # <<services/disk/methods/update, update>> operation of the service that manages that disk.
    # 
    # @param disk [Disk] The update to apply to the disk.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def update(disk, opts = {})
      internal_update(disk, Disk, UPDATE, opts)
    end
    
    # 
    # Reference to the service that manages the permissions assigned to the disk.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainDisksService < Service
    
    ADD = [
      [:unregistered, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds or registers a disk.
    # 
    # IMPORTANT: Since version 4.2 of the {engine-name} this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
    # operation of the service that manages the disks of the system. To register an unregistered disk use the
    # <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
    # that disk.
    # 
    # @param disk [Disk] The disk to add or register.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :unregistered Indicates if a new disk should be added or if an existing unregistered disk should be registered. If the
    #   value is `true` then the identifier of the disk to register needs to be provided. For example, to register
    #   the disk with ID `456` send a request like this:
    #   
    #   ....
    #   POST /ovirt-engine/api/storagedomains/123/disks?unregistered=true
    #   ....
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <disk id="456"/>
    #   ----
    #   
    #   If the value is `false` then a new disk will be created in the storage domain. In that case the
    #   `provisioned_size`, `format`, and `name` attributes are mandatory. For example, to create a new
    #   _copy on write_ disk of 1 GiB, send a request like this:
    #   
    #   ....
    #   POST /ovirt-engine/api/storagedomains/123/disks
    #   ....
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <disk>
    #     <name>mydisk</name>
    #     <format>cow</format>
    #     <provisioned_size>1073741824</provisioned_size>
    #   </disk>
    #   ----
    #   
    #   The default value is `false`.
    #   
    #   This parameter has been deprecated since version 4.2 of
    #   the {engine-name}.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def add(disk, opts = {})
      internal_add(disk, Disk, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:unregistered, TrueClass].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the list of disks that are available in the storage domain.
    # 
    # The order of the returned list of disks is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified, all the disks are returned.
    # 
    # @option opts [Boolean] :unregistered Indicates whether to retrieve a list of registered or unregistered disks in the storage domain.
    #   To get a list of unregistered disks in the storage domain the call should indicate the unregistered flag.
    #   For example, to get a list of unregistered disks the REST API call should look like this:
    #   
    #   ....
    #   GET /ovirt-engine/api/storagedomains/123/disks?unregistered=true
    #   ....
    #   
    #   The default value of the unregistered flag is `false`.
    #   The request only applies to storage domains that are attached.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A reference to the service that manages a specific disk.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [StorageDomainDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      StorageDomainDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageDomainServerConnectionService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Detaches a storage connection from storage.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainServerConnectionsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new `connection`.
    # 
    # @param connection [StorageConnection] The `connection` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def add(connection, opts = {})
      internal_add(connection, StorageConnection, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of connections to storage servers that existin the storage domain.
    # 
    # The order of the returned list of connections isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of connections to return. If not specified all the connections are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<StorageConnection>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `connection` service.
    # 
    # @param id [String] The identifier of the `connection`.
    # 
    # @return [StorageDomainServerConnectionService] A reference to the `connection` service.
    # 
    def connection_service(id)
      StorageDomainServerConnectionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return connection_service(path)
      end
      return connection_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageDomainTemplateService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Template]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT = [
      [:async, TrueClass].freeze,
      [:clone, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:exclusive, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
      [:template, Template].freeze,
      [:vm, Vm].freeze,
    ].freeze
    
    private_constant :IMPORT
    
    # 
    # Action to import a template from an export storage domain.
    # 
    # For example, to import the template `456` from the storage domain `123` send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/storagedomains/123/templates/456/import
    # ----
    # 
    # With the following request body:
    # 
    # [source, xml]
    # ----
    # <action>
    #   <storage_domain>
    #     <name>myexport</name>
    #   </storage_domain>
    #   <cluster>
    #     <name>mycluster</name>
    #   </cluster>
    # </action>
    # ----
    # 
    # If you register an entity without specifying the cluster ID or name,
    # the cluster name from the entity's OVF will be used (unless the register request also includes the
    # cluster mapping).
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the import should be performed asynchronously.
    # 
    # @option opts [Boolean] :clone Use the optional `clone` parameter to generate new UUIDs for the imported template and its entities.
    #   
    #   You can import a template with the `clone` parameter set to `false` when importing a template
    #   from an export domain, with templates that were exported by a different {product-name} environment.
    # 
    # @option opts [Cluster] :cluster 
    # 
    # @option opts [Boolean] :exclusive 
    # 
    # @option opts [StorageDomain] :storage_domain 
    # 
    # @option opts [Template] :template 
    # 
    # @option opts [Vm] :vm 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import(opts = {})
      internal_action(:import, nil, IMPORT, opts)
    end
    
    REGISTER = [
      [:allow_partial_import, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:clone, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:exclusive, TrueClass].freeze,
      [:registration_configuration, RegistrationConfiguration].freeze,
      [:template, Template].freeze,
      [:vnic_profile_mappings, List].freeze,
    ].freeze
    
    private_constant :REGISTER
    
    # 
    # Register the Template means importing the Template from the data domain by inserting the configuration of the
    # Template and disks into the database without the copy process.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :allow_partial_import Indicates whether a template is allowed to be registered with only some of its disks.
    #   
    #   If this flag is `true`, the system will not fail in the validation process if an image is not found, but
    #   instead it will allow the template to be registered without the missing disks. This is mainly used during
    #   registration of a template when some of the storage domains are not available. The default value is `false`.
    # 
    # @option opts [Boolean] :async Indicates if the registration should be performed asynchronously.
    # 
    # @option opts [Boolean] :clone 
    # 
    # @option opts [Cluster] :cluster 
    # 
    # @option opts [Boolean] :exclusive 
    # 
    # @option opts [RegistrationConfiguration] :registration_configuration This parameter describes how the template should be
    #   registered.
    #   
    #   This parameter is optional. If the parameter is not specified, the template
    #   will be registered with the same configuration that
    #   it had in the original environment where it was created.
    # 
    # @option opts [Template] :template 
    # 
    # @option opts [Array<VnicProfileMapping>] :vnic_profile_mappings Deprecated attribute describing mapping rules for virtual NIC profiles that will be applied during the import\register process.
    #   
    #   WARNING: Please note that this attribute has been deprecated since version 4.2.1 of the engine, and preserved only for backward
    #   compatibility. It will be removed in the future. To specify `vnic_profile_mappings` use the `vnic_profile_mappings`
    #   attribute inside the <<types/registration_configuration, RegistrationConfiguration>> type.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def register(opts = {})
      internal_action(:register, nil, REGISTER, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the `disks` service.
    # 
    # @return [StorageDomainContentDisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= StorageDomainContentDisksService.new(self, 'disks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainTemplatesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:unregistered, TrueClass].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of templates availalbe in the storage domain.
    # 
    # The order of the returned list of templates isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of templates to return. If not specified all the templates are returned.
    # 
    # @option opts [Boolean] :unregistered Indicates whether to retrieve a list of registered or unregistered templates which contain disks on the storage domain.
    #   To get a list of unregistered templates the call should indicate the unregistered flag.
    #   For example, to get a list of unregistered templates the REST API call should look like this:
    #   
    #   ....
    #   GET /ovirt-engine/api/storagedomains/123/templates?unregistered=true
    #   ....
    #   
    #   The default value of the unregisterd flag is `false`.
    #   The request only apply to storage domains that are attached.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Template>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `template` service.
    # 
    # @param id [String] The identifier of the `template`.
    # 
    # @return [StorageDomainTemplateService] A reference to the `template` service.
    # 
    def template_service(id)
      StorageDomainTemplateService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return template_service(path)
      end
      return template_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageDomainVmService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT = [
      [:async, TrueClass].freeze,
      [:clone, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:collapse_snapshots, TrueClass].freeze,
      [:exclusive, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
      [:vm, Vm].freeze,
    ].freeze
    
    private_constant :IMPORT
    
    # 
    # Imports a virtual machine from an export storage domain.
    # 
    # For example, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/storagedomains/123/vms/456/import
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain>
    #     <name>mydata</name>
    #   </storage_domain>
    #   <cluster>
    #     <name>mycluster</name>
    #   </cluster>
    # </action>
    # ----
    # 
    # To import a virtual machine as a new entity add the `clone` parameter:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain>
    #     <name>mydata</name>
    #   </storage_domain>
    #   <cluster>
    #     <name>mycluster</name>
    #   </cluster>
    #   <clone>true</clone>
    #   <vm>
    #     <name>myvm</name>
    #   </vm>
    # </action>
    # ----
    # 
    # Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
    # of the template that have the identifiers `123` and `456` send the following request body:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <cluster>
    #     <name>mycluster</name>
    #   </cluster>
    #   <vm>
    #     <name>myvm</name>
    #   </vm>
    #   <disks>
    #     <disk id="123"/>
    #     <disk id="456"/>
    #   </disks>
    # </action>
    # ----
    # 
    # If you register an entity without specifying the cluster ID or name,
    # the cluster name from the entity's OVF will be used (unless the register request also includes the
    # cluster mapping).
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the import should be performed asynchronously.
    # 
    # @option opts [Boolean] :clone Indicates if the identifiers of the imported virtual machine
    #   should be regenerated.
    #   
    #   By default when a virtual machine is imported the identifiers
    #   are preserved. This means that the same virtual machine can't
    #   be imported multiple times, as that identifiers needs to be
    #   unique. To allow importing the same machine multiple times set
    #   this parameter to `true`, as the default is `false`.
    # 
    # @option opts [Cluster] :cluster 
    # 
    # @option opts [Boolean] :collapse_snapshots Indicates of the snapshots of the virtual machine that is imported
    #   should be collapsed, so that the result will be a virtual machine
    #   without snapshots.
    #   
    #   This parameter is optional, and if it isn't explicitly specified the
    #   default value is `false`.
    # 
    # @option opts [Boolean] :exclusive 
    # 
    # @option opts [StorageDomain] :storage_domain 
    # 
    # @option opts [Vm] :vm 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import(opts = {})
      internal_action(:import, nil, IMPORT, opts)
    end
    
    REGISTER = [
      [:allow_partial_import, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:clone, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:reassign_bad_macs, TrueClass].freeze,
      [:registration_configuration, RegistrationConfiguration].freeze,
      [:vm, Vm].freeze,
      [:vnic_profile_mappings, List].freeze,
    ].freeze
    
    private_constant :REGISTER
    
    # 
    # Executes the `register` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :allow_partial_import Indicates whether a virtual machine is allowed to be registered with only some of its disks.
    #   
    #   If this flag is `true`, the engine will not fail in the validation process if an image is not found, but
    #   instead it will allow the virtual machine to be registered without the missing disks. This is mainly used
    #   during registration of a virtual machine when some of the storage domains are not available. The default
    #   value is `false`.
    # 
    # @option opts [Boolean] :async Indicates if the registration should be performed asynchronously.
    # 
    # @option opts [Boolean] :clone 
    # 
    # @option opts [Cluster] :cluster 
    # 
    # @option opts [Boolean] :reassign_bad_macs Indicates if the problematic MAC addresses should be re-assigned during the import process by the engine.
    #   
    #   A MAC address would be considered as a problematic one if one of the following is true:
    #   
    #   - It conflicts with a MAC address that is already allocated to a virtual machine in the target environment.
    #   - It's out of the range of the target MAC address pool.
    # 
    # @option opts [RegistrationConfiguration] :registration_configuration This parameter describes how the virtual machine should be
    #   registered.
    #   
    #   This parameter is optional. If the parameter is not specified, the virtual
    #   machine will be registered with the same configuration that
    #   it had in the original environment where it was created.
    # 
    # @option opts [Vm] :vm 
    # 
    # @option opts [Array<VnicProfileMapping>] :vnic_profile_mappings Deprecated attribute describing mapping rules for virtual NIC profiles that will be applied during the import\register process.
    #   
    #   WARNING: Please note that this attribute has been deprecated since version 4.2.1 of the engine, and preserved only for backward
    #   compatibility. It will be removed in the future. To specify `vnic_profile_mappings` use the `vnic_profile_mappings`
    #   attribute inside the <<types/registration_configuration, RegistrationConfiguration>> type.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def register(opts = {})
      internal_action(:register, nil, REGISTER, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes a virtual machine from an export storage domain.
    # 
    # For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/storagedomains/123/vms/456
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Returns a reference to the service that manages the disk attachments of the virtual machine.
    # 
    # @return [StorageDomainVmDiskAttachmentsService] A reference to `disk_attachments` service.
    # 
    def disk_attachments_service
      @disk_attachments_service ||= StorageDomainVmDiskAttachmentsService.new(self, 'diskattachments')
    end
    
    # 
    # Locates the `disks` service.
    # 
    # @return [StorageDomainContentDisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= StorageDomainContentDisksService.new(self, 'disks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'diskattachments'
        return disk_attachments_service
      end
      if path.start_with?('diskattachments/')
        return disk_attachments_service.service(path[16..-1])
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainVmDiskAttachmentService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the details of the attachment with all its properties and a link to the disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskAttachment]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageDomainVmDiskAttachmentsService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the disks that are attached to the virtual machine.
    # 
    # The order of the returned list of disk attachments isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<DiskAttachment>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific attachment.
    # 
    # @param id [String] The identifier of the `attachment`.
    # 
    # @return [StorageDomainVmDiskAttachmentService] A reference to the `attachment` service.
    # 
    def attachment_service(id)
      StorageDomainVmDiskAttachmentService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return attachment_service(path)
      end
      return attachment_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageDomainVmsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:unregistered, TrueClass].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of virtual machines of the export storage domain.
    # 
    # The order of the returned list of virtual machines isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of virtual machines to return. If not specified all the virtual machines are
    #   returned.
    # 
    # @option opts [Boolean] :unregistered Indicates whether to retrieve a list of registered or unregistered virtual machines which
    #   contain disks on the storage domain.
    #   To get a list of unregistered virtual machines the call should indicate the unregistered flag.
    #   For example, to get a list of unregistered virtual machines the REST API call should look like this:
    #   
    #   ....
    #   GET /ovirt-engine/api/storagedomains/123/vms?unregistered=true
    #   ....
    #   
    #   The default value of the unregisterd flag is `false`.
    #   The request only apply to storage domains that are attached.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Vm>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `vm` service.
    # 
    # @param id [String] The identifier of the `vm`.
    # 
    # @return [StorageDomainVmService] A reference to the `vm` service.
    # 
    def vm_service(id)
      StorageDomainVmService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return vm_service(path)
      end
      return vm_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageDomainsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new storage domain.
    # 
    # Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host`, and `storage`
    # attributes. Identify the `host` attribute with the `id` or `name` attributes. In {product-name} 3.6 and
    # later you can enable the wipe after delete option by default on the storage domain. To configure this, specify
    # `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
    # not change the wipe after delete property of disks that already exist.
    # 
    # To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address`, and `storage.path`,
    # and using a host with an id `123`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/storageDomains
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <storage_domain>
    #   <name>mydata</name>
    #   <type>data</type>
    #   <storage>
    #     <type>nfs</type>
    #     <address>mynfs.example.com</address>
    #     <path>/exports/mydata</path>
    #   </storage>
    #   <host>
    #     <name>myhost</name>
    #   </host>
    # </storage_domain>
    # ----
    # 
    # To create a new NFS ISO storage domain send a request like this:
    # 
    # [source,xml]
    # ----
    # <storage_domain>
    #   <name>myisos</name>
    #   <type>iso</type>
    #   <storage>
    #     <type>nfs</type>
    #     <address>mynfs.example.com</address>
    #     <path>/export/myisos</path>
    #   </storage>
    #   <host>
    #     <name>myhost</name>
    #   </host>
    # </storage_domain>
    # ----
    # 
    # To create a new iSCSI storage domain send a request like this:
    # 
    # [source,xml]
    # ----
    # <storage_domain>
    #   <name>myiscsi</name>
    #   <type>data</type>
    #   <storage>
    #     <type>iscsi</type>
    #     <logical_units>
    #       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
    #       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
    #     </logical_units>
    #   </storage>
    #   <host>
    #     <name>myhost</name>
    #   </host>
    # </storage_domain>
    # ----
    # 
    # @param storage_domain [StorageDomain] The storage domain to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def add(storage_domain, opts = {})
      internal_add(storage_domain, StorageDomain, ADD, opts)
    end
    
    ADD_BLOCK_DOMAIN = [
    ].freeze
    
    private_constant :ADD_BLOCK_DOMAIN
    
    # 
    # Import an existing block storage domain to the system using the targets already connected to the host.
    # 
    # @param storage_domain [StorageDomain] The storage domain to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def add_block_domain(storage_domain, opts = {})
      internal_add(storage_domain, StorageDomain, ADD_BLOCK_DOMAIN, opts)
    end
    
    ADD_BY_PATH = [
    ].freeze
    
    private_constant :ADD_BY_PATH
    
    # 
    # Add a new storage domain to the system using the storage on the given host and path.
    # 
    # @param storage_domain [StorageDomain] The storage domain to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def add_by_path(storage_domain, opts = {})
      internal_add(storage_domain, StorageDomain, ADD_BY_PATH, opts)
    end
    
    ADD_DIRECT_LUN = [
    ].freeze
    
    private_constant :ADD_DIRECT_LUN
    
    # 
    # Add a new storage domain to the system using a direct LUN.
    # 
    # @param storage_domain [StorageDomain] The storage domain to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def add_direct_lun(storage_domain, opts = {})
      internal_add(storage_domain, StorageDomain, ADD_DIRECT_LUN, opts)
    end
    
    ADD_GLUSTER_OR_POSTFS = [
    ].freeze
    
    private_constant :ADD_GLUSTER_OR_POSTFS
    
    # 
    # Add a new storage domain to the system using Gluster or POSIX FS storage.
    # 
    # @param storage_domain [StorageDomain] The storage domain to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def add_gluster_or_postfs(storage_domain, opts = {})
      internal_add(storage_domain, StorageDomain, ADD_GLUSTER_OR_POSTFS, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of storage domains in the system.
    # 
    # The order of the returned list of storage domains is guaranteed only if the `sortby` clause is included
    # in the `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search should be performed taking case into account.
    #   The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case, set it to `false`.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of storage domains to return. If not specified, all the storage domains are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned storage domains.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<StorageDomain>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    ADD_LOCAL = [
    ].freeze
    
    private_constant :ADD_LOCAL
    
    # 
    # Add a new storage domain to the system using the storage on the local host at the given path.
    # 
    # @param storage_domain [StorageDomain] The storage domain to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageDomain]
    # 
    def add_local(storage_domain, opts = {})
      internal_add(storage_domain, StorageDomain, ADD_LOCAL, opts)
    end
    
    # 
    # Locates the `storage_domain` service.
    # 
    # @param id [String] The identifier of the `storage_domain`.
    # 
    # @return [StorageDomainService] A reference to the `storage_domain` service.
    # 
    def storage_domain_service(id)
      StorageDomainService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return storage_domain_service(path)
      end
      return storage_domain_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageServerConnectionService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    UPDATE_GLUSTERFS = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_GLUSTERFS
    
    # 
    # Update the specified Glusterfs storage connection in the system.
    # 
    # @param connection [StorageConnection] The `connection` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the operation should succeed regardless to the relevant storage domain's status
    #   (i.e. updating is also applicable when storage domain's status is not maintenance).
    #   
    #   This parameter is optional, and the default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def update_glusterfs(connection, opts = {})
      internal_update(connection, StorageConnection, UPDATE_GLUSTERFS, opts)
    end
    
    UPDATE_ISCSI = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_ISCSI
    
    # 
    # Update the specified iSCSI storage connection in the system.
    # 
    # @param connection [StorageConnection] The `connection` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the operation should succeed regardless to the relevant storage domain's status
    #   (i.e. updating is also applicable when storage domain's status is not maintenance).
    #   
    #   This parameter is optional, and the default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def update_iscsi(connection, opts = {})
      internal_update(connection, StorageConnection, UPDATE_ISCSI, opts)
    end
    
    UPDATE_LOCAL = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_LOCAL
    
    # 
    # Update the specified local storage connection in the system.
    # 
    # @param connection [StorageConnection] The `connection` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the operation should succeed regardless to the relevant storage domain's status
    #   (i.e. updating is also applicable when storage domain's status is not maintenance).
    #   
    #   This parameter is optional, and the default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def update_local(connection, opts = {})
      internal_update(connection, StorageConnection, UPDATE_LOCAL, opts)
    end
    
    UPDATE_NFS = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_NFS
    
    # 
    # Update the specified NFS storage connection in the system.
    # 
    # @param connection [StorageConnection] The `connection` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the operation should succeed regardless to the relevant storage domain's status
    #   (i.e. updating is also applicable when storage domain's status is not maintenance).
    #   
    #   This parameter is optional, and the default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def update_nfs(connection, opts = {})
      internal_update(connection, StorageConnection, UPDATE_NFS, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
      [:host, String].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a storage connection.
    # 
    # A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
    # id is optional; providing it disconnects (unmounts) the connection from that host.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [String] :host The name or identifier of the host from which the connection would be unmounted (disconnected). If not
    #   provided, no host will be disconnected.
    #   
    #   For example, to use the host with identifier `456` to delete the storage connection with identifier `123`
    #   send a request like this:
    #   
    #   [source]
    #   ----
    #   DELETE /ovirt-engine/api/storageconnections/123?host=456
    #   ----
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the storage connection.
    # 
    # For example, to change the address of an NFS storage server, send a request like this:
    # 
    # [source,xml]
    # ----
    # PUT /ovirt-engine/api/storageconnections/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <storage_connection>
    #   <address>mynewnfs.example.com</address>
    # </storage_connection>
    # ----
    # 
    # To change the connection of an iSCSI storage server, send a request like this:
    # 
    # [source,xml]
    # ----
    # PUT /ovirt-engine/api/storageconnections/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <storage_connection>
    #   <port>3260</port>
    #   <target>iqn.2017-01.com.myhost:444</target>
    # </storage_connection>
    # ----
    # 
    # @param connection [StorageConnection] The `connection` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the operation should succeed regardless to the relevant storage domain's status
    #   (i.e. updating is also applicable when storage domain's status is not maintenance).
    #   
    #   This parameter is optional, and the default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def update(connection, opts = {})
      internal_update(connection, StorageConnection, UPDATE, opts)
    end
    
    UPDATE_VFS = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_VFS
    
    # 
    # Update the specified VFS storage connection in the system.
    # 
    # @param connection [StorageConnection] The `connection` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the operation should succeed regardless to the relevant storage domain's status
    #   (i.e. updating is also applicable when storage domain's status is not maintenance).
    #   
    #   This parameter is optional, and the default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def update_vfs(connection, opts = {})
      internal_update(connection, StorageConnection, UPDATE_VFS, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageServerConnectionExtensionService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnectionExtension]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update a storage server connection extension for the given host.
    # 
    # To update the storage connection `456` of host `123` send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <storage_connection_extension>
    #   <target>iqn.2016-01.com.example:mytarget</target>
    #   <username>myuser</username>
    #   <password>mypassword</password>
    # </storage_connection_extension>
    # ----
    # 
    # @param extension [StorageConnectionExtension] The `extension` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnectionExtension]
    # 
    def update(extension, opts = {})
      internal_update(extension, StorageConnectionExtension, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class StorageServerConnectionExtensionsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new storage server connection extension for the given host.
    # 
    # The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
    # `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
    # like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts/123/storageconnectionextensions
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <storage_connection_extension>
    #   <target>iqn.2016-01.com.example:mytarget</target>
    #   <username>myuser</username>
    #   <password>mypassword</password>
    # </storage_connection_extension>
    # ----
    # 
    # @param extension [StorageConnectionExtension] The `extension` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnectionExtension]
    # 
    def add(extension, opts = {})
      internal_add(extension, StorageConnectionExtension, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list os storage connection extensions.
    # 
    # The order of the returned list of storage connections isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of extensions to return. If not specified all the extensions are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<StorageConnectionExtension>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `storage_connection_extension` service.
    # 
    # @param id [String] The identifier of the `storage_connection_extension`.
    # 
    # @return [StorageServerConnectionExtensionService] A reference to the `storage_connection_extension` service.
    # 
    def storage_connection_extension_service(id)
      StorageServerConnectionExtensionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return storage_connection_extension_service(path)
      end
      return storage_connection_extension_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class StorageServerConnectionsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new storage connection.
    # 
    # For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
    # `/export/mydata` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/storageconnections
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <storage_connection>
    #   <type>nfs</type>
    #   <address>mynfs.example.com</address>
    #   <path>/export/mydata</path>
    #   <host>
    #     <name>myhost</name>
    #   </host>
    # </storage_connection>
    # ----
    # 
    # @param connection [StorageConnection] The `connection` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def add(connection, opts = {})
      internal_add(connection, StorageConnection, ADD, opts)
    end
    
    ADD_GLUSTERFS = [
    ].freeze
    
    private_constant :ADD_GLUSTERFS
    
    # 
    # Add a Glusterfs storage connection to the system.
    # 
    # @param connection [StorageConnection] The `connection` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def add_glusterfs(connection, opts = {})
      internal_add(connection, StorageConnection, ADD_GLUSTERFS, opts)
    end
    
    ADD_ISCSI = [
    ].freeze
    
    private_constant :ADD_ISCSI
    
    # 
    # Add a iSCSI storage connection to the system.
    # 
    # @param connection [StorageConnection] The `connection` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def add_iscsi(connection, opts = {})
      internal_add(connection, StorageConnection, ADD_ISCSI, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of storage connections.
    # 
    # The order of the returned list of connections isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of connections to return. If not specified all the connections are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<StorageConnection>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    ADD_LOCAL = [
    ].freeze
    
    private_constant :ADD_LOCAL
    
    # 
    # Add a local storage connection to the system.
    # 
    # @param connection [StorageConnection] The `connection` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def add_local(connection, opts = {})
      internal_add(connection, StorageConnection, ADD_LOCAL, opts)
    end
    
    ADD_NFS = [
    ].freeze
    
    private_constant :ADD_NFS
    
    # 
    # Add a nfs storage connection to the system.
    # 
    # @param connection [StorageConnection] The `connection` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def add_nfs(connection, opts = {})
      internal_add(connection, StorageConnection, ADD_NFS, opts)
    end
    
    ADD_VFS = [
    ].freeze
    
    private_constant :ADD_VFS
    
    # 
    # Add a vfs storage connection to the system.
    # 
    # @param connection [StorageConnection] The `connection` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [StorageConnection]
    # 
    def add_vfs(connection, opts = {})
      internal_add(connection, StorageConnection, ADD_VFS, opts)
    end
    
    # 
    # Locates the `storage_connection` service.
    # 
    # @param id [String] The identifier of the `storage_connection`.
    # 
    # @return [StorageServerConnectionService] A reference to the `storage_connection` service.
    # 
    def storage_connection_service(id)
      StorageServerConnectionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return storage_connection_service(path)
      end
      return storage_connection_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SystemService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns basic information describing the API, like the product name, the version number and a summary of the
    # number of relevant objects.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api
    # ----
    # 
    # We get following response:
    # 
    # [source,xml]
    # ----
    # <api>
    #   <link rel="capabilities" href="/api/capabilities"/>
    #   <link rel="clusters" href="/api/clusters"/>
    #   <link rel="clusters/search" href="/api/clusters?search={query}"/>
    #   <link rel="datacenters" href="/api/datacenters"/>
    #   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
    #   <link rel="events" href="/api/events"/>
    #   <link rel="events/search" href="/api/events?search={query}"/>
    #   <link rel="hosts" href="/api/hosts"/>
    #   <link rel="hosts/search" href="/api/hosts?search={query}"/>
    #   <link rel="networks" href="/api/networks"/>
    #   <link rel="roles" href="/api/roles"/>
    #   <link rel="storagedomains" href="/api/storagedomains"/>
    #   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
    #   <link rel="tags" href="/api/tags"/>
    #   <link rel="templates" href="/api/templates"/>
    #   <link rel="templates/search" href="/api/templates?search={query}"/>
    #   <link rel="users" href="/api/users"/>
    #   <link rel="groups" href="/api/groups"/>
    #   <link rel="domains" href="/api/domains"/>
    #   <link rel="vmpools" href="/api/vmpools"/>
    #   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
    #   <link rel="vms" href="/api/vms"/>
    #   <link rel="vms/search" href="/api/vms?search={query}"/>
    #   <product_info>
    #     <name>oVirt Engine</name>
    #     <vendor>ovirt.org</vendor>
    #     <version>
    #       <build>4</build>
    #       <full_version>4.0.4</full_version>
    #       <major>4</major>
    #       <minor>0</minor>
    #       <revision>0</revision>
    #     </version>
    #   </product_info>
    #   <special_objects>
    #     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
    #     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
    #   </special_objects>
    #   <summary>
    #     <hosts>
    #       <active>0</active>
    #       <total>0</total>
    #     </hosts>
    #     <storage_domains>
    #       <active>0</active>
    #       <total>1</total>
    #     </storage_domains>
    #     <users>
    #       <active>1</active>
    #       <total>1</total>
    #     </users>
    #     <vms>
    #       <active>0</active>
    #       <total>0</total>
    #     </vms>
    #   </summary>
    #   <time>2016-09-14T12:00:48.132+02:00</time>
    # </api>
    # ----
    # 
    # The entry point provides a user with links to the collections in a
    # virtualization environment. The `rel` attribute of each collection link
    # provides a reference point for each link.
    # 
    # The entry point also contains other data such as `product_info`,
    # `special_objects` and `summary`.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Api]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    RELOAD_CONFIGURATIONS = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :RELOAD_CONFIGURATIONS
    
    # 
    # Executes the `reload_configurations` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the reload should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reload_configurations(opts = {})
      internal_action(:reloadconfigurations, nil, RELOAD_CONFIGURATIONS, opts)
    end
    
    # 
    # List all known affinity labels.
    # 
    # @return [AffinityLabelsService] A reference to `affinity_labels` service.
    # 
    def affinity_labels_service
      @affinity_labels_service ||= AffinityLabelsService.new(self, 'affinitylabels')
    end
    
    # 
    # Locates the `bookmarks` service.
    # 
    # @return [BookmarksService] A reference to `bookmarks` service.
    # 
    def bookmarks_service
      @bookmarks_service ||= BookmarksService.new(self, 'bookmarks')
    end
    
    # 
    # Reference to the service that provides information about the cluster levels supported by the system.
    # 
    # @return [ClusterLevelsService] A reference to `cluster_levels` service.
    # 
    def cluster_levels_service
      @cluster_levels_service ||= ClusterLevelsService.new(self, 'clusterlevels')
    end
    
    # 
    # Locates the `clusters` service.
    # 
    # @return [ClustersService] A reference to `clusters` service.
    # 
    def clusters_service
      @clusters_service ||= ClustersService.new(self, 'clusters')
    end
    
    # 
    # Locates the `cpu_profiles` service.
    # 
    # @return [CpuProfilesService] A reference to `cpu_profiles` service.
    # 
    def cpu_profiles_service
      @cpu_profiles_service ||= CpuProfilesService.new(self, 'cpuprofiles')
    end
    
    # 
    # Locates the `data_centers` service.
    # 
    # @return [DataCentersService] A reference to `data_centers` service.
    # 
    def data_centers_service
      @data_centers_service ||= DataCentersService.new(self, 'datacenters')
    end
    
    # 
    # Locates the `disk_profiles` service.
    # 
    # @return [DiskProfilesService] A reference to `disk_profiles` service.
    # 
    def disk_profiles_service
      @disk_profiles_service ||= DiskProfilesService.new(self, 'diskprofiles')
    end
    
    # 
    # Locates the `disks` service.
    # 
    # @return [DisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= DisksService.new(self, 'disks')
    end
    
    # 
    # Locates the `domains` service.
    # 
    # @return [DomainsService] A reference to `domains` service.
    # 
    def domains_service
      @domains_service ||= DomainsService.new(self, 'domains')
    end
    
    # 
    # Locates the `events` service.
    # 
    # @return [EventsService] A reference to `events` service.
    # 
    def events_service
      @events_service ||= EventsService.new(self, 'events')
    end
    
    # 
    # Locates the `external_host_providers` service.
    # 
    # @return [ExternalHostProvidersService] A reference to `external_host_providers` service.
    # 
    def external_host_providers_service
      @external_host_providers_service ||= ExternalHostProvidersService.new(self, 'externalhostproviders')
    end
    
    # 
    # Reference to service facilitating import of external virtual machines.
    # 
    # @return [ExternalVmImportsService] A reference to `external_vm_imports` service.
    # 
    def external_vm_imports_service
      @external_vm_imports_service ||= ExternalVmImportsService.new(self, 'externalvmimports')
    end
    
    # 
    # Locates the `groups` service.
    # 
    # @return [GroupsService] A reference to `groups` service.
    # 
    def groups_service
      @groups_service ||= GroupsService.new(self, 'groups')
    end
    
    # 
    # Locates the `hosts` service.
    # 
    # @return [HostsService] A reference to `hosts` service.
    # 
    def hosts_service
      @hosts_service ||= HostsService.new(self, 'hosts')
    end
    
    # 
    # Locates the `icons` service.
    # 
    # @return [IconsService] A reference to `icons` service.
    # 
    def icons_service
      @icons_service ||= IconsService.new(self, 'icons')
    end
    
    # 
    # List of all image transfers being performed for image I/O in oVirt.
    # 
    # @return [ImageTransfersService] A reference to `image_transfers` service.
    # 
    def image_transfers_service
      @image_transfers_service ||= ImageTransfersService.new(self, 'imagetransfers')
    end
    
    # 
    # Locates the `instance_types` service.
    # 
    # @return [InstanceTypesService] A reference to `instance_types` service.
    # 
    def instance_types_service
      @instance_types_service ||= InstanceTypesService.new(self, 'instancetypes')
    end
    
    # 
    # List all the jobs monitored by the engine.
    # 
    # @return [JobsService] A reference to `jobs` service.
    # 
    def jobs_service
      @jobs_service ||= JobsService.new(self, 'jobs')
    end
    
    # 
    # List the available Katello errata assigned to the engine.
    # 
    # @return [EngineKatelloErrataService] A reference to `katello_errata` service.
    # 
    def katello_errata_service
      @katello_errata_service ||= EngineKatelloErrataService.new(self, 'katelloerrata')
    end
    
    # 
    # Locates the `mac_pools` service.
    # 
    # @return [MacPoolsService] A reference to `mac_pools` service.
    # 
    def mac_pools_service
      @mac_pools_service ||= MacPoolsService.new(self, 'macpools')
    end
    
    # 
    # Network filters will enhance the admin ability to manage the network packets traffic from/to the participated
    # VMs.
    # 
    # @return [NetworkFiltersService] A reference to `network_filters` service.
    # 
    def network_filters_service
      @network_filters_service ||= NetworkFiltersService.new(self, 'networkfilters')
    end
    
    # 
    # Locates the `networks` service.
    # 
    # @return [NetworksService] A reference to `networks` service.
    # 
    def networks_service
      @networks_service ||= NetworksService.new(self, 'networks')
    end
    
    # 
    # Locates the `openstack_image_providers` service.
    # 
    # @return [OpenstackImageProvidersService] A reference to `openstack_image_providers` service.
    # 
    def openstack_image_providers_service
      @openstack_image_providers_service ||= OpenstackImageProvidersService.new(self, 'openstackimageproviders')
    end
    
    # 
    # Locates the `openstack_network_providers` service.
    # 
    # @return [OpenstackNetworkProvidersService] A reference to `openstack_network_providers` service.
    # 
    def openstack_network_providers_service
      @openstack_network_providers_service ||= OpenstackNetworkProvidersService.new(self, 'openstacknetworkproviders')
    end
    
    # 
    # Locates the `openstack_volume_providers` service.
    # 
    # @return [OpenstackVolumeProvidersService] A reference to `openstack_volume_providers` service.
    # 
    def openstack_volume_providers_service
      @openstack_volume_providers_service ||= OpenstackVolumeProvidersService.new(self, 'openstackvolumeproviders')
    end
    
    # 
    # Locates the `operating_systems` service.
    # 
    # @return [OperatingSystemsService] A reference to `operating_systems` service.
    # 
    def operating_systems_service
      @operating_systems_service ||= OperatingSystemsService.new(self, 'operatingsystems')
    end
    
    # 
    # Reference to the service that provides values of configuration options of the system.
    # 
    # @return [SystemOptionsService] A reference to `options` service.
    # 
    def options_service
      @options_service ||= SystemOptionsService.new(self, 'options')
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [SystemPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= SystemPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `roles` service.
    # 
    # @return [RolesService] A reference to `roles` service.
    # 
    def roles_service
      @roles_service ||= RolesService.new(self, 'roles')
    end
    
    # 
    # Locates the `scheduling_policies` service.
    # 
    # @return [SchedulingPoliciesService] A reference to `scheduling_policies` service.
    # 
    def scheduling_policies_service
      @scheduling_policies_service ||= SchedulingPoliciesService.new(self, 'schedulingpolicies')
    end
    
    # 
    # Locates the `scheduling_policy_units` service.
    # 
    # @return [SchedulingPolicyUnitsService] A reference to `scheduling_policy_units` service.
    # 
    def scheduling_policy_units_service
      @scheduling_policy_units_service ||= SchedulingPolicyUnitsService.new(self, 'schedulingpolicyunits')
    end
    
    # 
    # Locates the `storage_connections` service.
    # 
    # @return [StorageServerConnectionsService] A reference to `storage_connections` service.
    # 
    def storage_connections_service
      @storage_connections_service ||= StorageServerConnectionsService.new(self, 'storageconnections')
    end
    
    # 
    # Locates the `storage_domains` service.
    # 
    # @return [StorageDomainsService] A reference to `storage_domains` service.
    # 
    def storage_domains_service
      @storage_domains_service ||= StorageDomainsService.new(self, 'storagedomains')
    end
    
    # 
    # Locates the `tags` service.
    # 
    # @return [TagsService] A reference to `tags` service.
    # 
    def tags_service
      @tags_service ||= TagsService.new(self, 'tags')
    end
    
    # 
    # Locates the `templates` service.
    # 
    # @return [TemplatesService] A reference to `templates` service.
    # 
    def templates_service
      @templates_service ||= TemplatesService.new(self, 'templates')
    end
    
    # 
    # Locates the `users` service.
    # 
    # @return [UsersService] A reference to `users` service.
    # 
    def users_service
      @users_service ||= UsersService.new(self, 'users')
    end
    
    # 
    # Locates the `vm_pools` service.
    # 
    # @return [VmPoolsService] A reference to `vm_pools` service.
    # 
    def vm_pools_service
      @vm_pools_service ||= VmPoolsService.new(self, 'vmpools')
    end
    
    # 
    # Locates the `vms` service.
    # 
    # @return [VmsService] A reference to `vms` service.
    # 
    def vms_service
      @vms_service ||= VmsService.new(self, 'vms')
    end
    
    # 
    # Locates the `vnic_profiles` service.
    # 
    # @return [VnicProfilesService] A reference to `vnic_profiles` service.
    # 
    def vnic_profiles_service
      @vnic_profiles_service ||= VnicProfilesService.new(self, 'vnicprofiles')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'affinitylabels'
        return affinity_labels_service
      end
      if path.start_with?('affinitylabels/')
        return affinity_labels_service.service(path[15..-1])
      end
      if path == 'bookmarks'
        return bookmarks_service
      end
      if path.start_with?('bookmarks/')
        return bookmarks_service.service(path[10..-1])
      end
      if path == 'clusterlevels'
        return cluster_levels_service
      end
      if path.start_with?('clusterlevels/')
        return cluster_levels_service.service(path[14..-1])
      end
      if path == 'clusters'
        return clusters_service
      end
      if path.start_with?('clusters/')
        return clusters_service.service(path[9..-1])
      end
      if path == 'cpuprofiles'
        return cpu_profiles_service
      end
      if path.start_with?('cpuprofiles/')
        return cpu_profiles_service.service(path[12..-1])
      end
      if path == 'datacenters'
        return data_centers_service
      end
      if path.start_with?('datacenters/')
        return data_centers_service.service(path[12..-1])
      end
      if path == 'diskprofiles'
        return disk_profiles_service
      end
      if path.start_with?('diskprofiles/')
        return disk_profiles_service.service(path[13..-1])
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      if path == 'domains'
        return domains_service
      end
      if path.start_with?('domains/')
        return domains_service.service(path[8..-1])
      end
      if path == 'events'
        return events_service
      end
      if path.start_with?('events/')
        return events_service.service(path[7..-1])
      end
      if path == 'externalhostproviders'
        return external_host_providers_service
      end
      if path.start_with?('externalhostproviders/')
        return external_host_providers_service.service(path[22..-1])
      end
      if path == 'externalvmimports'
        return external_vm_imports_service
      end
      if path.start_with?('externalvmimports/')
        return external_vm_imports_service.service(path[18..-1])
      end
      if path == 'groups'
        return groups_service
      end
      if path.start_with?('groups/')
        return groups_service.service(path[7..-1])
      end
      if path == 'hosts'
        return hosts_service
      end
      if path.start_with?('hosts/')
        return hosts_service.service(path[6..-1])
      end
      if path == 'icons'
        return icons_service
      end
      if path.start_with?('icons/')
        return icons_service.service(path[6..-1])
      end
      if path == 'imagetransfers'
        return image_transfers_service
      end
      if path.start_with?('imagetransfers/')
        return image_transfers_service.service(path[15..-1])
      end
      if path == 'instancetypes'
        return instance_types_service
      end
      if path.start_with?('instancetypes/')
        return instance_types_service.service(path[14..-1])
      end
      if path == 'jobs'
        return jobs_service
      end
      if path.start_with?('jobs/')
        return jobs_service.service(path[5..-1])
      end
      if path == 'katelloerrata'
        return katello_errata_service
      end
      if path.start_with?('katelloerrata/')
        return katello_errata_service.service(path[14..-1])
      end
      if path == 'macpools'
        return mac_pools_service
      end
      if path.start_with?('macpools/')
        return mac_pools_service.service(path[9..-1])
      end
      if path == 'networkfilters'
        return network_filters_service
      end
      if path.start_with?('networkfilters/')
        return network_filters_service.service(path[15..-1])
      end
      if path == 'networks'
        return networks_service
      end
      if path.start_with?('networks/')
        return networks_service.service(path[9..-1])
      end
      if path == 'openstackimageproviders'
        return openstack_image_providers_service
      end
      if path.start_with?('openstackimageproviders/')
        return openstack_image_providers_service.service(path[24..-1])
      end
      if path == 'openstacknetworkproviders'
        return openstack_network_providers_service
      end
      if path.start_with?('openstacknetworkproviders/')
        return openstack_network_providers_service.service(path[26..-1])
      end
      if path == 'openstackvolumeproviders'
        return openstack_volume_providers_service
      end
      if path.start_with?('openstackvolumeproviders/')
        return openstack_volume_providers_service.service(path[25..-1])
      end
      if path == 'operatingsystems'
        return operating_systems_service
      end
      if path.start_with?('operatingsystems/')
        return operating_systems_service.service(path[17..-1])
      end
      if path == 'options'
        return options_service
      end
      if path.start_with?('options/')
        return options_service.service(path[8..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'roles'
        return roles_service
      end
      if path.start_with?('roles/')
        return roles_service.service(path[6..-1])
      end
      if path == 'schedulingpolicies'
        return scheduling_policies_service
      end
      if path.start_with?('schedulingpolicies/')
        return scheduling_policies_service.service(path[19..-1])
      end
      if path == 'schedulingpolicyunits'
        return scheduling_policy_units_service
      end
      if path.start_with?('schedulingpolicyunits/')
        return scheduling_policy_units_service.service(path[22..-1])
      end
      if path == 'storageconnections'
        return storage_connections_service
      end
      if path.start_with?('storageconnections/')
        return storage_connections_service.service(path[19..-1])
      end
      if path == 'storagedomains'
        return storage_domains_service
      end
      if path.start_with?('storagedomains/')
        return storage_domains_service.service(path[15..-1])
      end
      if path == 'tags'
        return tags_service
      end
      if path.start_with?('tags/')
        return tags_service.service(path[5..-1])
      end
      if path == 'templates'
        return templates_service
      end
      if path.start_with?('templates/')
        return templates_service.service(path[10..-1])
      end
      if path == 'users'
        return users_service
      end
      if path.start_with?('users/')
        return users_service.service(path[6..-1])
      end
      if path == 'vmpools'
        return vm_pools_service
      end
      if path.start_with?('vmpools/')
        return vm_pools_service.service(path[8..-1])
      end
      if path == 'vms'
        return vms_service
      end
      if path.start_with?('vms/')
        return vms_service.service(path[4..-1])
      end
      if path == 'vnicprofiles'
        return vnic_profiles_service
      end
      if path.start_with?('vnicprofiles/')
        return vnic_profiles_service.service(path[13..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SystemOptionService < Service
    
    GET = [
      [:version, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get the values of specific configuration option.
    # 
    # For example to retrieve the values of configuration option `MigrationPoliciesSupported` send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/options/MigrationPoliciesSupported
    # ----
    # 
    # The response to that request will be the following:
    # 
    # [source,xml]
    # ----
    # <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
    #   <name>MigrationPoliciesSupported</name>
    #   <values>
    #     <system_option_value>
    #       <value>true</value>
    #       <version>4.0</version>
    #     </system_option_value>
    #     <system_option_value>
    #       <value>true</value>
    #       <version>4.1</version>
    #     </system_option_value>
    #     <system_option_value>
    #       <value>true</value>
    #       <version>4.2</version>
    #     </system_option_value>
    #     <system_option_value>
    #       <value>false</value>
    #       <version>3.6</version>
    #     </system_option_value>
    #   </values>
    # </system_option>
    # ----
    # 
    # NOTE: The appropriate permissions are required to query configuration options. Some options can be queried
    # only by users with administrator permissions.
    # 
    # [IMPORTANT]
    # ====
    # There is NO backward compatibility and no guarantee about the names or values of the options. Options may be
    # removed and their meaning can be changed at any point.
    # 
    # We strongly discourage the use of this service for applications other than the ones that are released
    # simultaneously with the engine. Usage by other applications is not supported. Therefore there will be no
    # documentation listing accessible configuration options.
    # ====
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :version Optional version parameter that specifies that only particular version of the configuration option
    #   should be returned.
    #   If this parameter isn't used then all the versions will be returned.
    #   
    #   For example, to get the value of the `MigrationPoliciesSupported` option but only for version `4.2` send
    #   a request like this:
    #   
    #   [source]
    #   ----
    #   GET /ovirt-engine/api/options/MigrationPoliciesSupported?version=4.2
    #   ----
    #   
    #   The response to that request will be like this:
    #   
    #   [source,xml]
    #   ----
    #   <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
    #     <name>MigrationPoliciesSupported</name>
    #     <values>
    #       <system_option_value>
    #         <value>true</value>
    #         <version>4.2</version>
    #       </system_option_value>
    #     </values>
    #   </system_option>
    #   ----
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [SystemOption]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class SystemOptionsService < Service
    
    # 
    # Returns a reference to the service that provides values of specific configuration option.
    # 
    # @param id [String] The identifier of the `option`.
    # 
    # @return [SystemOptionService] A reference to the `option` service.
    # 
    def option_service(id)
      SystemOptionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return option_service(path)
      end
      return option_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class SystemPermissionsService < AssignedPermissionsService
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Assign a new permission to a user or group for specific entity.
    # 
    # For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
    # send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/vms/123/permissions
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <permission>
    #   <role>
    #     <name>UserVmManager</name>
    #   </role>
    #   <user id="456"/>
    # </permission>
    # ----
    # 
    # To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/permissions
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <permission>
    #   <role>
    #     <name>SuperUser</name>
    #   </role>
    #   <user id="456"/>
    # </permission>
    # ----
    # 
    # If you want to assign permission to the group instead of the user please replace the `user` element with the
    # `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
    # id `123` to the group with id `789` send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/clusters/123/permissions
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <permission>
    #   <role>
    #     <name>UserRole</name>
    #   </role>
    #   <group id="789"/>
    # </permission>
    # ----
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add(permission, opts = {})
      internal_add(permission, Permission, ADD, opts)
    end
    
    ADD_CLUSTER_PERMISSION = [
    ].freeze
    
    private_constant :ADD_CLUSTER_PERMISSION
    
    # 
    # Add a new permission on the cluster to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_cluster_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_CLUSTER_PERMISSION, opts)
    end
    
    ADD_DATA_CENTER_PERMISSION = [
    ].freeze
    
    private_constant :ADD_DATA_CENTER_PERMISSION
    
    # 
    # Add a new permission on the data center to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_data_center_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_DATA_CENTER_PERMISSION, opts)
    end
    
    ADD_GROUP_LEVEL = [
    ].freeze
    
    private_constant :ADD_GROUP_LEVEL
    
    # 
    # Add a new group level permission for a given virtual machine.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_group_level(permission, opts = {})
      internal_add(permission, Permission, ADD_GROUP_LEVEL, opts)
    end
    
    ADD_HOST_PERMISSION = [
    ].freeze
    
    private_constant :ADD_HOST_PERMISSION
    
    # 
    # Add a new permission on the host to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_host_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_HOST_PERMISSION, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all the permissions of the specific entity.
    # 
    # For example to list all the permissions of the cluster with id `123` send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/clusters/123/permissions
    # ....
    # 
    # [source,xml]
    # ----
    # <permissions>
    #   <permission id="456">
    #     <cluster id="123"/>
    #     <role id="789"/>
    #     <user id="451"/>
    #   </permission>
    #   <permission id="654">
    #     <cluster id="123"/>
    #     <role id="789"/>
    #     <group id="127"/>
    #   </permission>
    # </permissions>
    # ----
    # 
    # The order of the returned permissions isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Permission>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    ADD_STORAGE_DOMAIN_PERMISSION = [
    ].freeze
    
    private_constant :ADD_STORAGE_DOMAIN_PERMISSION
    
    # 
    # Add a new permission on the storage domain to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_storage_domain_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_STORAGE_DOMAIN_PERMISSION, opts)
    end
    
    ADD_TEMPLATE_PERMISSION = [
    ].freeze
    
    private_constant :ADD_TEMPLATE_PERMISSION
    
    # 
    # Add a new permission on the template to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_template_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_TEMPLATE_PERMISSION, opts)
    end
    
    ADD_USER_LEVEL = [
    ].freeze
    
    private_constant :ADD_USER_LEVEL
    
    # 
    # Add a new user level permission for a given virtual machine.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_user_level(permission, opts = {})
      internal_add(permission, Permission, ADD_USER_LEVEL, opts)
    end
    
    ADD_VM_PERMISSION = [
    ].freeze
    
    private_constant :ADD_VM_PERMISSION
    
    # 
    # Add a new permission on the vm to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_vm_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_VM_PERMISSION, opts)
    end
    
    ADD_VM_POOL_PERMISSION = [
    ].freeze
    
    private_constant :ADD_VM_POOL_PERMISSION
    
    # 
    # Add a new permission on the vm pool to the group in the system.
    # 
    # @param permission [Permission] The permission.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Permission]
    # 
    def add_vm_pool_permission(permission, opts = {})
      internal_add(permission, Permission, ADD_VM_POOL_PERMISSION, opts)
    end
    
    # 
    # Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
    # dispatched.
    # 
    # @param id [String] The identifier of the `permission`.
    # 
    # @return [PermissionService] A reference to the `permission` service.
    # 
    def permission_service(id)
      PermissionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return permission_service(path)
      end
      return permission_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TagService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the information about the tag.
    # 
    # For example to retrieve the information about the tag with the id `123` send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/tags/123
    # ....
    # 
    # [source,xml]
    # ----
    # <tag href="/ovirt-engine/api/tags/123" id="123">
    #   <name>root</name>
    #   <description>root</description>
    # </tag>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Tag]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the tag from the system.
    # 
    # For example to remove the tag with id `123` send a request like this:
    # 
    # ....
    # DELETE /ovirt-engine/api/tags/123
    # ....
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the tag entity.
    # 
    # For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
    # 
    # ....
    # PUT /ovirt-engine/api/tags/123
    # ....
    # 
    # With request body like:
    # 
    # [source,xml]
    # ----
    # <tag>
    #   <parent id="456"/>
    # </tag>
    # ----
    # 
    # You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
    # of the tag with id `123` send a request like this:
    # 
    # [source,xml]
    # ----
    # <tag>
    #   <parent>
    #     <name>mytag</name>
    #   </parent>
    # </tag>
    # ----
    # 
    # @param tag [Tag] The updated tag.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Tag]
    # 
    def update(tag, opts = {})
      internal_update(tag, Tag, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TagsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new tag to the system.
    # 
    # For example, to add new tag with name `mytag` to the system send a request like this:
    # 
    # ....
    # POST /ovirt-engine/api/tags
    # ....
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <tag>
    #   <name>mytag</name>
    # </tag>
    # ----
    # 
    # NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
    # The root tag cannot be deleted nor assigned a parent tag.
    # 
    # To create new tag with specific parent tag send a request body like this:
    # 
    # [source,xml]
    # ----
    # <tag>
    #   <name>mytag</name>
    #   <parent>
    #     <name>myparenttag</name>
    #   </parent>
    # </tag>
    # ----
    # 
    # @param tag [Tag] The added tag.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Tag]
    # 
    def add(tag, opts = {})
      internal_add(tag, Tag, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the tags in the system.
    # 
    # For example to list the full hierarchy of the tags in the system send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/tags
    # ....
    # 
    # [source,xml]
    # ----
    # <tags>
    #   <tag href="/ovirt-engine/api/tags/222" id="222">
    #     <name>root2</name>
    #     <description>root2</description>
    #     <parent href="/ovirt-engine/api/tags/111" id="111"/>
    #   </tag>
    #   <tag href="/ovirt-engine/api/tags/333" id="333">
    #     <name>root3</name>
    #     <description>root3</description>
    #     <parent href="/ovirt-engine/api/tags/222" id="222"/>
    #   </tag>
    #   <tag href="/ovirt-engine/api/tags/111" id="111">
    #     <name>root</name>
    #     <description>root</description>
    #   </tag>
    # </tags>
    # ----
    # 
    # In the previous XML output you can see the following hierarchy of the tags:
    # ....
    # root:        (id: 111)
    #   - root2    (id: 222)
    #     - root3  (id: 333)
    # ....
    # 
    # The order of the returned list of tags isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of tags to return. If not specified all the tags are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Tag>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific tag.
    # 
    # @param id [String] The identifier of the `tag`.
    # 
    # @return [TagService] A reference to the `tag` service.
    # 
    def tag_service(id)
      TagService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return tag_service(path)
      end
      return tag_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TemplateService < Service
    
    EXPORT = [
      [:exclusive, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT
    
    # 
    # Exports a template to the data center export domain.
    # 
    # For example, send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/templates/123/export
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain id="456"/>
    #   <exclusive>true<exclusive/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :exclusive Indicates if the existing templates with the same name should be overwritten.
    #   
    #   The export action reports a failed action if a template of the same name exists in the destination domain.
    #   Set this parameter to `true` to change this behavior and overwrite any existing template.
    # 
    # @option opts [StorageDomain] :storage_domain Specifies the destination export storage domain.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export(opts = {})
      internal_action(:export, nil, EXPORT, opts)
    end
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the information about this template or template version.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Template]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a virtual machine template.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/templates/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the removal should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    EXPORT_TO_EXPORT_DOMAIN = [
      [:exclusive, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT_TO_EXPORT_DOMAIN
    
    # 
    # Exports a template to an export domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :exclusive Indicates if the existing templates with the same name should be overwritten.
    #   
    #   The export action reports a failed action if a template of the same name exists in the destination domain.
    #   Set this parameter to `true` to change this behavior and overwrite any existing template.
    # 
    # @option opts [StorageDomain] :storage_domain Specifies the destination export storage domain.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export_to_export_domain(opts = {})
      internal_action(:export, nil, EXPORT_TO_EXPORT_DOMAIN, opts)
    end
    
    EXPORT_TO_PATH_ON_HOST = [
      [:directory, String].freeze,
      [:exclusive, TrueClass].freeze,
      [:filename, String].freeze,
      [:host, Host].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT_TO_PATH_ON_HOST
    
    # 
    # Exports a template as an OVA file to a given path on a specified host.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :directory An absolute path of a directory on the host to generate the OVA file in.
    # 
    # @option opts [Boolean] :exclusive Indicates if the existing templates with the same name should be overwritten.
    #   
    #   The export action reports a failed action if a template of the same name exists in the destination domain.
    #   Set this parameter to `true` to change this behavior and overwrite any existing template.
    # 
    # @option opts [String] :filename The name of the OVA file.
    #   
    #   This is an optional parameter. If it is not specified, the name of the OVA file is determined according
    #   to the name of the template. It will conform to the following pattern: "<template name>.ova".
    # 
    # @option opts [Host] :host The host to generate the OVA file on.
    # 
    # @option opts [StorageDomain] :storage_domain Specifies the destination export storage domain.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export_to_path_on_host(opts = {})
      internal_action(:export, nil, EXPORT_TO_PATH_ON_HOST, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the template.
    # 
    # The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
    # `stateless`, `usb`, and `timezone` elements can be updated after a template has been created.
    # 
    # For example, to update a template so that it has 1 GiB of memory send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/templates/123
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <template>
    #   <memory>1073741824</memory>
    # </template>
    # ----
    # 
    # The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
    # template versions:
    # 
    # [source,xml]
    # ----
    # <template>
    #   <version>
    #     <version_name>mytemplate_2</version_name>
    #   </version>
    # </template>
    # ----
    # 
    # @param template [Template] The `template` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Template]
    # 
    def update(template, opts = {})
      internal_update(template, Template, UPDATE, opts)
    end
    
    # 
    # Returns a reference to the service that manages the CD-ROMs that are associated with the template.
    # 
    # @return [TemplateCdromsService] A reference to `cdroms` service.
    # 
    def cdroms_service
      @cdroms_service ||= TemplateCdromsService.new(self, 'cdroms')
    end
    
    # 
    # Returns a reference to the service that manages a specific
    # disk attachment of the template.
    # 
    # @return [TemplateDiskAttachmentsService] A reference to `disk_attachments` service.
    # 
    def disk_attachments_service
      @disk_attachments_service ||= TemplateDiskAttachmentsService.new(self, 'diskattachments')
    end
    
    # 
    # Returns a reference to the service that manages the graphical consoles that are associated with the template.
    # 
    # @return [TemplateGraphicsConsolesService] A reference to `graphics_consoles` service.
    # 
    def graphics_consoles_service
      @graphics_consoles_service ||= TemplateGraphicsConsolesService.new(self, 'graphicsconsoles')
    end
    
    # 
    # Returns a reference to the service that manages the NICs that are associated with the template.
    # 
    # @return [TemplateNicsService] A reference to `nics` service.
    # 
    def nics_service
      @nics_service ||= TemplateNicsService.new(self, 'nics')
    end
    
    # 
    # Returns a reference to the service that manages the permissions that are associated with the template.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Returns a reference to the service that manages the tags that are associated with the template.
    # 
    # @return [AssignedTagsService] A reference to `tags` service.
    # 
    def tags_service
      @tags_service ||= AssignedTagsService.new(self, 'tags')
    end
    
    # 
    # Returns a reference to the service that manages the _watchdogs_ that are associated with the template.
    # 
    # @return [TemplateWatchdogsService] A reference to `watchdogs` service.
    # 
    def watchdogs_service
      @watchdogs_service ||= TemplateWatchdogsService.new(self, 'watchdogs')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'cdroms'
        return cdroms_service
      end
      if path.start_with?('cdroms/')
        return cdroms_service.service(path[7..-1])
      end
      if path == 'diskattachments'
        return disk_attachments_service
      end
      if path.start_with?('diskattachments/')
        return disk_attachments_service.service(path[16..-1])
      end
      if path == 'graphicsconsoles'
        return graphics_consoles_service
      end
      if path.start_with?('graphicsconsoles/')
        return graphics_consoles_service.service(path[17..-1])
      end
      if path == 'nics'
        return nics_service
      end
      if path.start_with?('nics/')
        return nics_service.service(path[5..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'tags'
        return tags_service
      end
      if path.start_with?('tags/')
        return tags_service.service(path[5..-1])
      end
      if path == 'watchdogs'
        return watchdogs_service
      end
      if path.start_with?('watchdogs/')
        return watchdogs_service.service(path[10..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TemplateCdromService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the information about this CD-ROM device.
    # 
    # For example, to get information about the CD-ROM device of template `123` send a request like:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/templates/123/cdroms/
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cdrom]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TemplateCdromsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of CD-ROM devices of the template.
    # 
    # The order of the returned list of CD-ROM devices isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of CD-ROMs to return. If not specified all the CD-ROMs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Cdrom>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific CD-ROM device.
    # 
    # @param id [String] The identifier of the `cdrom`.
    # 
    # @return [TemplateCdromService] A reference to the `cdrom` service.
    # 
    def cdrom_service(id)
      TemplateCdromService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return cdrom_service(path)
      end
      return cdrom_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TemplateDiskService < Service
    
    COPY = [
      [:async, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :COPY
    
    # 
    # Copy the specified disk attached to the template to a specific storage domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the copy should be performed asynchronously.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [StorageDomain] :storage_domain 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def copy(opts = {})
      internal_action(:copy, nil, COPY, opts)
    end
    
    EXPORT = [
      [:async, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT
    
    # 
    # Executes the `export` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the export should be performed asynchronously.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [StorageDomain] :storage_domain 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export(opts = {})
      internal_action(:export, nil, EXPORT, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TemplateDiskAttachmentService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the details of the attachment.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [DiskAttachment]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:force, TrueClass].freeze,
      [:storage_domain, String].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the disk from the template. The disk will only be removed if there are other existing copies of the
    # disk on other storage domains.
    # 
    # A storage domain has to be specified to determine which of the copies should be removed (template disks can
    # have copies on multiple storage domains).
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :force 
    # @option opts [String] :storage_domain Specifies the identifier of the storage domain the image to be removed resides on.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TemplateDiskAttachmentsService < Service
    
    LIST = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the disks that are attached to the template.
    # 
    # The order of the returned list of attachments isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<DiskAttachment>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific attachment.
    # 
    # @param id [String] The identifier of the `attachment`.
    # 
    # @return [TemplateDiskAttachmentService] A reference to the `attachment` service.
    # 
    def attachment_service(id)
      TemplateDiskAttachmentService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return attachment_service(path)
      end
      return attachment_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TemplateDisksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disks of the template.
    # 
    # The order of the returned list of disks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified all the disks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `disk` service.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [TemplateDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      TemplateDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TemplateGraphicsConsoleService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets graphics console configuration of the template.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GraphicsConsole]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the graphics console from the template.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TemplateGraphicsConsolesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add new graphics console to the template.
    # 
    # @param console [GraphicsConsole] The `console` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GraphicsConsole]
    # 
    def add(console, opts = {})
      internal_add(console, GraphicsConsole, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all the configured graphics consoles of the template.
    # 
    # The order of the returned list of graphics consoles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of consoles to return. If not specified all the consoles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<GraphicsConsole>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific template graphics console.
    # 
    # @param id [String] The identifier of the `console`.
    # 
    # @return [TemplateGraphicsConsoleService] A reference to the `console` service.
    # 
    def console_service(id)
      TemplateGraphicsConsoleService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return console_service(path)
      end
      return console_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TemplateNicService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified network interface card attached to the template.
    # 
    # @param nic [Nic] The `nic` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def update(nic, opts = {})
      internal_update(nic, Nic, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TemplateNicsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a new network interface card to the template.
    # 
    # @param nic [Nic] The `nic` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def add(nic, opts = {})
      internal_add(nic, Nic, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of NICs of the template.
    # 
    # The order of the returned list of NICs isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of NICs to return. If not specified all the NICs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Nic>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `nic` service.
    # 
    # @param id [String] The identifier of the `nic`.
    # 
    # @return [TemplateNicService] A reference to the `nic` service.
    # 
    def nic_service(id)
      TemplateNicService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return nic_service(path)
      end
      return nic_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TemplateWatchdogService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the watchdog for the template identified by the given id.
    # 
    # @param watchdog [Watchdog] The `watchdog` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def update(watchdog, opts = {})
      internal_update(watchdog, Watchdog, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class TemplateWatchdogsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a watchdog to the template identified by the given id.
    # 
    # @param watchdog [Watchdog] The `watchdog` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def add(watchdog, opts = {})
      internal_add(watchdog, Watchdog, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of watchdogs.
    # 
    # The order of the returned list of watchdogs isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of watchdogs to return. If not specified all the watchdogs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Watchdog>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `watchdog` service.
    # 
    # @param id [String] The identifier of the `watchdog`.
    # 
    # @return [TemplateWatchdogService] A reference to the `watchdog` service.
    # 
    def watchdog_service(id)
      TemplateWatchdogService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return watchdog_service(path)
      end
      return watchdog_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class TemplatesService < Service
    
    ADD = [
      [:clone_permissions, TrueClass].freeze,
      [:seal, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new template.
    # 
    # This requires the `name` and `vm` elements. To identify the virtual machine use the `vm.id` or `vm.name`
    # attributes. For example, to create a template from a virtual machine with the identifier `123` send a request
    # like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/templates
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <template>
    #   <name>mytemplate</name>
    #   <vm id="123"/>
    # </template>
    # ----
    # 
    # Since version 4.3, in order to create virtual machine template from a snapshot send a request body like this:
    # 
    # [source,xml]
    # ----
    # <template>
    #   <name>mytemplate</name>
    #   <vm id="123">
    #     <snapshots>
    #       <snapshot id="456"/>
    #     </snapshots>
    #   </vm>
    # </template>
    # ----
    # 
    # The disks of the template can be customized, making some of their characteristics different from the disks of the
    # original virtual machine. To do so use the `vm.disk_attachments` attribute, specifying the identifier of the disk
    # of the original virtual machine and the characteristics that you want to change. For example, if the original
    # virtual machine has a disk with the identifier `456`, and, for that disk, you want to change the name to `mydisk`
    # the format to <<types/disk_format, _Copy On Write_>> and make it <<types/disk, sparse>>, send a request body like
    # this:
    # 
    # [source,xml]
    # ----
    # <template>
    #   <name>mytemplate</name>
    #   <vm id="123">
    #     <disk_attachments>
    #       <disk_attachment>
    #         <disk id="456">
    #           <name>mydisk</name>
    #           <format>cow</format>
    #           <sparse>true</sparse>
    #         </disk>
    #       </disk_attachment>
    #     </disk_attachments>
    #   </vm>
    # </template>
    # ----
    # 
    # The template can be created as a sub-version of an existing template. This requires the `name` and `vm` attributes
    # for the new template, and the `base_template` and `version_name` attributes for the new template version. The
    # `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
    # `template` section. Identify the virtual machine with the `id` or `name` attributes.
    # 
    # [source,xml]
    # ----
    # <template>
    #   <name>mytemplate</name>
    #   <vm id="123"/>
    #   <version>
    #     <base_template id="456"/>
    #     <version_name>mytemplate_001</version_name>
    #   </version>
    # </template>
    # ----
    # 
    # The destination storage domain of the template can be customized, in one of two ways:
    # 
    # 1. Globally, at the request level. The request must list the desired disk attachments to be created on the
    # storage domain. If the disk attachments are not listed, the global storage domain parameter will be ignored.
    # +
    # [source,xml]
    # ----
    # <template>
    #   <name>mytemplate</name>
    #   <storage_domain id="123"/>
    #   <vm id="456">
    #     <disk_attachments>
    #       <disk_attachment>
    #         <disk id="789">
    #           <format>cow</format>
    #           <sparse>true</sparse>
    #         </disk>
    #       </disk_attachment>
    #     </disk_attachments>
    #   </vm>
    # </template>
    # ----
    # 
    # 2. Per each disk attachment. Specify the desired storage domain for each disk attachment.
    # Specifying the global storage definition will override the storage domain per disk attachment specification.
    # +
    # [source,xml]
    # ----
    # <template>
    #   <name>mytemplate</name>
    #   <vm id="123">
    #     <disk_attachments>
    #       <disk_attachment>
    #         <disk id="456">
    #           <format>cow</format>
    #           <sparse>true</sparse>
    #           <storage_domains>
    #              <storage_domain id="789"/>
    #           </storage_domains>
    #         </disk>
    #       </disk_attachment>
    #     </disk_attachments>
    #   </vm>
    # </template>
    # ----
    # 
    # @param template [Template] The information about the template or template version.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the virtual machine should be copied to the template.
    #   
    #   If this optional parameter is provided, and its value is `true`, then the permissions of the virtual machine
    #   (only the direct ones, not the inherited ones) will be copied to the created template. For example, to create
    #   a template from the `myvm` virtual machine copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/templates?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <template>
    #     <name>mytemplate<name>
    #     <vm>
    #       <name>myvm<name>
    #     </vm>
    #   </template>
    #   ----
    # 
    # @option opts [Boolean] :seal Seals the template.
    #   
    #   If this optional parameter is provided and its value is `true`,
    #   then the template is sealed after creation.
    #   
    #   Sealing erases all host-specific configuration from the filesystem:
    #   SSH keys, UDEV rules, MAC addresses, system ID, hostname, and so on,
    #   thus making it easier to use the template to create multiple virtual
    #   machines without manual intervention.
    #   
    #   Currently, sealing is supported only for Linux operating systems.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Template]
    # 
    def add(template, opts = {})
      internal_add(template, Template, ADD, opts)
    end
    
    ADD_FROM_CONFIGURATION = [
      [:clone_permissions, TrueClass].freeze,
      [:seal, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_FROM_CONFIGURATION
    
    # 
    # Add a virtual machine template to the system from a configuration. Requires the configuration type, the configuration data, and the target cluster.
    # 
    # @param template [Template] The information about the template or template version.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the virtual machine should be copied to the template.
    #   
    #   If this optional parameter is provided, and its value is `true`, then the permissions of the virtual machine
    #   (only the direct ones, not the inherited ones) will be copied to the created template. For example, to create
    #   a template from the `myvm` virtual machine copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/templates?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <template>
    #     <name>mytemplate<name>
    #     <vm>
    #       <name>myvm<name>
    #     </vm>
    #   </template>
    #   ----
    # 
    # @option opts [Boolean] :seal Seals the template.
    #   
    #   If this optional parameter is provided and its value is `true`,
    #   then the template is sealed after creation.
    #   
    #   Sealing erases all host-specific configuration from the filesystem:
    #   SSH keys, UDEV rules, MAC addresses, system ID, hostname, and so on,
    #   thus making it easier to use the template to create multiple virtual
    #   machines without manual intervention.
    #   
    #   Currently, sealing is supported only for Linux operating systems.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Template]
    # 
    def add_from_configuration(template, opts = {})
      internal_add(template, Template, ADD_FROM_CONFIGURATION, opts)
    end
    
    ADD_FROM_VM = [
      [:clone_permissions, TrueClass].freeze,
      [:seal, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_FROM_VM
    
    # 
    # Add a virtual machine template to the system from an existing virtual machine.
    # 
    # @param template [Template] The information about the template or template version.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the virtual machine should be copied to the template.
    #   
    #   If this optional parameter is provided, and its value is `true`, then the permissions of the virtual machine
    #   (only the direct ones, not the inherited ones) will be copied to the created template. For example, to create
    #   a template from the `myvm` virtual machine copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/templates?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <template>
    #     <name>mytemplate<name>
    #     <vm>
    #       <name>myvm<name>
    #     </vm>
    #   </template>
    #   ----
    # 
    # @option opts [Boolean] :seal Seals the template.
    #   
    #   If this optional parameter is provided and its value is `true`,
    #   then the template is sealed after creation.
    #   
    #   Sealing erases all host-specific configuration from the filesystem:
    #   SSH keys, UDEV rules, MAC addresses, system ID, hostname, and so on,
    #   thus making it easier to use the template to create multiple virtual
    #   machines without manual intervention.
    #   
    #   Currently, sealing is supported only for Linux operating systems.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Template]
    # 
    def add_from_vm(template, opts = {})
      internal_add(template, Template, ADD_FROM_VM, opts)
    end
    
    ADD_FROM_VM_SNAPSHOT = [
      [:clone_permissions, TrueClass].freeze,
      [:seal, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_FROM_VM_SNAPSHOT
    
    # 
    # Add a virtual machine template to the system from a snapshot.
    # 
    # @param template [Template] The information about the template or template version.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the virtual machine should be copied to the template.
    #   
    #   If this optional parameter is provided, and its value is `true`, then the permissions of the virtual machine
    #   (only the direct ones, not the inherited ones) will be copied to the created template. For example, to create
    #   a template from the `myvm` virtual machine copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/templates?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <template>
    #     <name>mytemplate<name>
    #     <vm>
    #       <name>myvm<name>
    #     </vm>
    #   </template>
    #   ----
    # 
    # @option opts [Boolean] :seal Seals the template.
    #   
    #   If this optional parameter is provided and its value is `true`,
    #   then the template is sealed after creation.
    #   
    #   Sealing erases all host-specific configuration from the filesystem:
    #   SSH keys, UDEV rules, MAC addresses, system ID, hostname, and so on,
    #   thus making it easier to use the template to create multiple virtual
    #   machines without manual intervention.
    #   
    #   Currently, sealing is supported only for Linux operating systems.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Template]
    # 
    def add_from_vm_snapshot(template, opts = {})
      internal_add(template, Template, ADD_FROM_VM_SNAPSHOT, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of virtual machine templates.
    # 
    # For example:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/templates
    # ----
    # 
    # Will return the list of virtual machines and virtual machine templates.
    # 
    # The order of the returned list of templates is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of templates to return. If not specified, all the templates are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned templates.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Template>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific virtual machine template.
    # 
    # @param id [String] The identifier of the `template`.
    # 
    # @return [TemplateService] A reference to the `template` service.
    # 
    def template_service(id)
      TemplateService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return template_service(path)
      end
      return template_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class UnmanagedNetworkService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [UnmanagedNetwork]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class UnmanagedNetworksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of unmanaged networks of the host.
    # 
    # The order of the returned list of networks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of networks to return. If not specified all the networks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<UnmanagedNetwork>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `unmanaged_network` service.
    # 
    # @param id [String] The identifier of the `unmanaged_network`.
    # 
    # @return [UnmanagedNetworkService] A reference to the `unmanaged_network` service.
    # 
    def unmanaged_network_service(id)
      UnmanagedNetworkService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return unmanaged_network_service(path)
      end
      return unmanaged_network_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class UserService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the system user information.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/users/1234
    # ....
    # 
    # Will return the user information:
    # 
    # [source,xml]
    # ----
    # <user href="/ovirt-engine/api/users/1234" id="1234">
    #   <name>admin</name>
    #   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
    #   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
    #   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
    #   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
    #   <department></department>
    #   <domain_entry_id>23456</domain_entry_id>
    #   <email>user1@domain.com</email>
    #   <last_name>Lastname</last_name>
    #   <namespace>*</namespace>
    #   <principal>user1</principal>
    #   <user_name>user1@domain-authz</user_name>
    #   <domain href="/ovirt-engine/api/domains/45678" id="45678">
    #     <name>domain-authz</name>
    #   </domain>
    # </user>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [User]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the system user.
    # 
    # Usage:
    # 
    # ....
    # DELETE /ovirt-engine/api/users/1234
    # ....
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates information about the user.
    # 
    # Only the `user_options` field can be updated.
    # 
    # For example, to update user options:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/users/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <user>
    #    <user_options>
    #       <property>
    #          <name>test</name>
    #          <value>["any","JSON"]</value>
    #       </property>
    #    </user_options>
    # </user>
    # ----
    # 
    # @param user [User] The `user` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [User]
    # 
    def update(user, opts = {})
      internal_update(user, User, UPDATE, opts)
    end
    
    # 
    # List of event-subscriptions for this user.
    # 
    # @return [EventSubscriptionsService] A reference to `event_subscriptions` service.
    # 
    def event_subscriptions_service
      @event_subscriptions_service ||= EventSubscriptionsService.new(self, 'eventsubscriptions')
    end
    
    # 
    # Locates the `groups` service.
    # 
    # @return [DomainUserGroupsService] A reference to `groups` service.
    # 
    def groups_service
      @groups_service ||= DomainUserGroupsService.new(self, 'groups')
    end
    
    # 
    # Locates the `options` service.
    # 
    # @return [UserOptionsService] A reference to `options` service.
    # 
    def options_service
      @options_service ||= UserOptionsService.new(self, 'options')
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `roles` service.
    # 
    # @return [AssignedRolesService] A reference to `roles` service.
    # 
    def roles_service
      @roles_service ||= AssignedRolesService.new(self, 'roles')
    end
    
    # 
    # Locates the `ssh_public_keys` service.
    # 
    # @return [SshPublicKeysService] A reference to `ssh_public_keys` service.
    # 
    def ssh_public_keys_service
      @ssh_public_keys_service ||= SshPublicKeysService.new(self, 'sshpublickeys')
    end
    
    # 
    # Locates the `tags` service.
    # 
    # @return [AssignedTagsService] A reference to `tags` service.
    # 
    def tags_service
      @tags_service ||= AssignedTagsService.new(self, 'tags')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'eventsubscriptions'
        return event_subscriptions_service
      end
      if path.start_with?('eventsubscriptions/')
        return event_subscriptions_service.service(path[19..-1])
      end
      if path == 'groups'
        return groups_service
      end
      if path.start_with?('groups/')
        return groups_service.service(path[7..-1])
      end
      if path == 'options'
        return options_service
      end
      if path.start_with?('options/')
        return options_service.service(path[8..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'roles'
        return roles_service
      end
      if path.start_with?('roles/')
        return roles_service.service(path[6..-1])
      end
      if path == 'sshpublickeys'
        return ssh_public_keys_service
      end
      if path.start_with?('sshpublickeys/')
        return ssh_public_keys_service.service(path[14..-1])
      end
      if path == 'tags'
        return tags_service
      end
      if path.start_with?('tags/')
        return tags_service.service(path[5..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class UserOptionService < Service
    
    GET = [
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns a user profile property of type JSON.
    # 
    # Example request(for user with identifier `123` and option with identifier `456`):
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/users/123/options/456
    # ----
    # 
    # The result will be the following XML document:
    # 
    # [source,xml]
    # ----
    #   <user_option href="/ovirt-engine/api/users/123/options/456" id="456">
    #     <name>SomeName</name>
    #     <content>["any", "JSON"]</content>
    #     <user href="/ovirt-engine/api/users/123" id="123"/>
    #   </user_option>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [UserOption]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes an existing property of type JSON.
    # 
    # Example request(for user with identifier `123` and option with identifier `456`):
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/users/123/options/456
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Replaces an existing property of type JSON with a new one.
    # 
    # Example request(for user with identifier `123` and option with identifier `456`):
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/users/123/options/456
    # ----
    # 
    # Payload:
    # 
    # [source,xml]
    # ----
    # <user_option>
    #   <name>SomeName</name>
    #   <content>{"new" : "JSON"}</content>
    # </user_option>
    # ----
    # 
    # The result will be the following XML document:
    # 
    # [source,xml]
    # ----
    # <user_option href="/ovirt-engine/api/users/123/options/789" id="789">
    #   <name>SomeName</name>
    #   <content>{"new" : "JSON"}</content>
    #   <user href="/ovirt-engine/api/users/123" id="123"/>
    # </user_option>
    # ----
    # 
    # @param option [UserOption] The `option` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [UserOption]
    # 
    def update(option, opts = {})
      internal_update(option, UserOption, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class UserOptionsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new user profile property of type JSON.
    # 
    # Example request(for user with identifier `123`):
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/users/123/options
    # ----
    # 
    # Payload:
    # 
    # [source,xml]
    # ----
    #   <user_option>
    #     <name>SomeName</name>
    #     <content>["any", "JSON"]</content>
    #   </user_option>
    # ----
    # 
    # @param option [UserOption] The `option` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [UserOption]
    # 
    def add(option, opts = {})
      internal_add(option, UserOption, ADD, opts)
    end
    
    LIST = [
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns a list of user profile properties of type JSON.
    # 
    # Example request(for user with identifier `123`):
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/users/123/options
    # ----
    # 
    # The result will be the following XML document:
    # 
    # [source,xml]
    # ----
    # <user_options>
    #   <user_option href="/ovirt-engine/api/users/123/options/456" id="456">
    #     <name>SomeName</name>
    #     <content>["any", "JSON"]</content>
    #     <user href="/ovirt-engine/api/users/123" id="123"/>
    #   </user_option>
    # </user_options>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<UserOption>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `option` service.
    # 
    # @param id [String] The identifier of the `option`.
    # 
    # @return [UserOptionService] A reference to the `option` service.
    # 
    def option_service(id)
      UserOptionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return option_service(path)
      end
      return option_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class UsersService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add user from a directory service.
    # 
    # For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
    # like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/users
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <user>
    #   <user_name>myuser@myextension-authz</user_name>
    #   <domain>
    #     <name>myextension-authz</name>
    #   </domain>
    # </user>
    # ----
    # 
    # In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
    # by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
    # also `principal` parameter set to UPN of the user.
    # 
    # For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
    # authorization provider send a request body like this:
    # 
    # [source,xml]
    # ----
    # <user>
    #   <principal>myuser@mysubdomain.mydomain.com</principal>
    #   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
    #   <domain>
    #     <name>myextension-authz</name>
    #   </domain>
    # </user>
    # ----
    # 
    # @param user [User] The `user` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [User]
    # 
    def add(user, opts = {})
      internal_add(user, User, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all the users in the system.
    # 
    # Usage:
    # 
    # ....
    # GET /ovirt-engine/api/users
    # ....
    # 
    # Will return the list of users:
    # 
    # [source,xml]
    # ----
    # <users>
    #   <user href="/ovirt-engine/api/users/1234" id="1234">
    #     <name>admin</name>
    #     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
    #     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
    #     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
    #     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
    #     <domain_entry_id>23456</domain_entry_id>
    #     <namespace>*</namespace>
    #     <principal>user1</principal>
    #     <user_name>user1@domain-authz</user_name>
    #     <domain href="/ovirt-engine/api/domains/45678" id="45678">
    #       <name>domain-authz</name>
    #     </domain>
    #   </user>
    # </users>
    # ----
    # 
    # The order of the returned list of users isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of users to return. If not specified all the users are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned users.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<User>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `user` service.
    # 
    # @param id [String] The identifier of the `user`.
    # 
    # @return [UserService] A reference to the `user` service.
    # 
    def user_service(id)
      UserService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return user_service(path)
      end
      return user_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VirtualFunctionAllowedNetworkService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VirtualFunctionAllowedNetworksService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new `network`.
    # 
    # @param network [Network] The `network` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Network]
    # 
    def add(network, opts = {})
      internal_add(network, Network, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of networks.
    # 
    # The order of the returned list of networks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of networks to return. If not specified all the networks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Network>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `network` service.
    # 
    # @param id [String] The identifier of the `network`.
    # 
    # @return [VirtualFunctionAllowedNetworkService] A reference to the `network` service.
    # 
    def network_service(id)
      VirtualFunctionAllowedNetworkService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return network_service(path)
      end
      return network_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmService < MeasurableService
    
    AUTO_PIN_CPU_AND_NUMA_NODES = [
      [:async, TrueClass].freeze,
      [:optimize_cpu_settings, TrueClass].freeze,
    ].freeze
    
    private_constant :AUTO_PIN_CPU_AND_NUMA_NODES
    
    # 
    # Apply an automatic CPU and NUMA configuration on the VM.
    # 
    # An example for a request:
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/autopincpuandnumanodes
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <optimize_cpu_settings>true</optimize_cpu_settings>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the detach action should be performed asynchronously.
    # 
    # @option opts [Boolean] :optimize_cpu_settings Specifies how the auto CPU and NUMA configuration is applied.
    #   If set to true, will adjust the CPU topology to fit the VM pinned host hardware.
    #   Otherwise, it will use the VM CPU topology.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def auto_pin_cpu_and_numa_nodes(opts = {})
      internal_action(:autopincpuandnumanodes, nil, AUTO_PIN_CPU_AND_NUMA_NODES, opts)
    end
    
    CANCEL_MIGRATION = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :CANCEL_MIGRATION
    
    # 
    # This operation stops any migration of a virtual machine to another physical host.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/cancelmigration
    # ----
    # 
    # The cancel migration action does not take any action specific parameters;
    # therefore, the request body should contain an empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the migration should cancelled asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def cancel_migration(opts = {})
      internal_action(:cancelmigration, nil, CANCEL_MIGRATION, opts)
    end
    
    CLONE = [
      [:async, TrueClass].freeze,
      [:discard_snapshots, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
      [:vm, Vm].freeze,
    ].freeze
    
    private_constant :CLONE
    
    # 
    # Executes the `clone` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the clone should be performed asynchronously.
    # 
    # @option opts [Boolean] :discard_snapshots Use the `discard_snapshots` parameter when the virtual machine should be clone with its
    #   snapshots collapsed. Default is true.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain on which the virtual machines disks will be copied to.
    # 
    # @option opts [Vm] :vm 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def clone(opts = {})
      internal_action(:clone, nil, CLONE, opts)
    end
    
    COMMIT_SNAPSHOT = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :COMMIT_SNAPSHOT
    
    # 
    # Permanently restores the virtual machine to the state of the previewed snapshot.
    # 
    # See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the snapshots should be committed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def commit_snapshot(opts = {})
      internal_action(:commitsnapshot, nil, COMMIT_SNAPSHOT, opts)
    end
    
    DETACH = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :DETACH
    
    # 
    # Detaches a virtual machine from a pool.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/detach
    # ----
    # 
    # The detach action does not take any action specific parameters; therefore, the request body should contain an
    # empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the detach action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def detach(opts = {})
      internal_action(:detach, nil, DETACH, opts)
    end
    
    EXPORT = [
      [:async, TrueClass].freeze,
      [:discard_snapshots, TrueClass].freeze,
      [:exclusive, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT
    
    # 
    # Exports the virtual machine.
    # 
    # A virtual machine can be exported to an export domain.
    # For example, to export virtual machine `123` to the export domain `myexport`:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/export
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain>
    #     <name>myexport</name>
    #   </storage_domain>
    #   <exclusive>true</exclusive>
    #   <discard_snapshots>true</discard_snapshots>
    # </action>
    # ----
    # 
    # Since version 4.2 of the engine it is also possible to export a virtual machine as a virtual appliance (OVA).
    # For example, to export virtual machine `123` as an OVA file named `myvm.ova` that is placed in the directory `/home/ovirt/` on host `myhost`:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/export
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <host>
    #     <name>myhost</name>
    #   </host>
    #   <directory>/home/ovirt</directory>
    #   <filename>myvm.ova</filename>
    # </action>
    # ----
    # 
    # NOTE: Confirm that the export operation has completed before attempting any actions on the export domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the export should be performed asynchronously.
    # 
    # @option opts [Boolean] :discard_snapshots Use the `discard_snapshots` parameter when the virtual machine should be exported with all of its
    #   snapshots collapsed.
    # 
    # @option opts [Boolean] :exclusive Use the `exclusive` parameter when the virtual machine should be exported even if another copy of
    #   it already exists in the export domain (override).
    # 
    # @option opts [StorageDomain] :storage_domain The (export) storage domain to export the virtual machine to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export(opts = {})
      internal_action(:export, nil, EXPORT, opts)
    end
    
    FREEZE_FILESYSTEMS = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :FREEZE_FILESYSTEMS
    
    # 
    # Freezes virtual machine file systems.
    # 
    # This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
    # a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
    # manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
    # 
    # Example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/freezefilesystems
    # ----
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the freeze should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def freeze_filesystems(opts = {})
      internal_action(:freezefilesystems, nil, FREEZE_FILESYSTEMS, opts)
    end
    
    GET = [
      [:all_content, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:next_run, TrueClass].freeze,
      [:ovf_as_ova, TrueClass].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the description of the virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all of the attributes of the virtual machine should be included in the response.
    #   
    #   By default the following attributes are excluded:
    #   
    #   - `console`
    #   - `initialization.configuration.data` - The OVF document describing the virtual machine.
    #   - `rng_source`
    #   - `soundcard`
    #   - `virtio_scsi`
    #   
    #   For example, to retrieve the complete representation of the virtual machine '123':
    #   
    #   ....
    #   GET /ovirt-engine/api/vms/123?all_content=true
    #   ....
    #   
    #   NOTE: These attributes are not included by default as they reduce performance. These attributes are seldom used
    #   and require additional queries to the database. Only use this parameter when required as it will reduce performance.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Boolean] :next_run Indicates if the returned result describes the virtual machine as it is currently running or if describes
    #   the virtual machine with the modifications that have already been performed but that will only come into
    #   effect when the virtual machine is restarted. By default the value is `false`.
    #   
    #   If the parameter is included in the request, but without a value, it is assumed that the value is `true`. The
    #   the following request:
    #   
    #   [source]
    #   ----
    #   GET /vms/{vm:id};next_run
    #   ----
    #   
    #   Is equivalent to using the value `true`:
    #   
    #   [source]
    #   ----
    #   GET /vms/{vm:id};next_run=true
    #   ----
    # 
    # @option opts [Boolean] :ovf_as_ova Indicates if the results should expose the OVF as it appears in OVA files of that VM. The OVF document
    #   describing the virtual machine. This parameter will work only when all_content=True is set.
    #   The OVF will be presented in `initialization.configuration.data`.
    #   
    #   For example:
    #   [source]
    #   ----
    #   GET /vms/{vm:id}?all_content=true&ovf_as_ova=true
    #   ----
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    LOGON = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :LOGON
    
    # 
    # Initiates the automatic user logon to access a virtual machine from an external console.
    # 
    # This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
    # installed and the `ovirt-guest-agent` service to be running on the virtual machine.
    # 
    # Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
    # from an external console.
    # 
    # For example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/logon
    # ----
    # 
    # Request body:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the logon should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def logon(opts = {})
      internal_action(:logon, nil, LOGON, opts)
    end
    
    MAINTENANCE = [
      [:async, TrueClass].freeze,
      [:maintenance_enabled, TrueClass].freeze,
    ].freeze
    
    private_constant :MAINTENANCE
    
    # 
    # Sets the global maintenance mode on the hosted engine virtual machine.
    # 
    # This action has no effect on other virtual machines.
    # 
    # Example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/maintenance
    # ----
    # 
    # [source,xml]
    # ----
    # <action>
    #   <maintenance_enabled>true<maintenance_enabled/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the global maintenance action should be performed asynchronously.
    # 
    # @option opts [Boolean] :maintenance_enabled Indicates if global maintenance should be enabled or disabled.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def maintenance(opts = {})
      internal_action(:maintenance, nil, MAINTENANCE, opts)
    end
    
    MIGRATE = [
      [:async, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:force, TrueClass].freeze,
      [:host, Host].freeze,
      [:migrate_vms_in_affinity_closure, TrueClass].freeze,
    ].freeze
    
    private_constant :MIGRATE
    
    # 
    # Migrates a virtual machine to another physical host.
    # 
    # Example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/migrate
    # ----
    # 
    # To specify a specific host to migrate the virtual machine to:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the migration should be performed asynchronously.
    # 
    # @option opts [Cluster] :cluster Specifies the cluster the virtual machine should migrate to. This is an optional parameter. By default, the
    #   virtual machine is migrated to another host within the same cluster.
    #   
    #   WARNING: Live migration to another cluster is not supported. Strongly consider the target cluster's hardware
    #   architecture and network architecture before attempting a migration.
    # 
    # @option opts [Boolean] :force Specifies that the virtual machine should migrate even if the virtual machine is defined as non-migratable.
    #   This is an optional parameter. By default, it is set to `false`.
    # 
    # @option opts [Host] :host Specifies a specific host that the virtual machine should migrate to. This is an optional parameter. By default,
    #   the {engine-name} automatically selects a default host for migration within the same cluster. If an API user
    #   requires a specific host, the user can specify the host with either an `id` or `name` parameter.
    # 
    # @option opts [Boolean] :migrate_vms_in_affinity_closure Migrate also all other virtual machines in positive enforcing affinity groups with this virtual machine,
    #   that are running on the same host.
    #   
    #   The default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def migrate(opts = {})
      internal_action(:migrate, nil, MIGRATE, opts)
    end
    
    PREVIEW_SNAPSHOT = [
      [:async, TrueClass].freeze,
      [:disks, List].freeze,
      [:lease, StorageDomainLease].freeze,
      [:restore_memory, TrueClass].freeze,
      [:snapshot, Snapshot].freeze,
      [:vm, Vm].freeze,
    ].freeze
    
    private_constant :PREVIEW_SNAPSHOT
    
    # 
    # Temporarily restores the virtual machine to the state of a snapshot.
    # 
    # The snapshot is indicated with the `snapshot.id` parameter. It is restored temporarily, so that the content can
    # be inspected. Once that inspection is finished, the state of the virtual machine can be made permanent, using the
    # <<services/vm/methods/commit_snapshot, commit_snapshot>> method, or discarded using the
    # <<services/vm/methods/undo_snapshot, undo_snapshot>> method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the preview should be performed asynchronously.
    # 
    # @option opts [Array<Disk>] :disks Specify the disks included in the snapshot's preview.
    #   
    #   For each disk parameter, it is also required to specify its `image_id`.
    #   
    #   For example, to preview a snapshot with identifier `456` which includes a disk with identifier `111` and its
    #   `image_id` as `222`, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/vms/123/previewsnapshot
    #   ----
    #   
    #   Request body:
    #   
    #   [source,xml]
    #   ----
    #   <action>
    #     <disks>
    #       <disk id="111">
    #         <image_id>222</image_id>
    #       </disk>
    #     </disks>
    #     <snapshot id="456"/>
    #   </action>
    #   ----
    # 
    # @option opts [StorageDomainLease] :lease Specify the lease storage domain ID to use in the preview of the snapshot.
    #   If lease parameter is not passed, then the previewed snapshot lease storage domain will be used.
    #   If lease parameter is passed with empty storage domain parameter, then no lease will be used
    #   for the snapshot preview.
    #   If lease parameter is passed with storage domain parameter then the storage domain ID can be
    #   only one of the leases domain IDs that belongs to one of the virtual machine snapshots.
    #   This is an optional parameter, set by default to `null`
    # 
    # @option opts [Boolean] :restore_memory 
    # 
    # @option opts [Snapshot] :snapshot 
    # 
    # @option opts [Vm] :vm 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def preview_snapshot(opts = {})
      internal_action(:previewsnapshot, nil, PREVIEW_SNAPSHOT, opts)
    end
    
    REBOOT = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :REBOOT
    
    # 
    # Sends a reboot request to a virtual machine.
    # 
    # For example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/reboot
    # ----
    # 
    # The reboot action does not take any action specific parameters; therefore, the request body should contain an
    # empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # To reboot the VM even if a backup is running for it,
    # the action should include the 'force' element.
    # 
    # For example, to force reboot virtual machine `123`:
    # 
    # ----
    # POST /ovirt-engine/api/vms/123/reboot
    # ----
    # 
    # [source,xml]
    # ----
    # <action>
    #     <force>true</force>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the reboot should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the VM should be forcibly rebooted even
    #   if a backup is running for it.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reboot(opts = {})
      internal_action(:reboot, nil, REBOOT, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
      [:detach_only, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the virtual machine, including the virtual disks attached to it.
    # 
    # For example, to remove the virtual machine with identifier `123`:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vms/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Boolean] :detach_only Indicates if the attached virtual disks should be detached first and preserved instead of being removed.
    # @option opts [Boolean] :force Indicates if the virtual machine should be forcibly removed.
    #   
    #   Locked virtual machines and virtual machines with locked disk images
    #   cannot be removed without this flag set to true.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    REORDER_MAC_ADDRESSES = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REORDER_MAC_ADDRESSES
    
    # 
    # Executes the `reorder_mac_addresses` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reorder_mac_addresses(opts = {})
      internal_action(:reordermacaddresses, nil, REORDER_MAC_ADDRESSES, opts)
    end
    
    SHUTDOWN = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
      [:reason, String].freeze,
    ].freeze
    
    private_constant :SHUTDOWN
    
    # 
    # This operation sends a shutdown request to a virtual machine.
    # 
    # For example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/shutdown
    # ----
    # 
    # The shutdown action does not take any action specific parameters;
    # therefore, the request body should contain an empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # To shutdown the VM even if a backup is running for it,
    # the action should include the 'force' element.
    # 
    # For example, to force shutdown virtual machine `123`:
    # 
    # ----
    # POST /ovirt-engine/api/vms/123/shutdown
    # ----
    # 
    # [source,xml]
    # ----
    # <action>
    #     <force>true</force>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the shutdown should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the VM should be forcibly shutdown even
    #   if a backup is running for it.
    # 
    # @option opts [String] :reason The reason the virtual machine was stopped.
    #   Optionally set by user when shutting down the virtual machine.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def shutdown(opts = {})
      internal_action(:shutdown, nil, SHUTDOWN, opts)
    end
    
    START = [
      [:async, TrueClass].freeze,
      [:authorized_key, AuthorizedKey].freeze,
      [:filter, TrueClass].freeze,
      [:pause, TrueClass].freeze,
      [:use_cloud_init, TrueClass].freeze,
      [:use_ignition, TrueClass].freeze,
      [:use_initialization, TrueClass].freeze,
      [:use_sysprep, TrueClass].freeze,
      [:vm, Vm].freeze,
      [:volatile, TrueClass].freeze,
    ].freeze
    
    private_constant :START
    
    # 
    # Starts the virtual machine.
    # 
    # If the virtual environment is complete and the virtual machine contains all necessary components to function,
    # it can be started.
    # 
    # This example starts the virtual machine:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/start
    # ----
    # 
    # With a request body:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the start action should be performed asynchronously.
    # 
    # @option opts [AuthorizedKey] :authorized_key 
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [Boolean] :pause If set to `true`, start the virtual machine in paused mode. The default is `false`.
    # 
    # @option opts [Boolean] :use_cloud_init If set to `true`, the initialization type is set to _cloud-init_. The default value is `false`.
    #   See https://cloudinit.readthedocs.io/en/latest[this] for details.
    # 
    # @option opts [Boolean] :use_ignition If set to `true`, the initialization type is set to _Ignition_. The default value is `false`.
    #   See https://coreos.com/ignition/docs/latest/[this] for details.
    # 
    # @option opts [Boolean] :use_initialization If set to `true`, the initialization type is set by the VM's OS.
    #   Windows will set to _Sysprep_, Linux to _cloud-init_ and RedHat CoreOS to _Ignition_.
    #   If any of the initialization-types are explicitly set (useCloudInit, useSysprep or useIgnition),
    #   they will be prioritized and this flag will be ignored.
    #   The default value is `false`.
    # 
    # @option opts [Boolean] :use_sysprep If set to `true`, the initialization type is set to _Sysprep_. The default value is `false`.
    #   See https://en.wikipedia.org/wiki/Sysprep[this] for details.
    # 
    # @option opts [Vm] :vm The definition of the virtual machine for this specific run.
    #   
    #   For example:
    #   
    #   [source,xml]
    #   ----
    #   <action>
    #     <vm>
    #       <os>
    #         <boot>
    #           <devices>
    #             <device>cdrom</device>
    #           </devices>
    #         </boot>
    #       </os>
    #     </vm>
    #   </action>
    #   ----
    #   
    #   This will set the boot device to the CDROM only for this specific start. After the virtual machine is
    #   powered off, this definition will be reverted.
    # 
    # @option opts [Boolean] :volatile Indicates that this run configuration will be discarded even in the case of guest-initiated reboot.
    #   The default value is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def start(opts = {})
      internal_action(:start, nil, START, opts)
    end
    
    STOP = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
      [:reason, String].freeze,
    ].freeze
    
    private_constant :STOP
    
    # 
    # This operation forces a virtual machine to power-off.
    # 
    # For example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/stop
    # ----
    # 
    # The stop action does not take any action specific parameters;
    # therefore, the request body should contain an empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # To stop the VM even if a backup is running for it,
    # the action should include the 'force' element.
    # 
    # For example, to force stop virtual machine `123`:
    # 
    # ----
    # POST /ovirt-engine/api/vms/123/stop
    # ----
    # 
    # [source,xml]
    # ----
    # <action>
    #     <force>true</force>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the stop action should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the VM should be forcibly stop even
    #   if a backup is running for it.
    # 
    # @option opts [String] :reason The reason the virtual machine was stopped.
    #   Optionally set by user when shutting down the virtual machine.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def stop(opts = {})
      internal_action(:stop, nil, STOP, opts)
    end
    
    SUSPEND = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :SUSPEND
    
    # 
    # This operation saves the virtual machine state to disk and stops it.
    # Start a suspended virtual machine and restore the virtual machine state with the start action.
    # 
    # For example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/suspend
    # ----
    # 
    # The suspend action does not take any action specific parameters;
    # therefore, the request body should contain an empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the suspend action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def suspend(opts = {})
      internal_action(:suspend, nil, SUSPEND, opts)
    end
    
    THAW_FILESYSTEMS = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :THAW_FILESYSTEMS
    
    # 
    # Thaws virtual machine file systems.
    # 
    # This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
    # running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
    # with the API for virtual machines using OpenStack Volume (Cinder) disks.
    # 
    # Example:
    # 
    # [source]
    # ----
    # POST /api/vms/123/thawfilesystems
    # ----
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the thaw file systems action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def thaw_filesystems(opts = {})
      internal_action(:thawfilesystems, nil, THAW_FILESYSTEMS, opts)
    end
    
    TICKET = [
      [:async, TrueClass].freeze,
      [:ticket, Ticket].freeze,
    ].freeze
    
    private_constant :TICKET
    
    # 
    # Generates a time-sensitive authentication token for accessing a virtual machine's display.
    # 
    # For example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/ticket
    # ----
    # 
    # The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
    # 
    # The response specifies the actual ticket value and expiry used.
    # 
    # [source,xml]
    # ----
    # <action>
    #   <ticket>
    #     <value>abcd12345</value>
    #     <expiry>120</expiry>
    #   </ticket>
    # </action>
    # ----
    # 
    # [IMPORTANT]
    # ====
    # If the virtual machine is configured to support only one graphics protocol
    # then the generated authentication token will be valid for that protocol.
    # But if the virtual machine is configured to support multiple protocols,
    # VNC and SPICE, then the authentication token will only be valid for
    # the SPICE protocol.
    # 
    # In order to obtain an authentication token for a specific protocol, for
    # example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
    # service>>, which manages the graphics consoles of the virtual machine, by sending
    # a request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
    # ----
    # ====
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the generation of the ticket should be performed asynchronously.
    # 
    # @option opts [Ticket] :ticket 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def ticket(opts = {})
      internal_action(:ticket, :ticket, TICKET, opts)
    end
    
    EXPORT_TO_EXPORT_DOMAIN = [
      [:async, TrueClass].freeze,
      [:discard_snapshots, TrueClass].freeze,
      [:exclusive, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT_TO_EXPORT_DOMAIN
    
    # 
    # Exports a virtual machine to an export domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the export should be performed asynchronously.
    # 
    # @option opts [Boolean] :discard_snapshots Use the `discard_snapshots` parameter when the virtual machine should be exported with all of its
    #   snapshots collapsed.
    # 
    # @option opts [Boolean] :exclusive Use the `exclusive` parameter when the virtual machine should be exported even if another copy of
    #   it already exists in the export domain (override).
    # 
    # @option opts [StorageDomain] :storage_domain The (export) storage domain to export the virtual machine to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export_to_export_domain(opts = {})
      internal_action(:export, nil, EXPORT_TO_EXPORT_DOMAIN, opts)
    end
    
    EXPORT_TO_PATH_ON_HOST = [
      [:async, TrueClass].freeze,
      [:directory, String].freeze,
      [:discard_snapshots, TrueClass].freeze,
      [:exclusive, TrueClass].freeze,
      [:filename, String].freeze,
      [:host, Host].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT_TO_PATH_ON_HOST
    
    # 
    # Exports a virtual machine as an OVA file to a given path on a specified host.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the export should be performed asynchronously.
    # 
    # @option opts [String] :directory An absolute path of a directory on the host to generate the OVA file in.
    # 
    # @option opts [Boolean] :discard_snapshots Use the `discard_snapshots` parameter when the virtual machine should be exported with all of its
    #   snapshots collapsed.
    # 
    # @option opts [Boolean] :exclusive Use the `exclusive` parameter when the virtual machine should be exported even if another copy of
    #   it already exists in the export domain (override).
    # 
    # @option opts [String] :filename The name of the OVA file.
    #   
    #   This is an optional parameter, if it is not specified then the name of OVA file is determined according
    #   to the name of the virtual machine. It will conform the following pattern: "<virtual machine name>.ova".
    # 
    # @option opts [Host] :host The host to generate the OVA file on.
    # 
    # @option opts [StorageDomain] :storage_domain The (export) storage domain to export the virtual machine to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export_to_path_on_host(opts = {})
      internal_action(:export, nil, EXPORT_TO_PATH_ON_HOST, opts)
    end
    
    UNDO_SNAPSHOT = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UNDO_SNAPSHOT
    
    # 
    # Restores the virtual machine to the state it had before previewing the snapshot.
    # 
    # See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the undo snapshot action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def undo_snapshot(opts = {})
      internal_action(:undosnapshot, nil, UNDO_SNAPSHOT, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
      [:next_run, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the virtual machine in the system for the given virtual machine id.
    # 
    # @param vm [Vm] The `vm` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Boolean] :next_run Indicates if the update should be applied to the virtual machine immediately or if it should be applied only
    #   when the virtual machine is restarted. The default value is `false`, so by default changes are applied
    #   immediately.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def update(vm, opts = {})
      internal_update(vm, Vm, UPDATE, opts)
    end
    
    # 
    # List of scheduling labels assigned to this virtual machine.
    # 
    # @return [AssignedAffinityLabelsService] A reference to `affinity_labels` service.
    # 
    def affinity_labels_service
      @affinity_labels_service ||= AssignedAffinityLabelsService.new(self, 'affinitylabels')
    end
    
    # 
    # Locates the `applications` service.
    # 
    # @return [VmApplicationsService] A reference to `applications` service.
    # 
    def applications_service
      @applications_service ||= VmApplicationsService.new(self, 'applications')
    end
    
    # 
    # List of backups of this virtual machine.
    # 
    # @return [VmBackupsService] A reference to `backups` service.
    # 
    def backups_service
      @backups_service ||= VmBackupsService.new(self, 'backups')
    end
    
    # 
    # Locates the `cdroms` service.
    # 
    # @return [VmCdromsService] A reference to `cdroms` service.
    # 
    def cdroms_service
      @cdroms_service ||= VmCdromsService.new(self, 'cdroms')
    end
    
    # 
    # List of checkpoints of this virtual machine.
    # 
    # @return [VmCheckpointsService] A reference to `checkpoints` service.
    # 
    def checkpoints_service
      @checkpoints_service ||= VmCheckpointsService.new(self, 'checkpoints')
    end
    
    # 
    # List of disks attached to this virtual machine.
    # 
    # @return [DiskAttachmentsService] A reference to `disk_attachments` service.
    # 
    def disk_attachments_service
      @disk_attachments_service ||= DiskAttachmentsService.new(self, 'diskattachments')
    end
    
    # 
    # Locates the `graphics_consoles` service.
    # 
    # @return [VmGraphicsConsolesService] A reference to `graphics_consoles` service.
    # 
    def graphics_consoles_service
      @graphics_consoles_service ||= VmGraphicsConsolesService.new(self, 'graphicsconsoles')
    end
    
    # 
    # Locates the `host_devices` service.
    # 
    # @return [VmHostDevicesService] A reference to `host_devices` service.
    # 
    def host_devices_service
      @host_devices_service ||= VmHostDevicesService.new(self, 'hostdevices')
    end
    
    # 
    # Reference to the service that can show the applicable errata available on the virtual machine.
    # This information is taken from Katello.
    # 
    # @return [KatelloErrataService] A reference to `katello_errata` service.
    # 
    def katello_errata_service
      @katello_errata_service ||= KatelloErrataService.new(self, 'katelloerrata')
    end
    
    # 
    # Locates the `nics` service.
    # 
    # @return [VmNicsService] A reference to `nics` service.
    # 
    def nics_service
      @nics_service ||= VmNicsService.new(self, 'nics')
    end
    
    # 
    # Locates the `numa_nodes` service.
    # 
    # @return [VmNumaNodesService] A reference to `numa_nodes` service.
    # 
    def numa_nodes_service
      @numa_nodes_service ||= VmNumaNodesService.new(self, 'numanodes')
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `reported_devices` service.
    # 
    # @return [VmReportedDevicesService] A reference to `reported_devices` service.
    # 
    def reported_devices_service
      @reported_devices_service ||= VmReportedDevicesService.new(self, 'reporteddevices')
    end
    
    # 
    # Reference to the service that provides information about virtual machine user sessions.
    # 
    # @return [VmSessionsService] A reference to `sessions` service.
    # 
    def sessions_service
      @sessions_service ||= VmSessionsService.new(self, 'sessions')
    end
    
    # 
    # Locates the `snapshots` service.
    # 
    # @return [SnapshotsService] A reference to `snapshots` service.
    # 
    def snapshots_service
      @snapshots_service ||= SnapshotsService.new(self, 'snapshots')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the `tags` service.
    # 
    # @return [AssignedTagsService] A reference to `tags` service.
    # 
    def tags_service
      @tags_service ||= AssignedTagsService.new(self, 'tags')
    end
    
    # 
    # Locates the `watchdogs` service.
    # 
    # @return [VmWatchdogsService] A reference to `watchdogs` service.
    # 
    def watchdogs_service
      @watchdogs_service ||= VmWatchdogsService.new(self, 'watchdogs')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'affinitylabels'
        return affinity_labels_service
      end
      if path.start_with?('affinitylabels/')
        return affinity_labels_service.service(path[15..-1])
      end
      if path == 'applications'
        return applications_service
      end
      if path.start_with?('applications/')
        return applications_service.service(path[13..-1])
      end
      if path == 'backups'
        return backups_service
      end
      if path.start_with?('backups/')
        return backups_service.service(path[8..-1])
      end
      if path == 'cdroms'
        return cdroms_service
      end
      if path.start_with?('cdroms/')
        return cdroms_service.service(path[7..-1])
      end
      if path == 'checkpoints'
        return checkpoints_service
      end
      if path.start_with?('checkpoints/')
        return checkpoints_service.service(path[12..-1])
      end
      if path == 'diskattachments'
        return disk_attachments_service
      end
      if path.start_with?('diskattachments/')
        return disk_attachments_service.service(path[16..-1])
      end
      if path == 'graphicsconsoles'
        return graphics_consoles_service
      end
      if path.start_with?('graphicsconsoles/')
        return graphics_consoles_service.service(path[17..-1])
      end
      if path == 'hostdevices'
        return host_devices_service
      end
      if path.start_with?('hostdevices/')
        return host_devices_service.service(path[12..-1])
      end
      if path == 'katelloerrata'
        return katello_errata_service
      end
      if path.start_with?('katelloerrata/')
        return katello_errata_service.service(path[14..-1])
      end
      if path == 'nics'
        return nics_service
      end
      if path.start_with?('nics/')
        return nics_service.service(path[5..-1])
      end
      if path == 'numanodes'
        return numa_nodes_service
      end
      if path.start_with?('numanodes/')
        return numa_nodes_service.service(path[10..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'reporteddevices'
        return reported_devices_service
      end
      if path.start_with?('reporteddevices/')
        return reported_devices_service.service(path[16..-1])
      end
      if path == 'sessions'
        return sessions_service
      end
      if path.start_with?('sessions/')
        return sessions_service.service(path[9..-1])
      end
      if path == 'snapshots'
        return snapshots_service
      end
      if path.start_with?('snapshots/')
        return snapshots_service.service(path[10..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      if path == 'tags'
        return tags_service
      end
      if path.start_with?('tags/')
        return tags_service.service(path[5..-1])
      end
      if path == 'watchdogs'
        return watchdogs_service
      end
      if path.start_with?('watchdogs/')
        return watchdogs_service.service(path[10..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmApplicationService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the information about the application.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Application]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmApplicationsService < Service
    
    LIST = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns a list of applications installed in the virtual machine.
    # 
    # The order of the returned list of applications isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of applications to return. If not specified all the applications are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Application>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that provides information about a specific application.
    # 
    # @param id [String] The identifier of the `application`.
    # 
    # @return [VmApplicationService] A reference to the `application` service.
    # 
    def application_service(id)
      VmApplicationService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return application_service(path)
      end
      return application_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmBackupService < Service
    
    FINALIZE = [
    ].freeze
    
    private_constant :FINALIZE
    
    # 
    # Finalize the virtual machine backup entity.
    # 
    # End backup, unlock resources, and perform cleanups.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def finalize(opts = {})
      internal_action(:finalize, nil, FINALIZE, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns information about the virtual machine backup.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Backup]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # A reference to the service that lists the disks in backup.
    # 
    # @return [VmBackupDisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= VmBackupDisksService.new(self, 'disks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmBackupDiskService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the description of the disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmBackupDisksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disks in backup.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified, all the disks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A reference to the service that manages a specific disk.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [VmBackupDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      VmBackupDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmBackupsService < Service
    
    ADD = [
      [:require_consistency, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new backup entity to a virtual machine.
    # 
    # For example, to start a new incremental backup of a virtual machine
    # since checkpoint id `previous-checkpoint-uuid`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/backups
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <backup>
    #   <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
    #   <disks>
    #       <disk id="disk-uuid" />
    #       ...
    #   </disks>
    # </backup>
    # ----
    # 
    # The response body:
    # 
    # [source,xml]
    # ----
    # <backup id="backup-uuid">
    #     <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
    #     <to_checkpoint_id>new-checkpoint-uuid</to_checkpoint_id>
    #     <disks>
    #         <disk id="disk-uuid" />
    #         ...
    #         ...
    #     </disks>
    #     <status>initializing</status>
    #     <creation_date>
    # </backup>
    # ----
    # 
    # @param backup [Backup] The information about the virtual machine backup entity.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :require_consistency Indicates if the backup will fail if VM failed to freeze or not.
    #   
    #   If requireConsistency=True VM backup will fail in case of a
    #   failure to freeze the VM.
    #   
    #   The REST API call should look like this:
    #   
    #   ....
    #   POST /ovirt-engine/api/vms/123/backups?require_consistency=true
    #   ....
    #   
    #   The default value of the requireConsistency flag is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Backup]
    # 
    def add(backup, opts = {})
      internal_add(backup, Backup, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # The list of virtual machine backups.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of virtual machine backups to return. If not specified, all the virtual machine backups are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Backup>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific VM backup.
    # 
    # @param id [String] The identifier of the `backup`.
    # 
    # @return [VmBackupService] A reference to the `backup` service.
    # 
    def backup_service(id)
      VmBackupService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return backup_service(path)
      end
      return backup_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmCdromService < Service
    
    GET = [
      [:current, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the information about this CDROM device.
    # 
    # The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
    # and optionally the inserted disk.
    # 
    # If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
    # 
    # [source,xml]
    # ----
    # <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
    #   <file id="mycd.iso"/>
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    # </cdrom>
    # ----
    # 
    # If there is no disk inserted then the `file` attribute won't be reported:
    # 
    # [source,xml]
    # ----
    # <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    # </cdrom>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :current Indicates if the operation should return the information for the currently running virtual machine. This
    #   parameter is optional, and the default value is `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cdrom]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    UPDATE = [
      [:current, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the information about this CDROM device.
    # 
    # It allows to change or eject the disk by changing the value of the `file` attribute.
    # For example, to insert or change the disk send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
    # ----
    # 
    # The body should contain the new value for the `file` attribute:
    # 
    # [source,xml]
    # ----
    # <cdrom>
    #   <file id="mycd.iso"/>
    # </cdrom>
    # ----
    # 
    # The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
    # attached ISO storage domain.
    # 
    # To eject the disk use a `file` with an empty `id`:
    # 
    # [source,xml]
    # ----
    # <cdrom>
    #   <file id=""/>
    # </cdrom>
    # ----
    # 
    # By default the above operations change permanently the disk that will be visible to the virtual machine
    # after the next boot, but they don't have any effect on the currently running virtual machine. If you want
    # to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
    # For example, to eject the current disk send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <cdrom>
    #   <file id=""/>
    # </cdrom>
    # ----
    # 
    # IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
    # effect after the virtual machine is rebooted.
    # 
    # @param cdrom [Cdrom] The information about the CDROM device.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :current Indicates if the update should apply to the currently running virtual machine, or to the virtual machine
    #   after the next boot. This parameter is optional, and the default value is `false`, which means that by
    #   default the update will have effect only after the next boot.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cdrom]
    # 
    def update(cdrom, opts = {})
      internal_update(cdrom, Cdrom, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmCdromsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a cdrom to a virtual machine identified by the given id.
    # 
    # @param cdrom [Cdrom] The `cdrom` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Cdrom]
    # 
    def add(cdrom, opts = {})
      internal_add(cdrom, Cdrom, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of CDROM devices of the virtual machine.
    # 
    # The order of the returned list of CD-ROM devices isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of CDROMs to return. If not specified all the CDROMs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Cdrom>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific CDROM device.
    # 
    # @param id [String] The identifier of the `cdrom`.
    # 
    # @return [VmCdromService] A reference to the `cdrom` service.
    # 
    def cdrom_service(id)
      VmCdromService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return cdrom_service(path)
      end
      return cdrom_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmCheckpointService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns information about the virtual machine checkpoint.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Checkpoint]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the virtual machine checkpoint entity.
    # 
    # Remove the checkpoint from libvirt and the database.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # A reference to the service that lists the disks in checkpoint.
    # 
    # @return [VmCheckpointDisksService] A reference to `disks` service.
    # 
    def disks_service
      @disks_service ||= VmCheckpointDisksService.new(self, 'disks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'disks'
        return disks_service
      end
      if path.start_with?('disks/')
        return disks_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmCheckpointDiskService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the description of the disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmCheckpointDisksService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disks in checkpoint.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified, all the disks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # A reference to the service that manages a specific disk.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [VmCheckpointDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      VmCheckpointDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmCheckpointsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # The list of virtual machine checkpoints.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of virtual machine checkpoints to return.
    #   If not specified, all the virtual machine checkpoints are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Checkpoint>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific VM checkpoint.
    # 
    # @param id [String] The identifier of the `checkpoint`.
    # 
    # @return [VmCheckpointService] A reference to the `checkpoint` service.
    # 
    def checkpoint_service(id)
      VmCheckpointService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return checkpoint_service(path)
      end
      return checkpoint_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmDiskService < MeasurableService
    
    ACTIVATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :ACTIVATE
    
    # 
    # Executes the `activate` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the activation should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def activate(opts = {})
      internal_action(:activate, nil, ACTIVATE, opts)
    end
    
    DEACTIVATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :DEACTIVATE
    
    # 
    # Executes the `deactivate` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the deactivation should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def deactivate(opts = {})
      internal_action(:deactivate, nil, DEACTIVATE, opts)
    end
    
    EXPORT = [
      [:async, TrueClass].freeze,
      [:filter, TrueClass].freeze,
    ].freeze
    
    private_constant :EXPORT
    
    # 
    # Executes the `export` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the export should be performed asynchronously.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export(opts = {})
      internal_action(:export, nil, EXPORT, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    MOVE = [
      [:async, TrueClass].freeze,
      [:filter, TrueClass].freeze,
    ].freeze
    
    private_constant :MOVE
    
    # 
    # Executes the `move` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the move should be performed asynchronously.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def move(opts = {})
      internal_action(:move, nil, MOVE, opts)
    end
    
    REDUCE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REDUCE
    
    # 
    # Reduces the size of the disk image.
    # 
    # Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
    # This is applicable for floating disks and disks attached to non-running virtual machines.
    # There is no need to specify the size as the optimal size is calculated automatically.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reduce(opts = {})
      internal_action(:reduce, nil, REDUCE, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Detach the disk from the virtual machine.
    # 
    # NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
    # version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
    # method of the top level disk service>>.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the `disk`.
    # 
    # @param disk [Disk] The `disk` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def update(disk, opts = {})
      internal_update(disk, Disk, UPDATE, opts)
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmDisksService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a new `disk`.
    # 
    # @param disk [Disk] The `disk` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def add(disk, opts = {})
      internal_add(disk, Disk, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of disks of the virtual machine.
    # 
    # The order of the returned list of disks isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of disks to return. If not specified all the disks are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Disk>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `disk` service.
    # 
    # @param id [String] The identifier of the `disk`.
    # 
    # @return [VmDiskService] A reference to the `disk` service.
    # 
    def disk_service(id)
      VmDiskService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return disk_service(path)
      end
      return disk_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmGraphicsConsoleService < Service
    
    GET = [
      [:current, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the graphics console configuration of the virtual machine.
    # 
    # IMPORTANT: By default, when the `current` parameter is not specified, the data returned
    # corresponds to the next execution of the virtual machine. In the current implementation of
    # the system this means that the `address` and `port` attributes will not be populated because
    # the system does not know what address and port will be used for the next execution. Since in most
    # cases those attributes are needed, it is strongly advised to aways explicitly include the
    # `current` parameter with the value `true`.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :current Specifies if the data returned should correspond to the next execution of
    #   the virtual machine, or to the current execution.
    #   
    #   IMPORTANT: The `address` and `port` attributes will not be populated unless the value is
    #   `true`.
    #   
    #   For example, to get data for the current execution of the virtual machine, including the
    #   `address` and `port` attributes, send a request like this:
    #   
    #   [source]
    #   ----
    #   GET /ovit-engine/api/vms/123/graphicsconsoles/456?current=true
    #   ----
    #   
    #   The default value is `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GraphicsConsole]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    PROXY_TICKET = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :PROXY_TICKET
    
    # 
    # Executes the `proxy_ticket` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the generation of the ticket should be performed asynchronously.
    # 
    # @option opts [ProxyTicket] :proxy_ticket 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def proxy_ticket(opts = {})
      internal_action(:proxyticket, :proxy_ticket, PROXY_TICKET, opts)
    end
    
    REMOTE_VIEWER_CONNECTION_FILE = [
    ].freeze
    
    private_constant :REMOTE_VIEWER_CONNECTION_FILE
    
    # 
    # Generates the file which is compatible with `remote-viewer` client.
    # 
    # Use the following request to generate remote viewer connection file of the graphics console.
    # Note that this action generates the file only if virtual machine is running.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
    # ----
    # 
    # The `remoteviewerconnectionfile` action does not take any action specific parameters,
    # so the request body should contain an empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # The response contains the file, which can be used with `remote-viewer` client.
    # 
    # [source,xml]
    # ----
    # <action>
    #   <remote_viewer_connection_file>
    #     [virt-viewer]
    #     type=spice
    #     host=192.168.1.101
    #     port=-1
    #     password=123456789
    #     delete-this-file=1
    #     fullscreen=0
    #     toggle-fullscreen=shift+f11
    #     release-cursor=shift+f12
    #     secure-attention=ctrl+alt+end
    #     tls-port=5900
    #     enable-smartcard=0
    #     enable-usb-autoshare=0
    #     usb-filter=null
    #     tls-ciphers=DEFAULT
    #     host-subject=O=local,CN=example.com
    #     ca=...
    #   </remote_viewer_connection_file>
    # </action>
    # ----
    # 
    # E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
    # oVirt Python SDK as follows:
    # 
    # [source,python]
    # ----
    # # Find the virtual machine:
    # vm = vms_service.list(search='name=myvm')[0]
    # 
    # # Locate the service that manages the virtual machine, as that is where
    # # the locators are defined:
    # vm_service = vms_service.vm_service(vm.id)
    # 
    # # Find the graphic console of the virtual machine:
    # graphics_consoles_service = vm_service.graphics_consoles_service()
    # graphics_console = graphics_consoles_service.list()[0]
    # 
    # # Generate the remote viewer connection file:
    # console_service = graphics_consoles_service.console_service(graphics_console.id)
    # remote_viewer_connection_file = console_service.remote_viewer_connection_file()
    # 
    # # Write the content to file "/tmp/remote_viewer_connection_file.vv"
    # path = "/tmp/remote_viewer_connection_file.vv"
    # with open(path, "w") as f:
    #     f.write(remote_viewer_connection_file)
    # ----
    # 
    # When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
    # as follows:
    # 
    # [source,bash]
    # ----
    # #!/bin/sh -ex
    # 
    # remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :remote_viewer_connection_file Contains the file which is compatible with `remote-viewer` client.
    #   
    #   User can use the content of this attribute to create a file, which can be passed to `remote-viewer` client to
    #   connect to virtual machine graphic console.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remote_viewer_connection_file(opts = {})
      internal_action(:remoteviewerconnectionfile, :remote_viewer_connection_file, REMOTE_VIEWER_CONNECTION_FILE, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the graphics console from the virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    TICKET = [
      [:ticket, Ticket].freeze,
    ].freeze
    
    private_constant :TICKET
    
    # 
    # Generates a time-sensitive authentication token for accessing this virtual machine's console.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
    # ----
    # 
    # The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
    # 
    # In any case, the response specifies the actual ticket value and expiry used.
    # 
    # [source,xml]
    # ----
    # <action>
    #   <ticket>
    #     <value>abcd12345</value>
    #     <expiry>120</expiry>
    #   </ticket>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Ticket] :ticket The generated ticket that can be used to access this console.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def ticket(opts = {})
      internal_action(:ticket, :ticket, TICKET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmGraphicsConsolesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add new graphics console to the virtual machine.
    # 
    # @param console [GraphicsConsole] The `console` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GraphicsConsole]
    # 
    def add(console, opts = {})
      internal_add(console, GraphicsConsole, ADD, opts)
    end
    
    LIST = [
      [:current, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all the configured graphics consoles of the virtual machine.
    # 
    # IMPORTANT: By default, when the `current` parameter is not specified, the data returned
    # corresponds to the next execution of the virtual machine. In the current implementation of
    # the system this means that the `address` and `port` attributes will not be populated because
    # the system does not know what address and port will be used for the next execution. Since in most
    # cases those attributes are needed, it is strongly advised to aways explicitly include the
    # `current` parameter with the value `true`.
    # 
    # The order of the returned list of graphics consoles is not guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :current Specifies if the data returned should correspond to the next execution of
    #   the virtual machine, or to the current execution.
    #   
    #   IMPORTANT: The `address` and `port` attributes will not be populated unless the value is
    #   `true`.
    #   
    #   For example, to get data for the current execution of the virtual machine, including the
    #   `address` and `port` attributes, send a request like this:
    #   
    #   [source]
    #   ----
    #   GET /ovirt-engine/api/vms/123/graphicsconsoles?current=true
    #   ----
    #   
    #   The default value is `false`.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of consoles to return. If not specified all the consoles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<GraphicsConsole>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific virtual machine graphics console.
    # 
    # @param id [String] The identifier of the `console`.
    # 
    # @return [VmGraphicsConsoleService] A reference to the `console` service.
    # 
    def console_service(id)
      VmGraphicsConsoleService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return console_service(path)
      end
      return console_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmHostDeviceService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieve information about particular host device attached to given virtual machine.
    # 
    # Example:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/vms/123/hostdevices/456
    # ----
    # 
    # [source,xml]
    # ----
    # <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
    #   <name>pci_0000_04_00_0</name>
    #   <capability>pci</capability>
    #   <iommu_group>30</iommu_group>
    #   <placeholder>true</placeholder>
    #   <product id="0x13ba">
    #     <name>GM107GL [Quadro K2200]</name>
    #   </product>
    #   <vendor id="0x10de">
    #     <name>NVIDIA Corporation</name>
    #   </vendor>
    #   <host href="/ovirt-engine/api/hosts/543" id="543"/>
    #   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
    #     <name>pci_0000_00_03_0</name>
    #   </parent_device>
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    # </host_device>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [HostDevice]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the attachment of this host device from given virtual machine.
    # 
    # NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
    # in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
    # automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
    # group are detached).
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vms/123/hostdevices/456
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmHostDevicesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Attach target device to given virtual machine.
    # 
    # Example:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/hostdevices
    # ----
    # 
    # With request body of type <<types/host_device,HostDevice>>, for example
    # 
    # [source,xml]
    # ----
    # <host_device id="123" />
    # ----
    # 
    # NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
    # to *exactly* one host. The device ID is then taken relative to this host.
    # 
    # NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
    # devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
    # attribute of the <<types/host_device,HostDevice>> type set to `true`.
    # 
    # In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
    # for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
    # 
    # @param device [HostDevice] The host device to be attached to given virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [HostDevice]
    # 
    def add(device, opts = {})
      internal_add(device, HostDevice, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List the host devices assigned to given virtual machine.
    # 
    # The order of the returned list of devices isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of devices to return. If not specified all the devices are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<HostDevice>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific host device attached to given virtual machine.
    # 
    # @param id [String] The identifier of the `device`.
    # 
    # @return [VmHostDeviceService] A reference to the `device` service.
    # 
    def device_service(id)
      VmHostDeviceService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return device_service(path)
      end
      return device_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmNicService < MeasurableService
    
    ACTIVATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :ACTIVATE
    
    # 
    # Executes the `activate` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the activation should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def activate(opts = {})
      internal_action(:activate, nil, ACTIVATE, opts)
    end
    
    DEACTIVATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :DEACTIVATE
    
    # 
    # Executes the `deactivate` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the deactivation should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def deactivate(opts = {})
      internal_action(:deactivate, nil, DEACTIVATE, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the NIC.
    # 
    # For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vms/123/nics/456
    # ----
    # 
    # [IMPORTANT]
    # ====
    # The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
    # Example operating systems include:
    # 
    # - Red Hat Enterprise Linux 6
    # - Red Hat Enterprise Linux 5
    # - Windows Server 2008 and
    # - Windows Server 2003
    # ====
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the NIC.
    # 
    # For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
    # like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/vms/123/nics/456
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <nic>
    #   <name>mynic</name>
    #   <interface>e1000</interface>
    #   <vnic_profile id='789'/>
    # </nic>
    # ----
    # 
    # [IMPORTANT]
    # ====
    # The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
    # Example operating systems include:
    # 
    # - Red Hat Enterprise Linux 6
    # - Red Hat Enterprise Linux 5
    # - Windows Server 2008 and
    # - Windows Server 2003
    # ====
    # 
    # @param nic [Nic] The `nic` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def update(nic, opts = {})
      internal_update(nic, Nic, UPDATE, opts)
    end
    
    # 
    # Reference to the service that manages the network filter parameters of the NIC.
    # 
    # A single top-level network filter may assigned to the NIC by the NIC's <<types/vnic_profile,vNIC Profile>>.
    # 
    # @return [NicNetworkFilterParametersService] A reference to `network_filter_parameters` service.
    # 
    def network_filter_parameters_service
      @network_filter_parameters_service ||= NicNetworkFilterParametersService.new(self, 'networkfilterparameters')
    end
    
    # 
    # Locates the `reported_devices` service.
    # 
    # @return [VmReportedDevicesService] A reference to `reported_devices` service.
    # 
    def reported_devices_service
      @reported_devices_service ||= VmReportedDevicesService.new(self, 'reporteddevices')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'networkfilterparameters'
        return network_filter_parameters_service
      end
      if path.start_with?('networkfilterparameters/')
        return network_filter_parameters_service.service(path[24..-1])
      end
      if path == 'reporteddevices'
        return reported_devices_service
      end
      if path.start_with?('reporteddevices/')
        return reported_devices_service.service(path[16..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmNicsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds a NIC to the virtual machine.
    # 
    # The following example adds to the virtual machine `123` a network interface named `mynic` using `virtio` and the
    # NIC profile `456`.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/nics
    # ----
    # 
    # [source,xml]
    # ----
    # <nic>
    #   <name>mynic</name>
    #   <interface>virtio</interface>
    #   <vnic_profile id="456"/>
    # </nic>
    # ----
    # 
    # The following example sends that request using `curl`:
    # 
    # [source,bash]
    # ----
    # curl \
    # --request POST \
    # --header "Version: 4" \
    # --header "Content-Type: application/xml" \
    # --header "Accept: application/xml" \
    # --user "admin@internal:mypassword" \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --data '
    # <nic>
    #   <name>mynic</name>
    #   <interface>virtio</interface>
    #   <vnic_profile id="456"/>
    # </nic>
    # ' \
    # https://myengine.example.com/ovirt-engine/api/vms/123/nics
    # ----
    # 
    # [IMPORTANT]
    # ====
    # The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
    # Example operating systems include:
    # 
    # - Red Hat Enterprise Linux 6
    # - Red Hat Enterprise Linux 5
    # - Windows Server 2008 and
    # - Windows Server 2003
    # ====
    # 
    # @param nic [Nic] The `nic` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Nic]
    # 
    def add(nic, opts = {})
      internal_add(nic, Nic, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of NICs of the virtual machine.
    # 
    # The order of the returned list of NICs isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of NICs to return. If not specified all the NICs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Nic>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `nic` service.
    # 
    # @param id [String] The identifier of the `nic`.
    # 
    # @return [VmNicService] A reference to the `nic` service.
    # 
    def nic_service(id)
      VmNicService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return nic_service(path)
      end
      return nic_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmNumaNodeService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VirtualNumaNode]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a virtual NUMA node.
    # 
    # An example of removing a virtual NUMA node:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vms/123/numanodes/456
    # ----
    # 
    # NOTE: It's required to remove the numa nodes from the highest index
    # first.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates a virtual NUMA node.
    # 
    # An example of pinning a virtual NUMA node to a physical NUMA node on the host:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/vms/123/numanodes/456
    # ----
    # 
    # The request body should contain the following:
    # 
    # [source,xml]
    # ----
    # <vm_numa_node>
    #   <numa_node_pins>
    #     <numa_node_pin>
    #       <index>0</index>
    #     </numa_node_pin>
    #   </numa_node_pins>
    # </vm_numa_node>
    # ----
    # 
    # @param node [VirtualNumaNode] The `node` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VirtualNumaNode]
    # 
    def update(node, opts = {})
      internal_update(node, VirtualNumaNode, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmNumaNodesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new virtual NUMA node for the virtual machine.
    # 
    # An example of creating a NUMA node:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
    # Accept: application/xml
    # Content-type: application/xml
    # ----
    # The request body can contain the following:
    # [source,xml]
    # ----
    # <vm_numa_node>
    #   <cpu>
    #     <cores>
    #       <core>
    #         <index>0</index>
    #       </core>
    #     </cores>
    #   </cpu>
    #   <index>0</index>
    #   <memory>1024</memory>
    #   <numa_tune_mode>strict</numa_tune_mode>
    # </vm_numa_node>
    # ----
    # 
    # @param node [VirtualNumaNode] The `node` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VirtualNumaNode]
    # 
    def add(node, opts = {})
      internal_add(node, VirtualNumaNode, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists virtual NUMA nodes of a virtual machine.
    # 
    # The order of the returned list of NUMA nodes isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of nodes to return. If not specified all the nodes are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<VirtualNumaNode>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `node` service.
    # 
    # @param id [String] The identifier of the `node`.
    # 
    # @return [VmNumaNodeService] A reference to the `node` service.
    # 
    def node_service(id)
      VmNumaNodeService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return node_service(path)
      end
      return node_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmPoolService < Service
    
    ALLOCATE_VM = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :ALLOCATE_VM
    
    # 
    # This operation allocates a virtual machine in the virtual machine pool.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vmpools/123/allocatevm
    # ----
    # 
    # The allocate virtual machine action does not take any action specific parameters, so the request body should
    # contain an empty `action`:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the allocation should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def allocate_vm(opts = {})
      internal_action(:allocatevm, nil, ALLOCATE_VM, opts)
    end
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get the virtual machine pool.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/vmpools/123
    # ----
    # 
    # You will get a XML response like that one:
    # [source,xml]
    # ----
    # <vm_pool id="123">
    #   <actions>...</actions>
    #   <name>MyVmPool</name>
    #   <description>MyVmPool description</description>
    #   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
    #   <max_user_vms>1</max_user_vms>
    #   <prestarted_vms>0</prestarted_vms>
    #   <size>100</size>
    #   <stateful>false</stateful>
    #   <type>automatic</type>
    #   <use_latest_template_version>false</use_latest_template_version>
    #   <cluster id="123"/>
    #   <template id="123"/>
    #   <vm id="123">...</vm>
    #   ...
    # </vm_pool>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VmPool]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a virtual machine pool.
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vmpools/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the virtual machine pool.
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/vmpools/123
    # ----
    # 
    # The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
    # attributes can be updated after the virtual machine pool has been
    # created.
    # 
    # [source,xml]
    # ----
    # <vmpool>
    #   <name>VM_Pool_B</name>
    #   <description>Virtual Machine Pool B</description>
    #   <size>3</size>
    #   <prestarted_vms>1</size>
    #   <max_user_vms>2</size>
    # </vmpool>
    # ----
    # 
    # @param pool [VmPool] The virtual machine pool that is being updated.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VmPool]
    # 
    def update(pool, opts = {})
      internal_update(pool, VmPool, UPDATE, opts)
    end
    
    # 
    # Reference to a service managing the virtual machine pool assigned permissions.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmPoolsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new virtual machine pool.
    # 
    # A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
    # `id` or `name` nested attributes:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vmpools
    # ----
    # 
    # With the following body:
    # 
    # [source,xml]
    # ----
    # <vmpool>
    #   <name>mypool</name>
    #   <cluster id="123"/>
    #   <template id="456"/>
    # </vmpool>
    # ----
    # 
    # @param pool [VmPool] Pool to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VmPool]
    # 
    def add(pool, opts = {})
      internal_add(pool, VmPool, ADD, opts)
    end
    
    LIST = [
      [:case_sensitive, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Get a list of available virtual machines pools.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/vmpools
    # ----
    # 
    # You will receive the following response:
    # 
    # [source,xml]
    # ----
    # <vm_pools>
    #   <vm_pool id="123">
    #     ...
    #   </vm_pool>
    #   ...
    # </vm_pools>
    # ----
    # 
    # The order of the returned list of pools is guaranteed only if the `sortby` clause is included in the
    # `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of pools to return. If this value is not specified, all of the pools are returned.
    # 
    # @option opts [String] :search A query string used to restrict the returned pools.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<VmPool>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific virtual machine pool.
    # 
    # @param id [String] The identifier of the `pool`.
    # 
    # @return [VmPoolService] A reference to the `pool` service.
    # 
    def pool_service(id)
      VmPoolService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return pool_service(path)
      end
      return pool_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmReportedDeviceService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ReportedDevice]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmReportedDevicesService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of reported devices of the virtual machine.
    # 
    # The order of the returned list of devices isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of devices to return. If not specified all the devices are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<ReportedDevice>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `reported_device` service.
    # 
    # @param id [String] The identifier of the `reported_device`.
    # 
    # @return [VmReportedDeviceService] A reference to the `reported_device` service.
    # 
    def reported_device_service(id)
      VmReportedDeviceService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return reported_device_service(path)
      end
      return reported_device_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmSessionService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Session]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmSessionsService < Service
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Lists all user sessions for this virtual machine.
    # 
    # For example, to retrieve the session information for virtual machine `123` send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/vms/123/sessions
    # ----
    # 
    # The response body will contain something like this:
    # 
    # [source,xml]
    # ----
    # <sessions>
    #   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
    #     <console_user>true</console_user>
    #     <ip>
    #       <address>192.168.122.1</address>
    #     </ip>
    #     <user href="/ovirt-engine/api/users/789" id="789"/>
    #     <vm href="/ovirt-engine/api/vms/123" id="123"/>
    #   </session>
    #   ...
    # </sessions>
    # ----
    # 
    # The order of the returned list of sessions isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of sessions to return. If not specified all the sessions are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Session>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the service that manages a specific session.
    # 
    # @param id [String] The identifier of the `session`.
    # 
    # @return [VmSessionService] A reference to the `session` service.
    # 
    def session_service(id)
      VmSessionService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return session_service(path)
      end
      return session_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmWatchdogService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the information about the watchdog.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the watchdog from the virtual machine.
    # 
    # For example, to remove a watchdog from a virtual machine, send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the information about the watchdog.
    # 
    # You can update the information using `action` and `model` elements.
    # 
    # For example, to update a watchdog, send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/vms/123/watchdogs
    # <watchdog>
    #   <action>reset</action>
    # </watchdog>
    # ----
    # 
    # with response body:
    # 
    # [source,xml]
    # ----
    # <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    #   <action>reset</action>
    #   <model>i6300esb</model>
    # </watchdog>
    # ----
    # 
    # @param watchdog [Watchdog] The information about the watchdog.
    #   
    #   The request data must contain at least one of `model` and `action`
    #   elements. The response data contains complete information about the
    #   updated watchdog.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def update(watchdog, opts = {})
      internal_update(watchdog, Watchdog, UPDATE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VmWatchdogsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Adds new watchdog to the virtual machine.
    # 
    # For example, to add a watchdog to a virtual machine, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/vms/123/watchdogs
    # <watchdog>
    #   <action>poweroff</action>
    #   <model>i6300esb</model>
    # </watchdog>
    # ----
    # 
    # with response body:
    # 
    # [source,xml]
    # ----
    # <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
    #   <vm href="/ovirt-engine/api/vms/123" id="123"/>
    #   <action>poweroff</action>
    #   <model>i6300esb</model>
    # </watchdog>
    # ----
    # 
    # @param watchdog [Watchdog] The information about the watchdog.
    #   
    #   The request data must contain `model` element (such as `i6300esb`) and `action` element
    #   (one of `none`, `reset`, `poweroff`, `dump`, `pause`). The response data additionally
    #   contains references to the added watchdog and to the virtual machine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Watchdog]
    # 
    def add(watchdog, opts = {})
      internal_add(watchdog, Watchdog, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # The list of watchdogs of the virtual machine.
    # 
    # The order of the returned list of watchdogs isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of watchdogs to return. If not specified all the watchdogs are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Watchdog>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Returns a reference to the service that manages a specific watchdog.
    # 
    # @param id [String] The identifier of the `watchdog`.
    # 
    # @return [VmWatchdogService] A reference to the `watchdog` service.
    # 
    def watchdog_service(id)
      VmWatchdogService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return watchdog_service(path)
      end
      return watchdog_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VmsService < Service
    
    ADD = [
      [:clone, TrueClass].freeze,
      [:clone_permissions, TrueClass].freeze,
      [:filter, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD
    
    # 
    # Creates a new virtual machine.
    # 
    # The virtual machine can be created in different ways:
    # 
    # - From a template. In this case the identifier or name of the template must be provided. For example, using a
    #   plain shell script and XML:
    # 
    # [source,bash]
    # ----
    # #!/bin/sh -ex
    # 
    # url="https://engine.example.com/ovirt-engine/api"
    # user="admin@internal"
    # password="..."
    # curl \
    # --verbose \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --user "${user}:${password}" \
    # --request POST \
    # --header "Version: 4" \
    # --header "Content-Type: application/xml" \
    # --header "Accept: application/xml" \
    # --data '
    # <vm>
    #   <name>myvm</name>
    #   <template>
    #     <name>Blank</name>
    #   </template>
    #   <cluster>
    #     <name>mycluster</name>
    #   </cluster>
    # </vm>
    # ' \
    # "${url}/vms"
    # ----
    # 
    # - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
    #   shel script and XML:
    # 
    # [source,bash]
    # ----
    # #!/bin/sh -ex
    # 
    # url="https://engine.example.com/ovirt-engine/api"
    # user="admin@internal"
    # password="..."
    # curl \
    # --verbose \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --user "${user}:${password}" \
    # --request POST \
    # --header "Content-Type: application/xml" \
    # --header "Accept: application/xml" \
    # --data '
    # <vm>
    #   <name>myvm</name>
    #   <snapshots>
    #     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
    #   </snapshots>
    #   <cluster>
    #     <name>mycluster</name>
    #   </cluster>
    # </vm>
    # ' \
    # "${url}/vms"
    # ----
    # 
    # When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
    # in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
    # a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
    # 
    # [source,xml]
    # ----
    # <vm>
    #   ...
    #   <disk_attachments>
    #     <disk_attachment>
    #       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
    #         <storage_domains>
    #           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
    #         </storage_domains>
    #       </disk>
    #     <disk_attachment>
    #   </disk_attachments>
    # </vm>
    # ----
    # 
    # When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
    # `image_id` attribute instead of `id`.
    # 
    # [source,xml]
    # ----
    # <vm>
    #   ...
    #   <disk_attachments>
    #     <disk_attachment>
    #       <disk>
    #         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
    #         <storage_domains>
    #           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
    #         </storage_domains>
    #       </disk>
    #     <disk_attachment>
    #   </disk_attachments>
    # </vm>
    # ----
    # 
    # It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
    # of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
    # following:
    # 
    # [source,xml]
    # ----
    # <vm>
    #   <name>myvm</name>
    #   <description>My Desktop Virtual Machine</description>
    #   <type>desktop</type>
    #   <memory>2147483648</memory>
    #   ...
    # </vm>
    # ----
    # 
    # A bootable CDROM device can be set like this:
    # 
    # [source,xml]
    # ----
    # <vm>
    #   ...
    #   <os>
    #     <boot dev="cdrom"/>
    #   </os>
    # </vm>
    # ----
    # 
    # In order to boot from CDROM, you first need to insert a disk, as described in the
    # <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
    # attribute:
    # 
    # [source,xml]
    # ----
    # <vm>
    #   ...
    #   <os>
    #     <boot>
    #       <devices>
    #         <device>cdrom</device>
    #       </devices>
    #     </boot>
    #   </os>
    # </vm>
    # ----
    # 
    # In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
    # 
    # @param vm [Vm] The `vm` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone Specifies if the virtual machine should be independent of the template.
    #   
    #   When a virtual machine is created from a template by default the disks of the virtual machine depend on
    #   the disks of the template, they are using the https://en.wikipedia.org/wiki/Copy-on-write[_copy on write_]
    #   mechanism so that only the differences from the template take up real storage space. If this parameter is
    #   specified and the value is `true` then the disks of the created virtual machine will be _cloned_, and
    #   independent of the template. For example, to create an independent virtual machine, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/vms?clone=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    #   
    #   NOTE: When this parameter is `true` the permissions of the template will also be copied, as when using
    #   `clone_permissions=true`.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the template should be copied to the virtual machine.
    #   
    #   If this optional parameter is provided, and its values is `true` then the permissions of the template (only
    #   the direct ones, not the inherited ones) will be copied to the created virtual machine. For example, to
    #   create a virtual machine from the `mytemplate` template copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/vms?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    # 
    # @option opts [Boolean] :filter Relevant for admin users only. Indicates whether to assign UserVmManager role
    #   on the created Virtual Machine for this user. This will enable the user to later access
    #   the Virtual Machine as though he were a non-admin user, foregoing his admin permissions
    #   (by providing filter=true).
    #   
    #   NOTE: admin-as-user (meaning providing filter=true) POST requests on an existing Virtual
    #   Machine will fail unless the Virtual Machine has been previously created by the admin as
    #   a user (meaning with filter=true).
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def add(vm, opts = {})
      internal_add(vm, Vm, ADD, opts)
    end
    
    ADD_FROM_CONFIGURATION = [
      [:clone, TrueClass].freeze,
      [:clone_permissions, TrueClass].freeze,
      [:filter, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_FROM_CONFIGURATION
    
    # 
    # add a virtual machine to the system from a configuration - requires the configuration type and the configuration data
    # 
    # @param vm [Vm] The `vm` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone Specifies if the virtual machine should be independent of the template.
    #   
    #   When a virtual machine is created from a template by default the disks of the virtual machine depend on
    #   the disks of the template, they are using the https://en.wikipedia.org/wiki/Copy-on-write[_copy on write_]
    #   mechanism so that only the differences from the template take up real storage space. If this parameter is
    #   specified and the value is `true` then the disks of the created virtual machine will be _cloned_, and
    #   independent of the template. For example, to create an independent virtual machine, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/vms?clone=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    #   
    #   NOTE: When this parameter is `true` the permissions of the template will also be copied, as when using
    #   `clone_permissions=true`.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the template should be copied to the virtual machine.
    #   
    #   If this optional parameter is provided, and its values is `true` then the permissions of the template (only
    #   the direct ones, not the inherited ones) will be copied to the created virtual machine. For example, to
    #   create a virtual machine from the `mytemplate` template copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/vms?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    # 
    # @option opts [Boolean] :filter Relevant for admin users only. Indicates whether to assign UserVmManager role
    #   on the created Virtual Machine for this user. This will enable the user to later access
    #   the Virtual Machine as though he were a non-admin user, foregoing his admin permissions
    #   (by providing filter=true).
    #   
    #   NOTE: admin-as-user (meaning providing filter=true) POST requests on an existing Virtual
    #   Machine will fail unless the Virtual Machine has been previously created by the admin as
    #   a user (meaning with filter=true).
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def add_from_configuration(vm, opts = {})
      internal_add(vm, Vm, ADD_FROM_CONFIGURATION, opts)
    end
    
    ADD_FROM_SCRATCH = [
      [:clone, TrueClass].freeze,
      [:clone_permissions, TrueClass].freeze,
      [:filter, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_FROM_SCRATCH
    
    # 
    # add a virtual machine to the system from scratch
    # 
    # @param vm [Vm] The `vm` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone Specifies if the virtual machine should be independent of the template.
    #   
    #   When a virtual machine is created from a template by default the disks of the virtual machine depend on
    #   the disks of the template, they are using the https://en.wikipedia.org/wiki/Copy-on-write[_copy on write_]
    #   mechanism so that only the differences from the template take up real storage space. If this parameter is
    #   specified and the value is `true` then the disks of the created virtual machine will be _cloned_, and
    #   independent of the template. For example, to create an independent virtual machine, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/vms?clone=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    #   
    #   NOTE: When this parameter is `true` the permissions of the template will also be copied, as when using
    #   `clone_permissions=true`.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the template should be copied to the virtual machine.
    #   
    #   If this optional parameter is provided, and its values is `true` then the permissions of the template (only
    #   the direct ones, not the inherited ones) will be copied to the created virtual machine. For example, to
    #   create a virtual machine from the `mytemplate` template copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/vms?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    # 
    # @option opts [Boolean] :filter Relevant for admin users only. Indicates whether to assign UserVmManager role
    #   on the created Virtual Machine for this user. This will enable the user to later access
    #   the Virtual Machine as though he were a non-admin user, foregoing his admin permissions
    #   (by providing filter=true).
    #   
    #   NOTE: admin-as-user (meaning providing filter=true) POST requests on an existing Virtual
    #   Machine will fail unless the Virtual Machine has been previously created by the admin as
    #   a user (meaning with filter=true).
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def add_from_scratch(vm, opts = {})
      internal_add(vm, Vm, ADD_FROM_SCRATCH, opts)
    end
    
    ADD_FROM_SNAPSHOT = [
      [:clone, TrueClass].freeze,
      [:clone_permissions, TrueClass].freeze,
      [:filter, TrueClass].freeze,
    ].freeze
    
    private_constant :ADD_FROM_SNAPSHOT
    
    # 
    # add a virtual machine to the system by cloning from a snapshot
    # 
    # @param vm [Vm] The `vm` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :clone Specifies if the virtual machine should be independent of the template.
    #   
    #   When a virtual machine is created from a template by default the disks of the virtual machine depend on
    #   the disks of the template, they are using the https://en.wikipedia.org/wiki/Copy-on-write[_copy on write_]
    #   mechanism so that only the differences from the template take up real storage space. If this parameter is
    #   specified and the value is `true` then the disks of the created virtual machine will be _cloned_, and
    #   independent of the template. For example, to create an independent virtual machine, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/vms?clone=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    #   
    #   NOTE: When this parameter is `true` the permissions of the template will also be copied, as when using
    #   `clone_permissions=true`.
    # 
    # @option opts [Boolean] :clone_permissions Specifies if the permissions of the template should be copied to the virtual machine.
    #   
    #   If this optional parameter is provided, and its values is `true` then the permissions of the template (only
    #   the direct ones, not the inherited ones) will be copied to the created virtual machine. For example, to
    #   create a virtual machine from the `mytemplate` template copying its permissions, send a request like this:
    #   
    #   [source]
    #   ----
    #   POST /ovirt-engine/api/vms?clone_permissions=true
    #   ----
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <vm>
    #     <name>myvm<name>
    #     <template>
    #       <name>mytemplate<name>
    #     </template>
    #     <cluster>
    #       <name>mycluster<name>
    #     </cluster>
    #   </vm>
    #   ----
    # 
    # @option opts [Boolean] :filter Relevant for admin users only. Indicates whether to assign UserVmManager role
    #   on the created Virtual Machine for this user. This will enable the user to later access
    #   the Virtual Machine as though he were a non-admin user, foregoing his admin permissions
    #   (by providing filter=true).
    #   
    #   NOTE: admin-as-user (meaning providing filter=true) POST requests on an existing Virtual
    #   Machine will fail unless the Virtual Machine has been previously created by the admin as
    #   a user (meaning with filter=true).
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Vm]
    # 
    def add_from_snapshot(vm, opts = {})
      internal_add(vm, Vm, ADD_FROM_SNAPSHOT, opts)
    end
    
    LIST = [
      [:all_content, TrueClass].freeze,
      [:case_sensitive, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
      [:ovf_as_ova, TrueClass].freeze,
      [:search, String].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of virtual machines of the system.
    # 
    # The order of the returned list of virtual machines is guaranteed only if the `sortby` clause is included
    # in the `search` parameter.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all the attributes of the virtual machines should be included in the response.
    #   
    #   By default the following attributes are excluded:
    #   
    #   - `console`
    #   - `initialization.configuration.data` - The OVF document describing the virtual machine.
    #   - `rng_source`
    #   - `soundcard`
    #   - `virtio_scsi`
    #   
    #   For example, to retrieve the complete representation of the virtual machines send a request like this:
    #   
    #   ....
    #   GET /ovirt-engine/api/vms?all_content=true
    #   ....
    #   
    #   NOTE: The reason for not including these attributes is performance: they are seldom used and they require
    #   additional queries to the database. So try to use the this parameter only when it is really needed.
    # 
    # @option opts [Boolean] :case_sensitive Indicates if the search performed using the `search` parameter should be performed taking case into
    #   account. The default value is `true`, which means that case is taken into account. If you want to search
    #   ignoring case set it to `false`.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max The maximum number of results to return.
    # 
    # @option opts [Boolean] :ovf_as_ova Indicates if the results should expose the OVF as it appears in OVA files of that VM. The OVF document
    #   describing the virtual machine. This parameter will work only when all_content=True is set.
    #   The OVF will be presented in `initialization.configuration.data`.
    #   
    #   For example:
    #   [source]
    #   ----
    #   GET /vms?all_content=true&ovf_as_ova=true
    #   ----
    # 
    # @option opts [String] :search A query string used to restrict the returned virtual machines.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Vm>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `vm` service.
    # 
    # @param id [String] The identifier of the `vm`.
    # 
    # @return [VmService] A reference to the `vm` service.
    # 
    def vm_service(id)
      VmService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return vm_service(path)
      end
      return vm_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class VnicProfileService < Service
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves details about a vNIC profile.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VnicProfile]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the vNIC profile.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates details of a vNIC profile.
    # 
    # @param profile [VnicProfile] The vNIC profile that is being updated.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VnicProfile]
    # 
    def update(profile, opts = {})
      internal_update(profile, VnicProfile, UPDATE, opts)
    end
    
    # 
    # Locates the `permissions` service.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class VnicProfilesService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a vNIC profile.
    # 
    # For example to add vNIC profile `123` to network `456` send a request to:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/networks/456/vnicprofiles
    # ----
    # 
    # With the following body:
    # 
    # [source,xml]
    # ----
    # <vnic_profile id="123">
    #   <name>new_vNIC_name</name>
    #   <pass_through>
    #     <mode>disabled</mode>
    #   </pass_through>
    #   <port_mirroring>false</port_mirroring>
    # </vnic_profile>
    # ----
    # 
    # Please note that there is a default network filter to each VNIC profile.
    # For more details of how the default network filter is calculated please refer to
    # the documentation in <<services/network_filters,NetworkFilters>>.
    # 
    # NOTE: The automatically created vNIC profile for the external network will be without network filter.
    # 
    # The output of creating a new VNIC profile depends in the  body  arguments that were given.
    # In case no network filter was given, the default network filter will be configured. For example:
    # 
    # [source,xml]
    # ----
    # <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
    #   <name>new_vNIC_name</name>
    #   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
    #   <pass_through>
    #     <mode>disabled</mode>
    #   </pass_through>
    #   <port_mirroring>false</port_mirroring>
    #   <network href="/ovirt-engine/api/networks/456" id="456"/>
    #   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
    # </vnic_profile>
    # ----
    # 
    # In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
    # regardless of the VNIC profile's default network filter. For example:
    # 
    # [source,xml]
    # ----
    # <vnic_profile>
    #   <name>no_network_filter</name>
    #   <network_filter/>
    # </vnic_profile>
    # ----
    # 
    # In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
    # network filter regardless of the VNIC profiles's default network filter. For example:
    # 
    # [source,xml]
    # ----
    # <vnic_profile>
    #   <name>user_choice_network_filter</name>
    #   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
    # </vnic_profile>
    # ----
    # 
    # @param profile [VnicProfile] The vNIC profile that is being added.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [VnicProfile]
    # 
    def add(profile, opts = {})
      internal_add(profile, VnicProfile, ADD, opts)
    end
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # List all vNIC profiles.
    # 
    # The order of the returned list of vNIC profiles isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of profiles to return. If not specified all the profiles are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<VnicProfile>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `profile` service.
    # 
    # @param id [String] The identifier of the `profile`.
    # 
    # @return [VnicProfileService] A reference to the `profile` service.
    # 
    def profile_service(id)
      VnicProfileService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return profile_service(path)
      end
      return profile_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class WeightService < Service
    
    GET = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Weight]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class WeightsService < Service
    
    ADD = [
    ].freeze
    
    private_constant :ADD
    
    # 
    # Add a weight to a specified user defined scheduling policy.
    # 
    # @param weight [Weight] The `weight` to add.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Weight]
    # 
    def add(weight, opts = {})
      internal_add(weight, Weight, ADD, opts)
    end
    
    LIST = [
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Returns the list of weights.
    # 
    # The order of the returned list of weights isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of weights to return. If not specified all the weights are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<Weight>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Locates the `weight` service.
    # 
    # @param id [String] The identifier of the `weight`.
    # 
    # @return [WeightService] A reference to the `weight` service.
    # 
    def weight_service(id)
      WeightService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return weight_service(path)
      end
      return weight_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class AttachedStorageDomainDiskService < MeasurableService
    
    COPY = [
      [:disk, Disk].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :COPY
    
    # 
    # Copies a disk to the specified storage domain.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Disk] :disk Description of the resulting disk.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain where the new disk will be created.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def copy(opts = {})
      internal_action(:copy, nil, COPY, opts)
    end
    
    EXPORT = [
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT
    
    # 
    # Exports a disk to an export storage domain.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [StorageDomain] :storage_domain The export storage domain where the disk should be exported to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export(opts = {})
      internal_action(:export, nil, EXPORT, opts)
    end
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the description of the disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    MOVE = [
      [:async, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :MOVE
    
    # 
    # Moves a disk to another storage domain.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the move should be performed asynchronously.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain where the disk will be moved to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def move(opts = {})
      internal_action(:move, nil, MOVE, opts)
    end
    
    REGISTER = [
    ].freeze
    
    private_constant :REGISTER
    
    # 
    # Registers an unregistered disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def register(opts = {})
      internal_action(:register, nil, REGISTER, opts)
    end
    
    REMOVE = [
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a disk.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    SPARSIFY = [
    ].freeze
    
    private_constant :SPARSIFY
    
    # 
    # Sparsify the disk.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
    # operation of the service that manages that disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def sparsify(opts = {})
      internal_action(:sparsify, nil, SPARSIFY, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the disk.
    # 
    # IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
    # compatibility. It will be removed in the future. To update a disk use the
    # <<services/disk/methods/update, update>> operation of the service that manages that disk.
    # 
    # @param disk [Disk] The update to apply to the disk.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def update(disk, opts = {})
      internal_update(disk, Disk, UPDATE, opts)
    end
    
    # 
    # Reference to the service that manages the permissions assigned to the disk.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class DiskService < MeasurableService
    
    COPY = [
      [:async, TrueClass].freeze,
      [:disk, Disk].freeze,
      [:disk_profile, DiskProfile].freeze,
      [:filter, TrueClass].freeze,
      [:quota, Quota].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :COPY
    
    # 
    # This operation copies a disk to the specified storage domain.
    # 
    # For example, a disk can be copied using the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/disks/123/copy
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain id="456"/>
    #   <disk>
    #     <name>mydisk</name>
    #   </disk>
    # </action>
    # ----
    # 
    # If the disk profile or the quota currently used by the disk are not defined for the new storage domain, they
    # can be explicitly specified. If they are not specified, the first available disk profile and the default quota are used.
    # 
    # For example, to specify disk profile `987` and quota `753`, send a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain id="456"/>
    #   <disk_profile id="987"/>
    #   <quota id="753"/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the copy should be performed asynchronously.
    # 
    # @option opts [Disk] :disk 
    # 
    # @option opts [DiskProfile] :disk_profile Disk profile for the disk in the new storage domain.
    #   
    #   Disk profiles are defined for storage domains,
    #   so the old disk profile will not exist in the new storage domain.
    #   If this parameter is not used, the first disk profile from the new storage domain
    #   to which the user has permissions will be assigned to the disk.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [Quota] :quota Quota for the disk in the new storage domain.
    #   
    #   This optional parameter can be used to specify new quota for the disk,
    #   because the current quota may not be defined for the new storage domain.
    #   If this parameter is not used and the old quota is not defined for the new storage domain,
    #   the default (unlimited) quota will be assigned to the disk.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain where the new disk is created. This can be specified using the `id` or `name`
    #   attributes. For example, to copy a disk to the storage domain called `mydata`, send a request like this:
    #   
    #   ....
    #   POST /ovirt-engine/api/storagedomains/123/disks/789
    #   ....
    #   
    #   With a request body like this:
    #   
    #   [source,xml]
    #   ----
    #   <action>
    #     <storage_domain>
    #       <name>mydata</name>
    #     </storage_domain>
    #   </action>
    #   ----
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def copy(opts = {})
      internal_action(:copy, nil, COPY, opts)
    end
    
    EXPORT = [
      [:async, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :EXPORT
    
    # 
    # Exports a disk to an export storage domain.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the export should be performed asynchronously.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [StorageDomain] :storage_domain The export storage domain where the disk will be exported to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def export(opts = {})
      internal_action(:export, nil, EXPORT, opts)
    end
    
    GET = [
      [:all_content, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Retrieves the description of the disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all of the attributes of the disk should be included in the response.
    #   
    #   By default the following disk attributes are excluded:
    #   
    #   - `vms`
    #   
    #   For example, to retrieve the complete representation of disk '123':
    #   
    #   ....
    #   GET /ovirt-engine/api/disks/123?all_content=true
    #   ....
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    MOVE = [
      [:async, TrueClass].freeze,
      [:disk_profile, DiskProfile].freeze,
      [:filter, TrueClass].freeze,
      [:quota, Quota].freeze,
      [:storage_domain, StorageDomain].freeze,
    ].freeze
    
    private_constant :MOVE
    
    # 
    # Moves a disk to another storage domain.
    # 
    # For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
    # request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/disks/123/move
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain id="456"/>
    # </action>
    # ----
    # 
    # If the disk profile or the quota used currently by
    # the disk aren't defined for the new storage domain,
    # then they can be explicitly specified. If they aren't
    # then the first available disk profile and the default
    # quota are used.
    # 
    # For example, to explicitly use disk profile `987` and
    # quota `753` send a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <storage_domain id="456"/>
    #   <disk_profile id="987"/>
    #   <quota id="753"/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the move should be performed asynchronously.
    # 
    # @option opts [DiskProfile] :disk_profile Disk profile for the disk in the new storage domain.
    #   
    #   Disk profiles are defined for storage domains,
    #   so the old disk profile will not exist in the new storage domain.
    #   If this parameter is not used, the first disk profile from the new storage domain
    #   to which the user has permissions will be assigned to the disk.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [Quota] :quota Quota for the disk in the new storage domain.
    #   
    #   This optional parameter can be used to specify new quota for the disk,
    #   because the current quota may not be defined for the new storage domain.
    #   If this parameter is not used and the old quota is not defined for the new storage domain,
    #   the default (unlimited) quota will be assigned to the disk.
    # 
    # @option opts [StorageDomain] :storage_domain The storage domain where the disk will be moved to.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def move(opts = {})
      internal_action(:move, nil, MOVE, opts)
    end
    
    REDUCE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REDUCE
    
    # 
    # Reduces the size of the disk image.
    # 
    # Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
    # This is applicable for floating disks and disks attached to non-running virtual machines.
    # There is no need to specify the size as the optimal size is calculated automatically.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reduce(opts = {})
      internal_action(:reduce, nil, REDUCE, opts)
    end
    
    REFRESH_LUN = [
      [:host, Host].freeze,
    ].freeze
    
    private_constant :REFRESH_LUN
    
    # 
    # Refreshes a direct LUN disk with up-to-date information from the storage.
    # 
    # Refreshing a direct LUN disk is useful when:
    # 
    # - The LUN was added using the API without the host parameter, and therefore does not contain
    #   any information from the storage (see <<services/disks/methods/add, DisksService::add>>).
    # - New information about the LUN is available on the storage and you want to update the LUN with it.
    # 
    # To refresh direct LUN disk `123` using host `456`, send the following request:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/disks/123/refreshlun
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <host id='456'/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Host] :host The host that will be used to refresh the direct LUN disk.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def refresh_lun(opts = {})
      internal_action(:refreshlun, nil, REFRESH_LUN, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a disk.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    SPARSIFY = [
    ].freeze
    
    private_constant :SPARSIFY
    
    # 
    # Sparsify the disk.
    # 
    # Sparsification frees space in the disk image that is not used by its
    # filesystem. As a result, the image will occupy less space on the storage.
    # 
    # Currently sparsification works only on disks without snapshots. Disks
    # having derived disks are also not allowed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def sparsify(opts = {})
      internal_action(:sparsify, nil, SPARSIFY, opts)
    end
    
    UPDATE = [
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Updates the parameters of the specified disk.
    # 
    # This operation allows updating the following floating disk properties:
    # 
    # * For Image disks: `provisioned_size`, `alias`, `description`, `wipe_after_delete`, `shareable`, `backup` and `disk_profile`.
    # 
    # * For LUN disks: `alias`, `description` and `shareable`.
    # 
    # * For Cinder and Managed Block disks: `provisioned_size`, `alias` and `description`.
    # 
    # * For VM attached disks, the `qcow_version` can also be updated.
    # 
    # For example, a disk's update can be done by using the following request:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/disks/123
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <disk>
    #   <qcow_version>qcow2_v3</qcow_version>
    #   <alias>new-alias</alias>
    #   <description>new-desc</description>
    # </disk>
    # ----
    # 
    # Since the backend operation is asynchronous, the disk element that is returned
    # to the user might not be synced with the changed properties.
    # 
    # @param disk [Disk] The update to apply to the disk.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Disk]
    # 
    def update(disk, opts = {})
      internal_update(disk, Disk, UPDATE, opts)
    end
    
    # 
    # Reference to the service that manages the DiskSnapshots.
    # 
    # For example, to list all disk snapshots under the disks resource '123':
    # 
    # ....
    # GET /ovirt-engine/api/disks/123/disksnapshots
    # ....
    # 
    # For example, to retrieve a specific disk snapshot '789' under the disk resource '123':
    # ....
    # GET /ovirt-engine/api/disks/123/disksnapshots/789
    # ....
    # 
    # @return [DiskSnapshotsService] A reference to `disk_snapshots` service.
    # 
    def disk_snapshots_service
      @disk_snapshots_service ||= DiskSnapshotsService.new(self, 'disksnapshots')
    end
    
    # 
    # Reference to the service that manages the permissions assigned to the disk.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'disksnapshots'
        return disk_snapshots_service
      end
      if path.start_with?('disksnapshots/')
        return disk_snapshots_service.service(path[14..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class EngineKatelloErrataService < KatelloErrataService
    
    LIST = [
      [:follow, String].freeze,
      [:max, Integer].freeze,
    ].freeze
    
    private_constant :LIST
    
    # 
    # Retrieves the representation of the Katello errata.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/katelloerrata
    # ----
    # 
    # You will receive response in XML like this one:
    # 
    # [source,xml]
    # ----
    # <katello_errata>
    #   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
    #     <name>RHBA-2013:XYZ</name>
    #     <description>The description of the erratum</description>
    #     <title>some bug fix update</title>
    #     <type>bugfix</type>
    #     <issued>2013-11-20T02:00:00.000+02:00</issued>
    #     <solution>Few guidelines regarding the solution</solution>
    #     <summary>Updated packages that fix one bug are now available for XYZ</summary>
    #     <packages>
    #       <package>
    #         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
    #       </package>
    #       ...
    #     </packages>
    #   </katello_erratum>
    #   ...
    # </katello_errata>
    # ----
    # 
    # The order of the returned list of erratum isn't guaranteed.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Integer] :max Sets the maximum number of errata to return. If not specified all the errata are returned.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Array<KatelloErratum>]
    # 
    def list(opts = {})
      internal_get(LIST, opts)
    end
    
    # 
    # Reference to the Katello erratum service.
    # Use this service to view the erratum by its id.
    # 
    # @param id [String] The identifier of the `katello_erratum`.
    # 
    # @return [KatelloErratumService] A reference to the `katello_erratum` service.
    # 
    def katello_erratum_service(id)
      KatelloErratumService.new(self, id)
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      index = path.index('/')
      if index.nil?
        return katello_erratum_service(path)
      end
      return katello_erratum_service(path[0..(index - 1)]).service(path[(index + 1)..-1])
    end
    
  end
  
  class ExternalHostProviderService < ExternalProviderService
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get external host provider information
    # 
    # Host provider, Foreman or Satellite, can be set as an external provider in ovirt. To see details about specific
    # host providers attached to ovirt use this API.
    # 
    # For example, to get the details of host provider `123`, send a request like this:
    # 
    # ....
    # GET /ovirt-engine/api/externalhostproviders/123
    # ....
    # 
    # The response will be like this:
    # 
    # [source,xml]
    # ----
    # <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123">
    #   <name>mysatellite</name>
    #   <requires_authentication>true</requires_authentication>
    #   <url>https://mysatellite.example.com</url>
    #   <username>admin</username>
    # </external_host_provider>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalHostProvider]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    IMPORT_CERTIFICATES = [
      [:certificates, List].freeze,
    ].freeze
    
    private_constant :IMPORT_CERTIFICATES
    
    # 
    # Import the SSL certificates of the external host provider.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Array<Certificate>] :certificates 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def import_certificates(opts = {})
      internal_action(:importcertificates, nil, IMPORT_CERTIFICATES, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Deletes the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    TEST_CONNECTIVITY = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :TEST_CONNECTIVITY
    
    # 
    # In order to test connectivity for external provider we need
    # to run following request where 123 is an id of a provider.
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the test should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def test_connectivity(opts = {})
      internal_action(:testconnectivity, nil, TEST_CONNECTIVITY, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the specified external host provider in the system.
    # 
    # @param provider [ExternalHostProvider] The `provider` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [ExternalHostProvider]
    # 
    def update(provider, opts = {})
      internal_update(provider, ExternalHostProvider, UPDATE, opts)
    end
    
    # 
    # A service to view certificates for this external provider.
    # 
    # @return [ExternalProviderCertificatesService] A reference to `certificates` service.
    # 
    def certificates_service
      @certificates_service ||= ExternalProviderCertificatesService.new(self, 'certificates')
    end
    
    # 
    # Locates the `compute_resources` service.
    # 
    # @return [ExternalComputeResourcesService] A reference to `compute_resources` service.
    # 
    def compute_resources_service
      @compute_resources_service ||= ExternalComputeResourcesService.new(self, 'computeresources')
    end
    
    # 
    # Locates the `discovered_hosts` service.
    # 
    # @return [ExternalDiscoveredHostsService] A reference to `discovered_hosts` service.
    # 
    def discovered_hosts_service
      @discovered_hosts_service ||= ExternalDiscoveredHostsService.new(self, 'discoveredhosts')
    end
    
    # 
    # Locates the `host_groups` service.
    # 
    # @return [ExternalHostGroupsService] A reference to `host_groups` service.
    # 
    def host_groups_service
      @host_groups_service ||= ExternalHostGroupsService.new(self, 'hostgroups')
    end
    
    # 
    # Locates the `hosts` service.
    # 
    # @return [ExternalHostsService] A reference to `hosts` service.
    # 
    def hosts_service
      @hosts_service ||= ExternalHostsService.new(self, 'hosts')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'certificates'
        return certificates_service
      end
      if path.start_with?('certificates/')
        return certificates_service.service(path[13..-1])
      end
      if path == 'computeresources'
        return compute_resources_service
      end
      if path.start_with?('computeresources/')
        return compute_resources_service.service(path[17..-1])
      end
      if path == 'discoveredhosts'
        return discovered_hosts_service
      end
      if path.start_with?('discoveredhosts/')
        return discovered_hosts_service.service(path[16..-1])
      end
      if path == 'hostgroups'
        return host_groups_service
      end
      if path.start_with?('hostgroups/')
        return host_groups_service.service(path[11..-1])
      end
      if path == 'hosts'
        return hosts_service
      end
      if path.start_with?('hosts/')
        return hosts_service.service(path[6..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class GlusterBrickService < MeasurableService
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get details of a brick.
    # 
    # Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
    # the equivalent of running `gluster volume status <volumename> <brickname> detail`.
    # 
    # For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
    # ----
    # 
    # Which will return a response body like this:
    # 
    # [source,xml]
    # ----
    # <brick id="234">
    #   <name>host1:/rhgs/data/brick1</name>
    #   <brick_dir>/rhgs/data/brick1</brick_dir>
    #   <server_id>111</server_id>
    #   <status>up</status>
    #   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
    #   <fs_name>xfs</fs_name>
    #   <gluster_clients>
    #     <gluster_client>
    #       <bytes_read>2818417648</bytes_read>
    #       <bytes_written>1384694844</bytes_written>
    #       <client_port>1011</client_port>
    #       <host_name>client2</host_name>
    #     </gluster_client>
    #   </gluster_clients>
    #   <memory_pools>
    #     <memory_pool>
    #       <name>data-server:fd_t</name>
    #       <alloc_count>1626348</alloc_count>
    #       <cold_count>1020</cold_count>
    #       <hot_count>4</hot_count>
    #       <max_alloc>23</max_alloc>
    #       <max_stdalloc>0</max_stdalloc>
    #       <padded_size>140</padded_size>
    #       <pool_misses>0</pool_misses>
    #     </memory_pool>
    #   </memory_pools>
    #   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
    #   <pid>25589</pid>
    #   <port>49155</port>
    # </brick>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GlusterBrick]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes a brick.
    # 
    # Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
    # removing a single brick without data migration. To remove multiple bricks and with data migration, use
    # <<services/gluster_bricks/methods/migrate, migrate>> instead.
    # 
    # For example, to delete brick `234` from gluster volume `123`, send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    REPLACE = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :REPLACE
    
    # 
    # Replaces this brick with a new one.
    # 
    # IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
    # Use <<services/gluster_bricks/methods/add, add brick(s)>> and
    # <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the replacement should be performed asynchronously.
    # 
    # @option opts [Boolean] :force 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def replace(opts = {})
      internal_action(:replace, nil, REPLACE, opts)
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class GlusterVolumeService < MeasurableService
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Get the gluster volume details.
    # 
    # For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/clusters/456/glustervolumes/123
    # ----
    # 
    # This GET request will return the following output:
    # 
    # [source,xml]
    # ----
    # <gluster_volume id="123">
    #  <name>data</name>
    #  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
    #  <disperse_count>0</disperse_count>
    #  <options>
    #    <option>
    #      <name>storage.owner-gid</name>
    #      <value>36</value>
    #    </option>
    #    <option>
    #      <name>performance.io-cache</name>
    #      <value>off</value>
    #    </option>
    #    <option>
    #      <name>cluster.data-self-heal-algorithm</name>
    #      <value>full</value>
    #    </option>
    #  </options>
    #  <redundancy_count>0</redundancy_count>
    #  <replica_count>3</replica_count>
    #  <status>up</status>
    #  <stripe_count>0</stripe_count>
    #  <transport_types>
    #    <transport_type>tcp</transport_type>
    #  </transport_types>
    #  <volume_type>replicate</volume_type>
    #  </gluster_volume>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [GlusterVolume]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    GET_PROFILE_STATISTICS = [
    ].freeze
    
    private_constant :GET_PROFILE_STATISTICS
    
    # 
    # Get gluster volume profile statistics.
    # 
    # For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
    # request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [GlusterVolumeProfileDetails] :details Gluster volume profiling information returned from the action.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def get_profile_statistics(opts = {})
      internal_action(:getprofilestatistics, :details, GET_PROFILE_STATISTICS, opts)
    end
    
    REBALANCE = [
      [:async, TrueClass].freeze,
      [:fix_layout, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :REBALANCE
    
    # 
    # Rebalance the gluster volume.
    # 
    # Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
    # shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
    # non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
    # least one of the bricks in the replica should be online.
    # 
    # For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the rebalance should be performed asynchronously.
    # 
    # @option opts [Boolean] :fix_layout If set to true, rebalance will only fix the layout so that new data added to the volume is distributed
    #   across all the hosts. But it will not migrate/rebalance the existing data. Default is `false`.
    # 
    # @option opts [Boolean] :force Indicates if the rebalance should be force started. The rebalance command can be executed with the force
    #   option even when the older clients are connected to the cluster. However, this could lead to a data loss
    #   situation. Default is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def rebalance(opts = {})
      internal_action(:rebalance, nil, REBALANCE, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Removes the gluster volume.
    # 
    # For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
    # 
    # [source]
    # ----
    # DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    RESET_ALL_OPTIONS = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :RESET_ALL_OPTIONS
    
    # 
    # Resets all the options set in the gluster volume.
    # 
    # For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
    # this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the reset should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reset_all_options(opts = {})
      internal_action(:resetalloptions, nil, RESET_ALL_OPTIONS, opts)
    end
    
    RESET_OPTION = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
      [:option, Option].freeze,
    ].freeze
    
    private_constant :RESET_OPTION
    
    # 
    # Resets a particular option in the gluster volume.
    # 
    # For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
    # send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <action>
    #  <option name="option1"/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the reset should be performed asynchronously.
    # 
    # @option opts [Boolean] :force 
    # 
    # @option opts [Option] :option Option to reset.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def reset_option(opts = {})
      internal_action(:resetoption, nil, RESET_OPTION, opts)
    end
    
    SET_OPTION = [
      [:async, TrueClass].freeze,
      [:option, Option].freeze,
    ].freeze
    
    private_constant :SET_OPTION
    
    # 
    # Sets a particular option in the gluster volume.
    # 
    # For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
    # send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
    # ----
    # 
    # With the following request body:
    # 
    # [source,xml]
    # ----
    # <action>
    #  <option name="option1" value="value1"/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Option] :option Option to set.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def set_option(opts = {})
      internal_action(:setoption, nil, SET_OPTION, opts)
    end
    
    START = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :START
    
    # 
    # Starts the gluster volume.
    # 
    # A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
    # `123` in cluster `456`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Boolean] :force Indicates if the volume should be force started. If a gluster volume is started already but few/all bricks
    #   are down then force start can be used to bring all the bricks up. Default is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def start(opts = {})
      internal_action(:start, nil, START, opts)
    end
    
    START_PROFILE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :START_PROFILE
    
    # 
    # Start profiling the gluster volume.
    # 
    # For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def start_profile(opts = {})
      internal_action(:startprofile, nil, START_PROFILE, opts)
    end
    
    STOP = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :STOP
    
    # 
    # Stops the gluster volume.
    # 
    # Stopping a volume will make its data inaccessible.
    # 
    # For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Boolean] :force 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def stop(opts = {})
      internal_action(:stop, nil, STOP, opts)
    end
    
    STOP_PROFILE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :STOP_PROFILE
    
    # 
    # Stop profiling the gluster volume.
    # 
    # For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def stop_profile(opts = {})
      internal_action(:stopprofile, nil, STOP_PROFILE, opts)
    end
    
    STOP_REBALANCE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :STOP_REBALANCE
    
    # 
    # Stop rebalancing the gluster volume.
    # 
    # For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
    # this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def stop_rebalance(opts = {})
      internal_action(:stoprebalance, nil, STOP_REBALANCE, opts)
    end
    
    # 
    # Reference to a service managing gluster bricks.
    # 
    # @return [GlusterBricksService] A reference to `gluster_bricks` service.
    # 
    def gluster_bricks_service
      @gluster_bricks_service ||= GlusterBricksService.new(self, 'glusterbricks')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'glusterbricks'
        return gluster_bricks_service
      end
      if path.start_with?('glusterbricks/')
        return gluster_bricks_service.service(path[14..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class HostService < MeasurableService
    
    ACTIVATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :ACTIVATE
    
    # 
    # Activates the host for use, for example to run virtual machines.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the activation should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def activate(opts = {})
      internal_action(:activate, nil, ACTIVATE, opts)
    end
    
    APPROVE = [
      [:activate, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:host, Host].freeze,
      [:reboot, TrueClass].freeze,
    ].freeze
    
    private_constant :APPROVE
    
    # 
    # Approve a pre-installed Hypervisor host for usage in the virtualization environment.
    # 
    # This action also accepts an optional cluster element to define the target cluster for this host.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to 'true', this host will be activated after its approval completes. When set to 'false'
    #   the host will remain in 'maintenance' status after its approval. Absence of this parameter will be
    #   interpreted as 'true', since the desired default behavior is activating the host after approval.
    # 
    # @option opts [Boolean] :async Indicates if the approval should be performed asynchronously.
    # 
    # @option opts [Cluster] :cluster The cluster where the host will be added after it is approved.
    # 
    # @option opts [Host] :host The host to approve.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def approve(opts = {})
      internal_action(:approve, nil, APPROVE, opts)
    end
    
    COMMIT_NET_CONFIG = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :COMMIT_NET_CONFIG
    
    # 
    # Marks the network configuration as good and persists it inside the host.
    # 
    # An API user commits the network configuration to persist a host network interface attachment or detachment, or
    # persist the creation and deletion of a bonded interface.
    # 
    # IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
    # not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
    # automatically reverts to the previous networking configuration.
    # 
    # For example, to commit the network configuration of host with id `123` send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts/123/commitnetconfig
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
    # the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
    # configuration is automatically saved in the {hypervisor-name} upon completing the setup and
    # re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
    # waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def commit_net_config(opts = {})
      internal_action(:commitnetconfig, nil, COMMIT_NET_CONFIG, opts)
    end
    
    COPY_HOST_NETWORKS = [
      [:async, TrueClass].freeze,
      [:source_host, Host].freeze,
    ].freeze
    
    private_constant :COPY_HOST_NETWORKS
    
    # 
    # Copy the network configuration of the specified host to current host.
    # 
    # IMPORTANT: Any network attachments that are not present on the source host will be erased from the target host
    # by the copy operation.
    # 
    # To copy networks from another host, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts/123/copyhostnetworks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #    <source_host id="456"/>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Host] :source_host The host to copy networks from.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def copy_host_networks(opts = {})
      internal_action(:copyhostnetworks, nil, COPY_HOST_NETWORKS, opts)
    end
    
    DEACTIVATE = [
      [:async, TrueClass].freeze,
      [:reason, String].freeze,
      [:stop_gluster_service, TrueClass].freeze,
    ].freeze
    
    private_constant :DEACTIVATE
    
    # 
    # Deactivates the host to perform maintenance tasks.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the deactivation should be performed asynchronously.
    # 
    # @option opts [String] :reason 
    # 
    # @option opts [Boolean] :stop_gluster_service Indicates if the gluster service should be stopped as part of deactivating the host. It can be used while
    #   performing maintenance operations on the gluster host. Default value for this variable is `false`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def deactivate(opts = {})
      internal_action(:deactivate, nil, DEACTIVATE, opts)
    end
    
    DISCOVER_ISCSI = [
      [:async, TrueClass].freeze,
      [:iscsi, IscsiDetails].freeze,
    ].freeze
    
    private_constant :DISCOVER_ISCSI
    
    # 
    # Discovers iSCSI targets on the host, using the initiator details.
    # Returns a list of IscsiDetails objects containing the discovered data.
    # 
    # For example, to discover iSCSI targets available in `myiscsi.example.com`,
    # from host `123`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts/123/discoveriscsi
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <iscsi>
    #     <address>myiscsi.example.com</address>
    #   </iscsi>
    # </action>
    # ----
    # 
    # The result will be like this:
    # 
    # [source,xml]
    # ----
    # <discovered_targets>
    #   <iscsi_details>
    #     <address>10.35.1.72</address>
    #     <port>3260</port>
    #     <portal>10.35.1.72:3260,1</portal>
    #     <target>iqn.2015-08.com.tgt:444</target>
    #   </iscsi_details>
    # </discovered_targets>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the discovery should be performed asynchronously.
    # 
    # @option opts [Array<IscsiDetails>] :discovered_targets The discovered targets including all connection information.
    # 
    # @option opts [IscsiDetails] :iscsi The target iSCSI device.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def discover_iscsi(opts = {})
      internal_action(:discoveriscsi, :discovered_targets, DISCOVER_ISCSI, opts)
    end
    
    ENROLL_CERTIFICATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :ENROLL_CERTIFICATE
    
    # 
    # Enrolls the certificate of the host. Useful in case you get a warning that it is about to expire or has already
    # expired.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the enrollment should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def enroll_certificate(opts = {})
      internal_action(:enrollcertificate, nil, ENROLL_CERTIFICATE, opts)
    end
    
    FENCE = [
      [:async, TrueClass].freeze,
      [:fence_type, String].freeze,
      [:maintenance_after_restart, TrueClass].freeze,
    ].freeze
    
    private_constant :FENCE
    
    # 
    # Controls the host's power management device.
    # 
    # For example, to start the host. This can be done via:
    # 
    # [source]
    # ----
    # #!/bin/sh -ex
    # 
    # url="https://engine.example.com/ovirt-engine/api"
    # user="admin@internal"
    # password="..."
    # 
    # curl \
    # --verbose \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --user "${user}:${password}" \
    # --request POST \
    # --header "Version: 4" \
    # --header "Content-Type: application/xml" \
    # --header "Accept: application/xml" \
    # --data '
    # <action>
    #   <fence_type>start</fence_type>
    # </action>
    # ' \
    # "${url}/hosts/123/fence"
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the fencing should be performed asynchronously.
    # 
    # @option opts [String] :fence_type 
    # 
    # @option opts [Boolean] :maintenance_after_restart Indicates if host should be put into maintenance after restart.
    # 
    # @option opts [PowerManagement] :power_management 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def fence(opts = {})
      internal_action(:fence, :power_management, FENCE, opts)
    end
    
    FORCE_SELECT_SPM = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :FORCE_SELECT_SPM
    
    # 
    # To manually set a host as the storage pool manager (SPM).
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts/123/forceselectspm
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def force_select_spm(opts = {})
      internal_action(:forceselectspm, nil, FORCE_SELECT_SPM, opts)
    end
    
    GET = [
      [:all_content, TrueClass].freeze,
      [:filter, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Gets the host details.
    # 
    # [source]
    # ----
    # GET /ovirt-engine/api/hosts/123
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all of the attributes of the host should be included in the response.
    #   
    #   By default the following attributes are excluded:
    #   
    #   - `hosted_engine`
    #   
    #   For example, to retrieve the complete representation of host '123':
    #   
    #   ....
    #   GET /ovirt-engine/api/hosts/123?all_content=true
    #   ....
    #   
    #   NOTE: These attributes are not included by default because retrieving them impacts performance. They are
    #   seldom used and require additional queries to the database. Use this parameter with caution and only when
    #   specifically required.
    # 
    # @option opts [Boolean] :filter Indicates if the results should be filtered according to the permissions of the user.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    INSTALL = [
      [:activate, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:deploy_hosted_engine, TrueClass].freeze,
      [:host, Host].freeze,
      [:image, String].freeze,
      [:reboot, TrueClass].freeze,
      [:root_password, String].freeze,
      [:ssh, Ssh].freeze,
      [:undeploy_hosted_engine, TrueClass].freeze,
    ].freeze
    
    private_constant :INSTALL
    
    # 
    # Installs the latest version of VDSM and related software on the host.
    # 
    # The action also performs every configuration steps on the host which is done during adding host to the engine:
    # kdump configuration, hosted-engine deploy, kernel options changes, etc.
    # 
    # The host type defines additional parameters for the action.
    # 
    # Example of installing a host, using `curl` and JSON, plain:
    # 
    # [source,bash]
    # ----
    # curl \
    # --verbose \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --request PUT \
    # --header "Content-Type: application/json" \
    # --header "Accept: application/json" \
    # --header "Version: 4" \
    # --user "admin@internal:..." \
    # --data '
    # {
    #   "root_password": "myrootpassword"
    # }
    # ' \
    # "https://engine.example.com/ovirt-engine/api/hosts/123"
    # ----
    # 
    # Example of installing a host using `curl` and JSON with hosted engine components:
    # 
    # [source,bash]
    # ----
    # curl \
    # curl \
    # --verbose \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --request PUT \
    # --header "Content-Type: application/json" \
    # --header "Accept: application/json" \
    # --header "Version: 4" \
    # --user "admin@internal:..." \
    # --data '
    # {
    #   "root_password": "myrootpassword"
    # "deploy_hosted_engine" : "true"
    # }
    # ' \
    # "https://engine.example.com/ovirt-engine/api/hosts/123"
    # ----
    # 
    # IMPORTANT: Since version 4.1.2 of the engine, when a host is reinstalled we override the host firewall
    # definitions by default.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to 'true', this host will be activated after its installation completes. When set to 'false'
    #   the host will remain in 'maintenance' status after its installation. Absence of this parameter will be
    #   interpreted as 'true', since the desired default behavior is activating the host after install.
    # 
    # @option opts [Boolean] :async Indicates if the installation should be performed asynchronously.
    # 
    # @option opts [Boolean] :deploy_hosted_engine When set to `true` this host will also deploy the self-hosted engine components. A missing value
    #   is treated as `true` i.e deploy. Omitting this parameter means `false` and will not perform any operation in the
    #   self-hosted engine area.
    # 
    # @option opts [Host] :host The `override_iptables` property is used to indicate if the firewall configuration should be replaced by the
    #   default one.
    # 
    # @option opts [String] :image When installing {hypervisor-name}, an ISO image file is required.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [String] :root_password The password of the `root` user used to connect to the host via SSH.
    # 
    # @option opts [Ssh] :ssh The SSH details used to connect to the host.
    # 
    # @option opts [Boolean] :undeploy_hosted_engine When set to `true` this host will un-deploy the self-hosted engine components, and this host will
    #   not function as part of the High Availability cluster. A missing value is treated as `true` i.e un-deploy.
    #   Omitting this parameter means `false` and will not perform any operation in the self-hosted engine area.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def install(opts = {})
      internal_action(:install, nil, INSTALL, opts)
    end
    
    ISCSI_DISCOVER = [
      [:async, TrueClass].freeze,
      [:iscsi, IscsiDetails].freeze,
    ].freeze
    
    private_constant :ISCSI_DISCOVER
    
    # 
    # This method has been deprecated since Engine version 4.4.6.
    # DiscoverIscsi should be used instead.
    # 
    # Discovers iSCSI targets on the host, using the initiator details.
    # Returns an array of strings containing the discovered data.
    # 
    # For example, to discover iSCSI targets available in `myiscsi.example.com`,
    # from host `123`, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts/123/iscsidiscover
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action>
    #   <iscsi>
    #     <address>myiscsi.example.com</address>
    #   </iscsi>
    # </action>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the discovery should be performed asynchronously.
    # 
    # @option opts [IscsiDetails] :iscsi The target iSCSI device.
    # 
    # @option opts [Array<String>] :iscsi_targets The iSCSI targets.
    #           *
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def iscsi_discover(opts = {})
      internal_action(:iscsidiscover, :iscsi_targets, ISCSI_DISCOVER, opts)
    end
    
    ISCSI_LOGIN = [
      [:async, TrueClass].freeze,
      [:iscsi, IscsiDetails].freeze,
    ].freeze
    
    private_constant :ISCSI_LOGIN
    
    # 
    # Login to iSCSI targets on the host, using the target details.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the login should be performed asynchronously.
    # 
    # @option opts [IscsiDetails] :iscsi The target iSCSI device.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def iscsi_login(opts = {})
      internal_action(:iscsilogin, nil, ISCSI_LOGIN, opts)
    end
    
    REFRESH = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :REFRESH
    
    # 
    # Refresh the host devices and capabilities.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the refresh should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def refresh(opts = {})
      internal_action(:refresh, nil, REFRESH, opts)
    end
    
    REMOVE = [
      [:async, TrueClass].freeze,
      [:force, TrueClass].freeze,
    ].freeze
    
    private_constant :REMOVE
    
    # 
    # Remove the host from the system.
    # 
    # [source]
    # ----
    # #!/bin/sh -ex
    # 
    # url="https://engine.example.com/ovirt-engine/api"
    # user="admin@internal"
    # password="..."
    # 
    # curl \
    # --verbose \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --user "${user}:${password}" \
    # --request DELETE \
    # --header "Version: 4" \
    # "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the remove should be performed asynchronously.
    # @option opts [Boolean] :force Indicates that the host should be removed even if it is non-responsive,
    #   or if it is part of a Gluster Storage cluster and has volume bricks on it.
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def remove(opts = {})
      internal_remove(REMOVE, opts)
    end
    
    SETUP_NETWORKS = [
      [:async, TrueClass].freeze,
      [:check_connectivity, TrueClass].freeze,
      [:commit_on_success, TrueClass].freeze,
      [:connectivity_timeout, Integer].freeze,
      [:modified_bonds, List].freeze,
      [:modified_labels, List].freeze,
      [:modified_network_attachments, List].freeze,
      [:removed_bonds, List].freeze,
      [:removed_labels, List].freeze,
      [:removed_network_attachments, List].freeze,
      [:synchronized_network_attachments, List].freeze,
    ].freeze
    
    private_constant :SETUP_NETWORKS
    
    # 
    # This method is used to change the configuration of the network interfaces of a host.
    # 
    # For example, if you have a host with three network interfaces `eth0`, `eth1` and `eth2` and you want to configure
    # a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell script and the `curl`
    # command line HTTP client that can be done as follows:
    # 
    # [source]
    # ----
    # #!/bin/sh -ex
    # 
    # url="https://engine.example.com/ovirt-engine/api"
    # user="admin@internal"
    # password="..."
    # 
    # curl \
    # --verbose \
    # --cacert /etc/pki/ovirt-engine/ca.pem \
    # --user "${user}:${password}" \
    # --request POST \
    # --header "Version: 4" \
    # --header "Content-Type: application/xml" \
    # --header "Accept: application/xml" \
    # --data '
    # <action>
    #   <modified_bonds>
    #     <host_nic>
    #       <name>bond0</name>
    #       <bonding>
    #         <options>
    #           <option>
    #             <name>mode</name>
    #             <value>4</value>
    #           </option>
    #           <option>
    #             <name>miimon</name>
    #             <value>100</value>
    #           </option>
    #         </options>
    #         <slaves>
    #           <host_nic>
    #             <name>eth1</name>
    #           </host_nic>
    #           <host_nic>
    #             <name>eth2</name>
    #           </host_nic>
    #         </slaves>
    #       </bonding>
    #     </host_nic>
    #   </modified_bonds>
    #   <modified_network_attachments>
    #     <network_attachment>
    #       <network>
    #         <name>myvlan</name>
    #       </network>
    #       <host_nic>
    #         <name>bond0</name>
    #       </host_nic>
    #       <ip_address_assignments>
    #         <ip_address_assignment>
    #           <assignment_method>static</assignment_method>
    #           <ip>
    #             <address>192.168.122.10</address>
    #             <netmask>255.255.255.0</netmask>
    #           </ip>
    #         </ip_address_assignment>
    #       </ip_address_assignments>
    #       <dns_resolver_configuration>
    #         <name_servers>
    #           <name_server>1.1.1.1</name_server>
    #           <name_server>2.2.2.2</name_server>
    #         </name_servers>
    #       </dns_resolver_configuration>
    #     </network_attachment>
    #   </modified_network_attachments>
    #  </action>
    # ' \
    # "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
    # ----
    # 
    # NOTE: This is valid for version 4 of the API. In previous versions some elements were represented as XML
    # attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
    # 
    # [source,xml]
    # ----
    # <options name="mode" value="4"/>
    # <options name="miimon" value="100"/>
    # <ip address="192.168.122.10" netmask="255.255.255.0"/>
    # ----
    # 
    # The same thing can be done using the Python SDK with the following code:
    # 
    # [source,python]
    # ----
    # # Find the service that manages the collection of hosts:
    # hosts_service = connection.system_service().hosts_service()
    # 
    # # Find the host:
    # host = hosts_service.list(search='name=myhost')[0]
    # 
    # # Find the service that manages the host:
    # host_service = hosts_service.host_service(host.id)
    # 
    # # Configure the network adding a bond with two slaves and attaching it to a
    # # network with an static IP address:
    # host_service.setup_networks(
    #     modified_bonds=[
    #         types.HostNic(
    #             name='bond0',
    #             bonding=types.Bonding(
    #                 options=[
    #                     types.Option(
    #                         name='mode',
    #                         value='4',
    #                     ),
    #                     types.Option(
    #                         name='miimon',
    #                         value='100',
    #                     ),
    #                 ],
    #                 slaves=[
    #                     types.HostNic(
    #                         name='eth1',
    #                     ),
    #                     types.HostNic(
    #                         name='eth2',
    #                     ),
    #                 ],
    #             ),
    #         ),
    #     ],
    #     modified_network_attachments=[
    #         types.NetworkAttachment(
    #             network=types.Network(
    #                 name='myvlan',
    #             ),
    #             host_nic=types.HostNic(
    #                 name='bond0',
    #             ),
    #             ip_address_assignments=[
    #                 types.IpAddressAssignment(
    #                     assignment_method=types.BootProtocol.STATIC,
    #                     ip=types.Ip(
    #                         address='192.168.122.10',
    #                         netmask='255.255.255.0',
    #                     ),
    #                 ),
    #             ],
    #             dns_resolver_configuration=types.DnsResolverConfiguration(
    #                 name_servers=[
    #                     '1.1.1.1',
    #                     '2.2.2.2',
    #                 ],
    #             ),
    #         ),
    #     ],
    # )
    # 
    # # After modifying the network configuration it is very important to make it
    # # persistent:
    # host_service.commit_net_config()
    # ----
    # 
    # IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
    # when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
    # 
    # IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
    # the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
    # configuration is automatically saved in the {hypervisor-name} upon completing the setup and
    # re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
    # waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Boolean] :check_connectivity 
    # 
    # @option opts [Boolean] :commit_on_success Specifies whether to automatically save the configuration in the {hypervisor-name} upon completing
    #   the setup and re-establishing connectivity between the {hypervisor-name} and {engine-name},
    #   and without waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>>
    #   request.
    #   The default value is `false`, which means that the configuration will not be
    #   saved automatically.
    # 
    # @option opts [Integer] :connectivity_timeout 
    # 
    # @option opts [Array<HostNic>] :modified_bonds 
    # 
    # @option opts [Array<NetworkLabel>] :modified_labels 
    # 
    # @option opts [Array<NetworkAttachment>] :modified_network_attachments 
    # 
    # @option opts [Array<HostNic>] :removed_bonds 
    # 
    # @option opts [Array<NetworkLabel>] :removed_labels 
    # 
    # @option opts [Array<NetworkAttachment>] :removed_network_attachments 
    # 
    # @option opts [Array<NetworkAttachment>] :synchronized_network_attachments A list of network attachments that will be synchronized.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def setup_networks(opts = {})
      internal_action(:setupnetworks, nil, SETUP_NETWORKS, opts)
    end
    
    SYNC_ALL_NETWORKS = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :SYNC_ALL_NETWORKS
    
    # 
    # To synchronize all networks on the host, send a request like this:
    # 
    # [source]
    # ----
    # POST /ovirt-engine/api/hosts/123/syncallnetworks
    # ----
    # 
    # With a request body like this:
    # 
    # [source,xml]
    # ----
    # <action/>
    # ----
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the action should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def sync_all_networks(opts = {})
      internal_action(:syncallnetworks, nil, SYNC_ALL_NETWORKS, opts)
    end
    
    UNREGISTERED_STORAGE_DOMAINS_DISCOVER = [
      [:async, TrueClass].freeze,
      [:iscsi, IscsiDetails].freeze,
    ].freeze
    
    private_constant :UNREGISTERED_STORAGE_DOMAINS_DISCOVER
    
    # 
    # Discovers the block Storage Domains which are candidates to be imported to the setup. For FCP no arguments are
    # required.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the discovery should be performed asynchronously.
    # 
    # @option opts [IscsiDetails] :iscsi 
    # 
    # @option opts [Array<StorageDomain>] :storage_domains 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def unregistered_storage_domains_discover(opts = {})
      internal_action(:unregisteredstoragedomainsdiscover, :storage_domains, UNREGISTERED_STORAGE_DOMAINS_DISCOVER, opts)
    end
    
    UPDATE = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE
    
    # 
    # Update the host properties.
    # 
    # For example, to update a the kernel command line of a host send a request like this:
    # 
    # [source]
    # ----
    # PUT /ovirt-engine/api/hosts/123
    # ----
    # 
    # With request body like this:
    # 
    # [source, xml]
    # ----
    # <host>
    #   <os>
    #     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
    #   </os>
    # </host>
    # ----
    # 
    # @param host [Host] The `host` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def update(host, opts = {})
      internal_update(host, Host, UPDATE, opts)
    end
    
    UPGRADE = [
      [:async, TrueClass].freeze,
      [:image, String].freeze,
      [:reboot, TrueClass].freeze,
      [:timeout, Integer].freeze,
    ].freeze
    
    private_constant :UPGRADE
    
    # 
    # Upgrades VDSM and selected software on the host.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the upgrade should be performed asynchronously.
    # 
    # @option opts [String] :image This property is no longer relevant, since Vintage Node is no longer supported, and has been deprecated.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after the upgrade.
    #   By default the host is rebooted.
    #   
    #   NOTE: This parameter is ignored for {hypervisor-name}, which is always rebooted after the upgrade.
    # 
    # @option opts [Integer] :timeout Upgrade timeout.
    #   
    #   The maximum time to wait for upgrade to finish in minutes.
    #   Default value is specified by `ANSIBLE_PLAYBOOK_EXEC_DEFAULT_TIMEOUT` configration option.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def upgrade(opts = {})
      internal_action(:upgrade, nil, UPGRADE, opts)
    end
    
    UPGRADE_CHECK = [
    ].freeze
    
    private_constant :UPGRADE_CHECK
    
    # 
    # Check if there are upgrades available for the host. If there are upgrades available an icon will be displayed
    # next to host status icon in the Administration Portal. Audit log messages are also added to indicate the
    # availability of upgrades. The upgrade can be started from the webadmin or by using the
    # <<services/host/methods/upgrade, upgrade>> host action.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def upgrade_check(opts = {})
      internal_action(:upgradecheck, nil, UPGRADE_CHECK, opts)
    end
    
    APPROVE_USING_ROOT_PASSWORD = [
      [:activate, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:host, Host].freeze,
      [:reboot, TrueClass].freeze,
    ].freeze
    
    private_constant :APPROVE_USING_ROOT_PASSWORD
    
    # 
    # Executes the `approve_using_root_password` method.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to 'true', this host will be activated after its approval completes. When set to 'false'
    #   the host will remain in 'maintenance' status after its approval. Absence of this parameter will be
    #   interpreted as 'true', since the desired default behavior is activating the host after approval.
    # 
    # @option opts [Boolean] :async Indicates if the approval should be performed asynchronously.
    # 
    # @option opts [Cluster] :cluster The cluster where the host will be added after it is approved.
    # 
    # @option opts [Host] :host The host to approve.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def approve_using_root_password(opts = {})
      internal_action(:approve, nil, APPROVE_USING_ROOT_PASSWORD, opts)
    end
    
    INSTALL_USING_ROOT_PASSWORD = [
      [:activate, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:deploy_hosted_engine, TrueClass].freeze,
      [:host, Host].freeze,
      [:image, String].freeze,
      [:reboot, TrueClass].freeze,
      [:root_password, String].freeze,
      [:ssh, Ssh].freeze,
      [:undeploy_hosted_engine, TrueClass].freeze,
    ].freeze
    
    private_constant :INSTALL_USING_ROOT_PASSWORD
    
    # 
    # Install VDSM and other packages required to get the host ready to be used in the engine providing the root
    # password. This has been deprecated.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to 'true', this host will be activated after its installation completes. When set to 'false'
    #   the host will remain in 'maintenance' status after its installation. Absence of this parameter will be
    #   interpreted as 'true', since the desired default behavior is activating the host after install.
    # 
    # @option opts [Boolean] :async Indicates if the installation should be performed asynchronously.
    # 
    # @option opts [Boolean] :deploy_hosted_engine When set to `true` this host will also deploy the self-hosted engine components. A missing value
    #   is treated as `true` i.e deploy. Omitting this parameter means `false` and will not perform any operation in the
    #   self-hosted engine area.
    # 
    # @option opts [Host] :host The `override_iptables` property is used to indicate if the firewall configuration should be replaced by the
    #   default one.
    # 
    # @option opts [String] :image When installing {hypervisor-name}, an ISO image file is required.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [String] :root_password The password of the `root` user used to connect to the host via SSH.
    # 
    # @option opts [Ssh] :ssh The SSH details used to connect to the host.
    # 
    # @option opts [Boolean] :undeploy_hosted_engine When set to `true` this host will un-deploy the self-hosted engine components, and this host will
    #   not function as part of the High Availability cluster. A missing value is treated as `true` i.e un-deploy.
    #   Omitting this parameter means `false` and will not perform any operation in the self-hosted engine area.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def install_using_root_password(opts = {})
      internal_action(:install, nil, INSTALL_USING_ROOT_PASSWORD, opts)
    end
    
    UPDATE_USING_ROOT_PASSWORD = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_USING_ROOT_PASSWORD
    
    # 
    # Update the specified host in the system. This is deprecated and is provided only for backwards compatibility.
    # 
    # @param host [Host] The `host` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def update_using_root_password(host, opts = {})
      internal_update(host, Host, UPDATE_USING_ROOT_PASSWORD, opts)
    end
    
    APPROVE_USING_SSH = [
      [:activate, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:cluster, Cluster].freeze,
      [:host, Host].freeze,
      [:reboot, TrueClass].freeze,
    ].freeze
    
    private_constant :APPROVE_USING_SSH
    
    # 
    # Approve the specified host to be added to the engine by using ssh authentication. This occurs when the host
    # registers itself with the engine.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to 'true', this host will be activated after its approval completes. When set to 'false'
    #   the host will remain in 'maintenance' status after its approval. Absence of this parameter will be
    #   interpreted as 'true', since the desired default behavior is activating the host after approval.
    # 
    # @option opts [Boolean] :async Indicates if the approval should be performed asynchronously.
    # 
    # @option opts [Cluster] :cluster The cluster where the host will be added after it is approved.
    # 
    # @option opts [Host] :host The host to approve.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def approve_using_ssh(opts = {})
      internal_action(:approve, nil, APPROVE_USING_SSH, opts)
    end
    
    INSTALL_USING_SSH = [
      [:activate, TrueClass].freeze,
      [:async, TrueClass].freeze,
      [:deploy_hosted_engine, TrueClass].freeze,
      [:host, Host].freeze,
      [:image, String].freeze,
      [:reboot, TrueClass].freeze,
      [:root_password, String].freeze,
      [:ssh, Ssh].freeze,
      [:undeploy_hosted_engine, TrueClass].freeze,
    ].freeze
    
    private_constant :INSTALL_USING_SSH
    
    # 
    # Install VDSM and other packages required to get the host ready to be used in the engine providing the SSH
    # password.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :activate When set to 'true', this host will be activated after its installation completes. When set to 'false'
    #   the host will remain in 'maintenance' status after its installation. Absence of this parameter will be
    #   interpreted as 'true', since the desired default behavior is activating the host after install.
    # 
    # @option opts [Boolean] :async Indicates if the installation should be performed asynchronously.
    # 
    # @option opts [Boolean] :deploy_hosted_engine When set to `true` this host will also deploy the self-hosted engine components. A missing value
    #   is treated as `true` i.e deploy. Omitting this parameter means `false` and will not perform any operation in the
    #   self-hosted engine area.
    # 
    # @option opts [Host] :host The `override_iptables` property is used to indicate if the firewall configuration should be replaced by the
    #   default one.
    # 
    # @option opts [String] :image When installing {hypervisor-name}, an ISO image file is required.
    # 
    # @option opts [Boolean] :reboot Indicates if the host should be rebooted after successful installation. The default value is `true`.
    # 
    # @option opts [String] :root_password The password of the `root` user used to connect to the host via SSH.
    # 
    # @option opts [Ssh] :ssh The SSH details used to connect to the host.
    # 
    # @option opts [Boolean] :undeploy_hosted_engine When set to `true` this host will un-deploy the self-hosted engine components, and this host will
    #   not function as part of the High Availability cluster. A missing value is treated as `true` i.e un-deploy.
    #   Omitting this parameter means `false` and will not perform any operation in the self-hosted engine area.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def install_using_ssh(opts = {})
      internal_action(:install, nil, INSTALL_USING_SSH, opts)
    end
    
    UPDATE_USING_SSH = [
      [:async, TrueClass].freeze,
    ].freeze
    
    private_constant :UPDATE_USING_SSH
    
    # 
    # Updates the specified host in the system.
    # 
    # @param host [Host] The `host` to update.
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [Host]
    # 
    def update_using_ssh(host, opts = {})
      internal_update(host, Host, UPDATE_USING_SSH, opts)
    end
    
    # 
    # List of scheduling labels assigned to this host.
    # 
    # @return [AssignedAffinityLabelsService] A reference to `affinity_labels` service.
    # 
    def affinity_labels_service
      @affinity_labels_service ||= AssignedAffinityLabelsService.new(self, 'affinitylabels')
    end
    
    # 
    # A reference to the host devices service. Use this service to view the devices of the host object.
    # 
    # @return [HostDevicesService] A reference to `devices` service.
    # 
    def devices_service
      @devices_service ||= HostDevicesService.new(self, 'devices')
    end
    
    # 
    # External network providers provisioned by the system on the host.
    # 
    # @return [ExternalNetworkProviderConfigurationsService] A reference to `external_network_provider_configurations` service.
    # 
    def external_network_provider_configurations_service
      @external_network_provider_configurations_service ||= ExternalNetworkProviderConfigurationsService.new(self, 'externalnetworkproviderconfigurations')
    end
    
    # 
    # A reference to the fence agents service. Use this service to manage fence and power management agents on the host
    # object.
    # 
    # @return [FenceAgentsService] A reference to `fence_agents` service.
    # 
    def fence_agents_service
      @fence_agents_service ||= FenceAgentsService.new(self, 'fenceagents')
    end
    
    # 
    # A reference to the host hooks service. Use this service to view the hooks available in the host object.
    # 
    # @return [HostHooksService] A reference to `hooks` service.
    # 
    def hooks_service
      @hooks_service ||= HostHooksService.new(self, 'hooks')
    end
    
    # 
    # A reference to the service that can show the applicable errata available on the host. This information is taken
    # from Katello.
    # 
    # @return [KatelloErrataService] A reference to `katello_errata` service.
    # 
    def katello_errata_service
      @katello_errata_service ||= KatelloErrataService.new(self, 'katelloerrata')
    end
    
    # 
    # A reference to the network attachments service. You can use this service to attach Logical networks to host
    # interfaces.
    # 
    # @return [NetworkAttachmentsService] A reference to `network_attachments` service.
    # 
    def network_attachments_service
      @network_attachments_service ||= NetworkAttachmentsService.new(self, 'networkattachments')
    end
    
    # 
    # A reference to the service that manages the network interface devices on the host.
    # 
    # @return [HostNicsService] A reference to `nics` service.
    # 
    def nics_service
      @nics_service ||= HostNicsService.new(self, 'nics')
    end
    
    # 
    # A reference to the service that manage NUMA nodes for the host.
    # 
    # @return [HostNumaNodesService] A reference to `numa_nodes` service.
    # 
    def numa_nodes_service
      @numa_nodes_service ||= HostNumaNodesService.new(self, 'numanodes')
    end
    
    # 
    # A reference to the host permission service.
    # Use this service to manage permissions on the host object.
    # 
    # @return [AssignedPermissionsService] A reference to `permissions` service.
    # 
    def permissions_service
      @permissions_service ||= AssignedPermissionsService.new(self, 'permissions')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # A reference to the service that manages the host's storage.
    # 
    # @return [HostStorageService] A reference to `storage` service.
    # 
    def storage_service
      @storage_service ||= HostStorageService.new(self, 'storage')
    end
    
    # 
    # A reference to storage connection extensions.
    # 
    # @return [StorageServerConnectionExtensionsService] A reference to `storage_connection_extensions` service.
    # 
    def storage_connection_extensions_service
      @storage_connection_extensions_service ||= StorageServerConnectionExtensionsService.new(self, 'storageconnectionextensions')
    end
    
    # 
    # A reference to the host tags service. Use this service to manage tags on the host object.
    # 
    # @return [AssignedTagsService] A reference to `tags` service.
    # 
    def tags_service
      @tags_service ||= AssignedTagsService.new(self, 'tags')
    end
    
    # 
    # A reference to unmanaged networks.
    # 
    # @return [UnmanagedNetworksService] A reference to `unmanaged_networks` service.
    # 
    def unmanaged_networks_service
      @unmanaged_networks_service ||= UnmanagedNetworksService.new(self, 'unmanagednetworks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'affinitylabels'
        return affinity_labels_service
      end
      if path.start_with?('affinitylabels/')
        return affinity_labels_service.service(path[15..-1])
      end
      if path == 'devices'
        return devices_service
      end
      if path.start_with?('devices/')
        return devices_service.service(path[8..-1])
      end
      if path == 'externalnetworkproviderconfigurations'
        return external_network_provider_configurations_service
      end
      if path.start_with?('externalnetworkproviderconfigurations/')
        return external_network_provider_configurations_service.service(path[38..-1])
      end
      if path == 'fenceagents'
        return fence_agents_service
      end
      if path.start_with?('fenceagents/')
        return fence_agents_service.service(path[12..-1])
      end
      if path == 'hooks'
        return hooks_service
      end
      if path.start_with?('hooks/')
        return hooks_service.service(path[6..-1])
      end
      if path == 'katelloerrata'
        return katello_errata_service
      end
      if path.start_with?('katelloerrata/')
        return katello_errata_service.service(path[14..-1])
      end
      if path == 'networkattachments'
        return network_attachments_service
      end
      if path.start_with?('networkattachments/')
        return network_attachments_service.service(path[19..-1])
      end
      if path == 'nics'
        return nics_service
      end
      if path.start_with?('nics/')
        return nics_service.service(path[5..-1])
      end
      if path == 'numanodes'
        return numa_nodes_service
      end
      if path.start_with?('numanodes/')
        return numa_nodes_service.service(path[10..-1])
      end
      if path == 'permissions'
        return permissions_service
      end
      if path.start_with?('permissions/')
        return permissions_service.service(path[12..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      if path == 'storage'
        return storage_service
      end
      if path.start_with?('storage/')
        return storage_service.service(path[8..-1])
      end
      if path == 'storageconnectionextensions'
        return storage_connection_extensions_service
      end
      if path.start_with?('storageconnectionextensions/')
        return storage_connection_extensions_service.service(path[28..-1])
      end
      if path == 'tags'
        return tags_service
      end
      if path.start_with?('tags/')
        return tags_service.service(path[5..-1])
      end
      if path == 'unmanagednetworks'
        return unmanaged_networks_service
      end
      if path.start_with?('unmanagednetworks/')
        return unmanaged_networks_service.service(path[18..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class HostNicService < MeasurableService
    
    GET = [
      [:all_content, TrueClass].freeze,
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :all_content Indicates if all of the attributes of the host network interface should be included in the response.
    #   
    #   By default the following attributes are excluded:
    #   
    #   - `virtual_functions_configuration`
    #   
    #   For example, to retrieve the complete representation network interface '456' of host '123':
    #   
    #   ....
    #   GET /ovirt-engine/api/hosts/123/nics/456?all_content=true
    #   ....
    #   
    #   NOTE: These attributes are not included by default because retrieving them impacts performance. They are
    #   seldom used and require additional queries to the database. Use this parameter with caution and only when
    #   specifically required.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [HostNic]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    UPDATE_VIRTUAL_FUNCTIONS_CONFIGURATION = [
      [:async, TrueClass].freeze,
      [:virtual_functions_configuration, HostNicVirtualFunctionsConfiguration].freeze,
    ].freeze
    
    private_constant :UPDATE_VIRTUAL_FUNCTIONS_CONFIGURATION
    
    # 
    # The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
    # The input should be consisted of at least one of the following properties:
    # 
    # - `allNetworksAllowed`
    # - `numberOfVirtualFunctions`
    # 
    # Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [Boolean] :async Indicates if the update should be performed asynchronously.
    # 
    # @option opts [HostNicVirtualFunctionsConfiguration] :virtual_functions_configuration 
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    def update_virtual_functions_configuration(opts = {})
      internal_action(:updatevirtualfunctionsconfiguration, nil, UPDATE_VIRTUAL_FUNCTIONS_CONFIGURATION, opts)
    end
    
    # 
    # A reference to information elements received by LLDP on the NIC.
    # 
    # @return [LinkLayerDiscoveryProtocolService] A reference to `link_layer_discovery_protocol_elements` service.
    # 
    def link_layer_discovery_protocol_elements_service
      @link_layer_discovery_protocol_elements_service ||= LinkLayerDiscoveryProtocolService.new(self, 'linklayerdiscoveryprotocolelements')
    end
    
    # 
    # Reference to the service that manages the network attachments assigned to this network interface.
    # 
    # @return [NetworkAttachmentsService] A reference to `network_attachments` service.
    # 
    def network_attachments_service
      @network_attachments_service ||= NetworkAttachmentsService.new(self, 'networkattachments')
    end
    
    # 
    # Reference to the service that manages the network labels assigned to this network interface.
    # 
    # @return [NetworkLabelsService] A reference to `network_labels` service.
    # 
    def network_labels_service
      @network_labels_service ||= NetworkLabelsService.new(self, 'networklabels')
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Retrieves sub-collection resource of network labels that are allowed on an the virtual functions
    # in case that the current resource represents an SR-IOV physical function NIC.
    # 
    # @return [NetworkLabelsService] A reference to `virtual_function_allowed_labels` service.
    # 
    def virtual_function_allowed_labels_service
      @virtual_function_allowed_labels_service ||= NetworkLabelsService.new(self, 'virtualfunctionallowedlabels')
    end
    
    # 
    # Retrieves sub-collection resource of networks that are allowed on an the virtual functions
    # in case that the current resource represents an SR-IOV physical function NIC.
    # 
    # @return [VirtualFunctionAllowedNetworksService] A reference to `virtual_function_allowed_networks` service.
    # 
    def virtual_function_allowed_networks_service
      @virtual_function_allowed_networks_service ||= VirtualFunctionAllowedNetworksService.new(self, 'virtualfunctionallowednetworks')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'linklayerdiscoveryprotocolelements'
        return link_layer_discovery_protocol_elements_service
      end
      if path.start_with?('linklayerdiscoveryprotocolelements/')
        return link_layer_discovery_protocol_elements_service.service(path[35..-1])
      end
      if path == 'networkattachments'
        return network_attachments_service
      end
      if path.start_with?('networkattachments/')
        return network_attachments_service.service(path[19..-1])
      end
      if path == 'networklabels'
        return network_labels_service
      end
      if path.start_with?('networklabels/')
        return network_labels_service.service(path[14..-1])
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      if path == 'virtualfunctionallowedlabels'
        return virtual_function_allowed_labels_service
      end
      if path.start_with?('virtualfunctionallowedlabels/')
        return virtual_function_allowed_labels_service.service(path[29..-1])
      end
      if path == 'virtualfunctionallowednetworks'
        return virtual_function_allowed_networks_service
      end
      if path.start_with?('virtualfunctionallowednetworks/')
        return virtual_function_allowed_networks_service.service(path[31..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
  class HostNumaNodeService < MeasurableService
    
    GET = [
      [:follow, String].freeze,
    ].freeze
    
    private_constant :GET
    
    # 
    # Returns the representation of the object managed by this service.
    # 
    # @param opts [Hash] Additional options.
    # 
    # @option opts [String] :follow Indicates which inner links should be _followed_. The objects referenced by these links will be fetched as part
    #   of the current request. See <<documents/003_common_concepts/follow, here>> for details.
    # 
    # @option opts [Hash] :headers ({}) Additional HTTP headers.
    # 
    # @option opts [Hash] :query ({}) Additional URL query parameters.
    # 
    # @option opts [Integer] :timeout (nil) The timeout for this request, in seconds. If no value is explicitly 
    #   given then the timeout set globally for the connection will be used.
    # 
    # @option opts [Boolean] :wait (true) If `true` wait for the response.
    # 
    # @return [NumaNode]
    # 
    def get(opts = {})
      internal_get(GET, opts)
    end
    
    # 
    # Locates the `statistics` service.
    # 
    # @return [StatisticsService] A reference to `statistics` service.
    # 
    def statistics_service
      @statistics_service ||= StatisticsService.new(self, 'statistics')
    end
    
    # 
    # Locates the service corresponding to the given path.
    # 
    # @param path [String] The path of the service.
    # 
    # @return [Service] A reference to the service.
    # 
    def service(path)
      if path.nil? || path == ''
        return self
      end
      if path == 'statistics'
        return statistics_service
      end
      if path.start_with?('statistics/')
        return statistics_service.service(path[11..-1])
      end
      raise Error.new("The path \"#{path}\" doesn't correspond to any service")
    end
    
  end
  
end

